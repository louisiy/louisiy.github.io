---
title: 操作系统笔记
date: 2024-03-04 19:18:00
tags: Operation System
---

## 概述

### 指令

指令是计算机运行的最小的功能单元，是指挥计算机硬件运行的命令

- 算术运算指令
- 逻辑运算指令
- 移位操作指令
- 数据传送指令
- 输入输出指令
- 转移指令等

操作码 + 操作数

在硬件和应用软件之间引入操作系统

- 管理系统的各个部件，使之能正常运转；
- 给上层的应用软件提供一个易于理解和编程的接口

### 操作系统发展历史

- 1946-1950
  - 机器语言，纸带或卡片
- 50年代末-60年代中
  - 批处理管理程序
  - 串行执行，单道批处理
  - 60年代初发展了通道与中断技术
- 60年代中-70年代中
  - 现代意义上的操作系统的出现
  - 多道批处理系统
- 70年代中-至今
  - 分时系统
    - CTSS
    - MULTICS
    - UNIX
- 个人计算机操作系统

### 操作系统类型

- 批处理操作系统（多道批处理）
- 分时操作系统
- 实时操作系统
- 嵌入式系统
- 个人计算机操作系统
- 分布式操作系统

### 操作系统需要的硬件特性

#### 受保护的指令

- 对某些硬件资源直接访问的指令
- 对内存管理状态进行操作的指令
- 某些特殊的状态位的设置指令

- 停机指令

根据运行程序对资源和机器指令的使用权限，把处理器设置为不同状态

- 管态：操作系统的管理程序运行时的状态，较高的特权级别，又称为特权态、系统态、内核态，处于该状态时可以执行所有的指令（包括特权指令）、使用所有的资源，并具有改变处理器状态的能力
- 目态：用户程序运行时的状态，较低的特权级别，又称为普通态（普态）、用户态。在此状态下禁止使用特权指令，不能直接使用系统资源与改变CPU状态，并且只能访问用户程序所在的存储空间

有的系统分为核心状态，管理状态和用户程序状态（目标状态）三种

程序状态字PSW (Program Status Word )一个专门的寄存器，用来指示处理器的状态，包括

- CPU的工作状态码
- 条件码
- 中断屏蔽码

![image-20240311204447522](https://cdn.jsdelivr.net/gh/louisiy/ImageStorage/img/image-20240311204447522.png)

#### 系统调用

用户程序通过特殊的访管指令，来请求操作系统为其提供某种功能的服务

- 当CPU执行访管指令时，即引起访管中断；
- 处理器保存中断点的程序执行上下文环境（PSW,    PC和其他的一些寄存器），CPU切换到内核态。
- 中断处理程序开始工作，调用相应的系统服务；
- 中断处理结束后，恢复被中断程序的上下文环境，CPU恢复为用户态，回到中断点继续执行。

#### 内存保护

- 防止一个用户程序去访问其他用户 程序的数据；
- 保护操作系统免受用户程序的破坏。

最简单的做法：基址寄存器和边界寄存器。在开始运行一个程序时，由操作系统负责给基址寄存器和边界寄存器设置相应的值

虚拟存储技术：把内存和外存结合起来使用，硬件提供虚、实地址映射的机制。

#### 中断机制

- 同步中断：指当CPU正在执行指令的时候，由CPU的控制单元所发出的中断，也称为“异常”
  - CPU检测到的异常，包括：错误Fault、陷阱Trap和中止Abort，例如：算术溢出、被零除、用户态下使用了特权指令等；
  - 程序设定的异常，即程序员通过int、int3等指令来发出的中断请求，也称为软中断，主要用来实现系统调用服务。
- 异步中断：指由其他的硬件设备在任意的时刻所发出的中断，简称为“中断” ；
  - 可屏蔽中断，即I/O中断，它是当外部设备或通道操作正常结束或发生错误时所发生的中断。例如：打印机打印完成、缺纸，读磁盘时驱动器中没有磁盘等；
  - 不可屏蔽中断，例如：由掉电、存储器校验错等硬件故障引起的硬件中断；

每一个中断或异常都用一个0－255之间的整数来标识，称为中断向量，系统根据中断向量，来为每一个中断或异常指定相应的处理程序

#### I/O系统

完成计算机系统中信息的输入输出功能

#### 时钟操作

时钟是操作系统运行时必不可少的硬件设施，在操作系统中需要时钟支持的工作有：

- 在分时系统中，间隔时钟实现进程间按时间片轮转；
- 在实时系统中，按要求的间隔输出正确的时间信号给实时的控制设备；
- 记录用户和系统所需的绝对时间（年、月、日、时、分、秒）。

## 进程管理

### 进程 process

#### 前置知识

CPU

![image-20240311192818883](https://cdn.jsdelivr.net/gh/louisiy/ImageStorage/img/image-20240311192818883.png)

- 控制单元
  - 能够正确并且自动地连续执行指令
  - 能正确并分步完成每一条指令的功能读取指令、分析指令、控制执行
  - 响应并处理中断
- 执行单元
  - CPU的“计算器”
  - 分为不同的功能部件，包括算术逻辑单元（ALU，+-*/）、移位器、乘法器、除法器、分支单元等
  - 来自控制单元的信号选择不同的功能部件
- 寄存器组
  - General-purpose register
  - Segment register
  - EFLAGS register
  - EIP

虚拟/物理计算机

- 虚拟CPU
- 虚拟内存
  - 栈
  - 堆
  - 静态数据
  - 代码

#### 进程基本

process = program in execution

一个进程应该包括：

- 程序的代码；
- 程序的数据；
- CPU寄存器的值，如PC，用来指示下一条将运行     的指令、通用寄存器等；
- 堆、栈；
- 一组系统资源（如地址空间、打开的文件）

总之，进程包含了正在运行的一个程序的所有状态信息。

栈Stack

- 只允许在一端插入和删除。允许插入和删除的一端称为栈顶 (top)，另一端称为栈底 (bottom)
- 特点：后进先出(LIFO)
- 栈的主要操作
  - 进栈 Push
  - 出栈 Pop
- 栈的用途
  - 用于暂存功能，在程序运行时保存运行上下文信息
  - 在函数调用发生时，保存被调用函数的局部变量和形参

堆Heap

- 内存中的一块空间，用于动态分配；
- 在C语言中，通过malloc来申请动态内存空间，通过free来释放；
- 使用不当可能导致内存泄漏。

#### 进程的特性

- 动态性：程序的运行状态在变，PC、寄存器、堆和栈等；
- 独立性：是一个独立的实体，是计算机系统资源的使用单位。每个进程在一个“虚拟计算机”上运行，每个进程都有“自己”的PC和内部状态，运行时独立于其他的进程（虚拟PC和物理PC）；
- 并发性：从宏观上看各进程是同时独立运行的

#### 进程的创建

引起进程创建的三个主要事件：

- 系统初始化时；
- 在一个正在运行的进程当中，执行了创建进程的系统调用；
- 用户请求创建一个新进程。

从技术上来说，只有一种创建进程的方法，即在一个已经存在的进程（用户进程或系统
进程）当中，通过系统调用来创建一个新的进程。

- Unix：`fork`函数；
- Windows：`CreateProcess`函数;

#### 进程的状态

进程的三种基本状态：

- 运行状态（Running）：进程占有CPU，并在CPU上运行。处于此状态的进程数目小于等于CPU的数目。
- 就绪状态（Ready）：进程已经具备运行条件，但由于CPU忙暂时不能运行，只要分得CPU即可执行；
- 阻塞状态（Blocked）：指进程因等待某种事件的发生而暂时不能运行的状态（如I/O操作或进程同步）,此时，即使CPU空闲，该进程也不能运行。

进程转换

- 运行 --> 阻塞
  - 等待I/O的结果
  - 等待某一进程提供输入
- 运行 --> 就绪
  - 运行进程用完了时间片
  - 运行进程被中断，因为一高优先级进程处于就绪状态
- 就绪 --> 运行
  - 调度程序选择一个新的进程运行
- 阻塞 --> 就绪
  - 当所等待的事件发生时

描述进程的数据结构：进程控制块（Process  Control  Block，PCB）

系统为每个进程都维护了一个PCB，用来保存与该进程有关的各种状态信息

虚拟CPU即为存放在PCB中的内存变量

系统用PCB来描述进程的基本情况以及运行变化的过程，PCB是进程存在的唯一标志

#### 状态对列

- 操作系统来维护一组队列，用来表示系统当中所有进程的当前状态；
- 不同的状态分别用不同的队列来表示（运行队列、就绪队列、各种类型的阻塞队列）；
- 每个进程的PCB都根据它的状态加入到相应的队列当中，当一个进程的状态发生变化时，它的PCB从一个状态队列中脱离出来，加入到另外一个队列。

使用链表实现

### 线程 thread

进程  ＝  线程 ＋ 资源平台

- 一个进程中可以同时存在多个线程
- 各个线程之间可以并发地执行
- 各个线程之间可以共享地址空间

TCP

线程与进程比较

- 进程是资源分配单位和操作系统保护单位，线程     是CPU调度单位；
- 进程拥有一个完整的资源平台，如代码、数据和     堆，而线程只独享必不可少的资源如寄存器和栈
- 线程同样具有就绪、阻塞和执行三种基本状态，     同样具有状态之间的转换关系；
- 线程能减少并发执行的时间和空间开销；
- 线程 ＝ 轻量级进程（lightweight  process）

### 进程间通信

进程之间的信息交流与协调

并发进程之间的两种关系：

- 相互独立：进程之间没有任何关联关系，仅有CPU竞争关系；
- 相互关联：进程之间存在着某种关联关系（直接或间接），需要相互通信。

进程间通信方式

- 低级通信：只能传递状态和整数值（控制信息）
  - 信号量（semaphore）
  - 信号（signal）
- 高级通信：能够传送任意数量的数据
  - 共享内存（shared memory）
  - 消息传递（message passing）
  - 管道（pipe）

进程互斥的产生原因

- 进程宏观上并发执行，依靠时钟中断来实现微观上轮流执行；
- 访问共享资源。

竞争状态

两个或多个进程对同一共享数据同时进行读写操作，而最后的结果是不可预测的，它取决于各个进程具体运行情况。在同一时刻，只允许一个进程访问该共享数据

对共享内存或共享文件的访问，可能会导致竞争状态的出现，把完成这类事情的那段程     序称为“临界区”，把需要互斥访问的共享资     源称为“临界资源”。

实现互斥访问的四个条件

- 任何两个进程都不能同时进入临界区；
- 不能事先假定CPU的个数和运行速度；
- 当一个进程运行在它的临界区外面时，不能妨碍其他的进程进入临界区；
- 任何一个进程进入临界区的要求应该在有限时间内得到满足。

#### 实现

##### 基于关闭中断的互斥实现

当一个进程进入临界区后，关闭所有的中断；当它退出临界区时，再打开中断。

- 进程的切换是由中断引发的，关闭中断后，CPU不会被分配给其他进程，其他进程无法执行；
- 操作系统内核经常使用这种方法来更新内部的数据结构（变量、链表等）

##### 基于繁忙等待的互斥实现

- 加锁标志位法

lock的初始值为0，当一个进程想进入临界区时，先查看lock的值，若为1，说明已有进程在临界区内，只好循环等待。等它变成了0，才可进入。

缺点：可能出现针对lock的竞争状态问题。

- 强制轮流法

基本思想：每个进程严格地按照轮流的顺序来进入临界区。

优点：保证在任何时刻最多只有一个进程在临界区
缺点：违反了互斥访问四条件中的第三个条件

- Peterson方法

当一个进程想进入临界区时，先调用enter_region函数，判断是否能安全进入，不能的话等待；当它从临界区退出后，需调用leave_region函数，允许其它进程进入临界区。两个函数的参数均为进程号。

基于繁忙等待的互斥实现缺点

- 浪费CPU时间；

- 可能导致预料之外的结果（如：一个低优先级进程位于临界区中，这时有一个高优先级的进程也试图进入临界区）

##### 信号量

semaphore

取值可正可负，正数表示当前空闲资源的数量，负数的绝对值表示正在等待进入临界区的进程个数。

由操作系统来维护，用户进程只能通过初始化和两个标准原语（P、V原语）来访问。初始化可指定一个非负整数，即空闲资源总数。

> 原语不会被中断

- P、V原语包含有进程的阻塞和唤醒机制，因此在进程等待进入临界区时不会浪费CPU时间；

- P原语：申请一个空闲资源（把信号量减1），若成功，则退出；若失败，则该进程被阻塞；
- V原语：释放一个被占用的资源（把信号量加1），若发现有被阻塞的进程，则选择一个唤醒之

信号量与PV原语的实现

```c
typedef struct{
    int   count;			// 计数变量
    struct  PCB *queue;	    // 进程等待队列
} semaphore;

P( semaphore  S){
    --S.count;		    //表示申请一个资源;
    if (S.count < 0){	//表示没有空闲资源;
      该进程进入等待队列S.queue末尾;
      阻塞该进程;
      调用进程调度器；     // OSSched( )
    }
}

V( semaphore  S){
    ++S.count;		    //表示释放一个资源;
    if (S.count <= 0){  //表示有进程被阻塞;
      从等待队列S.queue中取出一个进程;
      把该进程改为就绪状态，插入就绪队列
    }
}
```

- Windows
  - CreateSemaphore（创建信号量）
  - WaitForSingleObject（P操作）
  - ReleaseSemaphore（V操作）
- COS-II
  - osSemCreate（创建信号量）
  - osSemPend （P操作）
  - osSemPost（V操作）
- Python
  - threading.Semaphore类
  - ```python
    Semaphore(value = 1)
    acquire(blocking = True, timeout=None)
    release(n=1)
    ```
    
    - value：构造函数的参数，默认为1，即互斥
    - acquire：相当于P原语，申请一个资源，若成功则退出，若失败则阻塞当前线程
    - release：相当于V原语，释放一个资源，若当前有线程被阻塞，则唤醒

利用信号量来实现进程互斥

``` c
int count;
semaphore mutex; //初始化为1
```

``` c
//各进程
非临界区
P(mutex);
临界区
V(mutex);
非临界区
```

进程间同步

指多个进程中发生的事件存在某种时序关系，因此在各个进程之间必须协同合作，相互配合，使各个进程按一定的速度执行，以共同完成某一项任务。

- 同步：合作

- 互斥：竞争

只考虑基于信号量的同步问题。

先A执行后B执行实现

![image-20240401203905784](https://cdn.jsdelivr.net/gh/louisiy/ImageStorage/img/image-20240401203905784.png)

### 进程调度

调度器

``` C
if ( readyProcesses(PCBs) ) {
	nextPCB = selectProcess(PCBs);
	run( nextPCB );
} else {
	run_idle_process();
}
```

CPU繁忙（CPU-bound）的进程：大部分时间   处于运行和就绪状态；
I/O繁忙（I/O-bound）的进程：大部分时间处   于阻塞状态。

两种调度方式

- 不可抢占调度方式：一个进程若被选中，就一直运行下去，直到它被阻塞（I/O，或正在等待其他的进程），或主动地交出CPU。以上的情形1－3均可发生调度；
- 可抢占调度方式：当一个进程在运行时，调度程序可以打断它。以上的情形1－5均可发生调度

#### 算法

时间片轮转法

- 在时间片轮转算法（Round-Robin，RR）中，将所有的就绪进程按照FCFS原则，排成一个队列；
- 每次调度时将处理器分派给队首进程，让其执行一小段CPU时间（时间片）；
- 在一个时间片结束时，如果进程还没有执行完的话，在时钟中断中，进程调度程序将暂停当前进程的执行，并将其送到就绪队列的末尾，然后执行当前的队首进程；
- 如果一个进程在它的时间片用完之前就已结束或被阻塞，那么立即让出CPU。

优点

- 公平性：各个就绪进程平均地分配CPU的使用时间。假设有n个就绪进程， 那么每个进程将得到1/n的CPU时间；
- 活动性：若时间片大小为q，每个进程最多等待(n-1)q时间就能够再次得到CPU去运行。 

缺点：q的大小难以确定

- q太大：退化为FCFS算法，进程在一个时间片内执行完或被阻塞，响应时间长。如q=100ms；
- q太小：每个进程需要更多时间片才能处理完，进程切换次数增加(1ms)，增大系统开销；
- 一般在20－50ms

优先级算法

给每个进程设置一个优先级，然后在所有就绪进程中选择优先级最高的那个进程去运行；

可以把进程按照不同的优先级别分组，然后在不同级别之间使用优先级算法，而在同一级别的各个进程之间使用时间片轮转法。

饥饿（Starvation）：低优先级的进程始终得不到CPU去运行

解决办法：动态优先级。

优先级反转

- T1 优先级高、T2 优先级低
  - T2 获得了锁 L 
  - T1 试图去获取L，失败，被阻塞。T3 进入系统，其优先级高于T2、低于T1。 T2 无法运行。

## 储存管理

### 储存管理概述

理想的存储器

更大、更快、更便宜的非易失性存储器

存储器系统的层次结构

- 寄存器
- 高速缓存
  - Cache
- 主存储器
  - DRAM
- 外部存储器
  - 硬盘、光盘、U盘

工作原理

- 一个内存中包含有许多存储单元，每个单元可以存放一个适当单位的信息
- 全部存储单元按一定顺序编号，这种编号称为存储器的地址。对各个存储单元的读写操作就是通过它们的地址来进行的

### 单道程序储存管理

内存分为两个区域：系统区，用户区。

每次把一个应用程序装入到用户区运行，由它和操作系统来共享内存。当它运行结束后，操作系统再装入一个新的程序把它覆盖

![image-20240415195340799](https://cdn.jsdelivr.net/gh/louisiy/ImageStorage/img/image-20240415195340799.png)

优点

- 简单、开销小，易于管理；
- 适合于单用户、单任务的OS

缺点

- 每次只能运行一个程序
- 内存资源的使用效率不高
  - 程序较小时，会浪费大量的内存空间
- OS的保护
  - 应用程序的bug会破坏OS
- 地址空间有限
  - 即为物理内存的大小

多道存储管理需考虑

- 内存管理
- 内存分配
- 内存回收
- 地址重定位
- 内存保护
- 内存共享

### 分区储存管理

内存分为两大区域：系统区，用户区。又把用户区划分为若干分区(partition)。一个进程占用一个分区

特点：适合多道程序系统和分时系统，支持多个程序并发执行

#### 固定分区存储管理

各个用户分区的个数、位置和大小一旦确定以后，就固定不变

分区大小

- 多个小分区、适量的中等分区、少量大分区

输入队列

- 管理进程进入分区

数据结构

- 设置内存分配表

内存分配

- 先放入输入队列，然后采用最先匹配法、最佳匹配法等算法

内存回收

- 简单

缺点

- 内存利用率不高，内碎片造成很大浪费。所谓内碎片，即进程所占用分区之内的未被利用的空间。
- 分区的总数固定，限制了并发执行的程序个数，不够灵活。
- 地址空间的大小有限。

#### 可变分区储存管理

可变分区（动态分区）

- 初始时，操作系统会占用内存的一部分，其余空间为一个完整的大空闲区
- 当一个程序要求装入内存运行时，系统从这个空闲区中划一块分配给它
- 当程序完成后释放所占用的存储区
- 随着一系列的内存分配和回收，原来的一整块大空闲区就形成了若干占用区和空闲区相间的布局

特点

- 分区的个数、位置和大小都是随进程的进出而动态变化的，非常灵活，避免了在固定分区中因分区大小不当所造成的内碎片，提高了内存利用率。
- 有外碎片，即各个占用分区之间难以利用的空闲分区。
- 使得内存的分配、回收和管理更为复杂

#### 地址映射（重定位）

CPU访问内存的两种模式

- 实模式：直接访问内存，8086 CPU的工作方式，数据总线和寄存器各16位，地址总线20位，可访问内存空间1M。现代计算机在刚加电时运行在实模式，单道；
- 保护模式：需要进行地址映射，286以后CPU采用的工作方式

虚拟计算机

物理地址

- 也叫内存地址、绝对地址，实地址；
- 把内存分成很多个大小相等的存储单元，每个单元给一个编号，这个编号称为物理地址；
- 物理地址可以直接寻址；
- 物理地址的集合称为物理地址空间（内存地址空间），它是一个一维的线性空间。

逻辑地址

- 也叫相对地址，虚地址；
- 用户程序经汇编或编译后形成目标代码，目标代码通常采用相对地址的形式，其首地址为0，其余指令中的地址都是相对首地址来编址；
- 内存保护：逻辑地址与物理地址分离。

地址映射

- 为保证CPU执行指令时可正确访问存储单元，需将用户程序中的逻辑地址转换为运行时由机器直接寻址的物理地址，此过程称为地址映射

为了保证CPU执行指令时可正确访问存储单元，在装入程序时必须进行地址映射，将程序中的
逻辑地址转换为物理地址。这主要有两种方式：

- 静态地址映射（静态重定位）
  - 当用户程序被装入内存时，直接对指令代码进行修改，一次性实现逻辑地址到物理地址的转换。
  - 无需额外硬件，适用于嵌入式系统
- 动态地址映射（动态重定位）
  - 当用户程序被装入内存时，不对指令代码做任何修改。而是在程序运行过程中，当需要访问内存单元时再来进行地址转换（即在逐条执行指令时完成转换）。
  - 由硬件地址映射机制完成，如设置一个基地址寄存器，并装入进程所在分区起始地址；
  - 在程序运行时，硬件自动完成地址映射

#### 储存保护

为了防止一个用户程序去访问其他用户程序的内存分区，保护操作系统免受用户程序的破坏，须进行存储保护

最简单的做法：在基地址寄存器的基础上再增加一个限长寄存器，记录分区长度。这两者在一起，就定义了进程所在的分区

CPU组件

CPU+MMU->发送指令到总线

MMU作用

- 内存保护
- 内存共享

### 页式和段式存储管理

#### 页式存储管理

##### 基本原理

- 把物理内存划分为许多个固定大小的内存块，称为物理页面，或页框（page frame）；

- 把逻辑地址空间划分为大小相同的块，称为逻辑页面，或简称页面（page）；

- 页面大小为2^n，一般在512字节到8K字节之间；

- 当一个用户程序装入内存时，以页面为单位进行分配。若要运行一个大小为n个页面的程序，

  需要有n个空闲的物理页面把它装入，这些页面不必是连续的

##### 数据结构

页表：系统为每一个进程都建立了一个页表，页表给出了逻辑页面号和具体内存块号（物理页面号）之间的对应关系

物理页面表：在系统中设立一张物理页面表，用来描述内存空间当中，各个物理页面的分配使用状况。具体实现：位示图，空闲页面链表

##### 内存的分配与回收

内存的分配与回收算法与物理页面表的具体实现方法有关。这里以位示图为例。

内存的分配

- 计算一个进程所需要的页面数N，并查看位示图，看是否还有N个空闲页面；
- 若有，则申请一个页表，其长度为N，并把页表的起始地址填入PCB；
- 分配N个空闲物理页面，将其编号填入页表；
- 修改位示图（0→1，空闲页面数－N）

内存的回收

- 当一个进程运行结束，释放它所占用的内存空间后，需要对这些物理页面进行回收。
- 对于每一个物理页面，根据它的编号计算出它在位示图当中的相应位置，并将相应位的值从1改成0；
- 修改位示图中的空闲页面数：加上N

##### 地址映射

- 对于给定的逻辑地址，找到逻辑页面号和页内偏移地址；
- 查找页表，找到相应的物理页面号；
- 计算最终的物理地址

把逻辑地址划分为两部分：逻辑页面号和页内偏移地址。这种划分是由系统自动完成的，对用户是透明的。由于页面的大小一般为2的整数次幂，因此，地址的高位部分即为页号，低位部分即为页内偏移地址

逻辑地址为十进制的形式的计算方法：

- 页号 ＝ 虚地址 / 页大小
- 位移量 ＝ 虚地址 % 页大小

页表的具体实现

- 页表保存在内存当中（内核空间）;
- 设置一个页表基地址寄存器（Page-table base register，PTBR），用来指向页表的起始地址；
- 设置一个页表长度寄存器（Page-table length register，PTLR），指示页表大小

![image-20240415214151481](https://cdn.jsdelivr.net/gh/louisiy/ImageStorage/img/image-20240415214151481.png)

### 虚拟储存技术

