


<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>  When I Learn C |    Louisiy.</title>
  <meta name="description" content="Blog">
  <!-- 标签页图标 -->
  
  <link rel="shortcut icon" href="/img/favicon.ico" type="image/x-icon">
  

  <!-- 图标库 -->
  <link href="https://cdn.jsdelivr.net/npm/remixicon@2.2.0/fonts/remixicon.css" rel="stylesheet">
  <!-- 动画库 -->
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fushaolei/cdn-white@1.0/css/animate.css"/>
  
  <!-- css文件 -->
  
<link rel="stylesheet" href="/css/white.css">

  <!-- 代码高亮 -->
  
    
      
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.1.1/styles/github.css">

    
  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>

<div class="menu-outer">
    <div class="menu-inner">
      <div class="menu-site-name  animate__animated  animate__fadeInUp">
        <a href="/">
          Louisiy.
        </a>
        
      </div>
      <div class="menu-group">
        <ul class="menu-ul">
        
          <a href="/" class="nav-link">
            <li class="menu-li  animate__animated  animate__fadeInUp">
              HOME
            </li>
          </a>
        
          <a href="/archives" class="nav-link">
            <li class="menu-li  animate__animated  animate__fadeInUp">
              BLOG
            </li>
          </a>
        
        
        
        <a href="/search">
          <li class="menu-li  animate__animated  animate__fadeInUp">
            <i class="ri-search-line"></i>
          </li>
        </a>
        
          <li class="menu-li animate__animated  animate__fadeInUp" id="mobile-menu">
            <i class="ri-menu-line"></i>
          </li>
        
        </ul>

      </div>

    </div>
</div>
<div id="mobile-main" class="animate__animated  animate__fadeIn">
  <div class="mobile-menu-inner">
    <div class="mobile-menu-site-name animate__animated  animate__fadeInUp">
      <a href="/">
        Louisiy.
      </a>
    </div>
    <div class="mobile-menu-group" id="mobile-close">
      <i class="ri-close-line"></i>
    </div>

  </div>

  <div class="mobile-menu-div">
  
    <a href="/" class="mobile-nav-link">
      <div class="mobile-menu-child animate__animated  animate__fadeInUp">
        <span>HOME</span>
      </div>
    </a>
  
    <a href="/archives" class="mobile-nav-link">
      <div class="mobile-menu-child animate__animated  animate__fadeInUp">
        <span>BLOG</span>
      </div>
    </a>
  
  
    <a href="/search">  
      <div class="mobile-menu-child  animate__animated  animate__fadeInUp">
        <i class="ri-search-line"></i>
      </div>
    </a>
    
  </div>


</div>

<div class="body-outer">
  <div class="body-inner">
    
<article class="post-inner">
  <div class="post-content-outer">
    <div class="post-intro">
      <div class="post-title animate__animated  animate__fadeInUp">When I learn C</div>
      <div class="meta-intro animate__animated  animate__fadeInUp">7月 04 2022</div>
      
    </div>
    <div class="post-content-inner">
      <div class="post-content-inner-space">

      </div>
      <div class="post-content-main animate__animated  animate__fadeInUp">
        <!-- top型目录 -->
        
        <h1 id="HERE-IS-NOTE-FOR-Head-First-C-😃"><a href="#HERE-IS-NOTE-FOR-Head-First-C-😃" class="headerlink" title="HERE IS NOTE FOR Head First C 😃"></a>HERE IS NOTE FOR <em>Head First C</em> 😃</h1><h2 id="0-关于"><a href="#0-关于" class="headerlink" title="0 关于"></a>0 关于</h2><p>这里是符号说明，形如</p>
<ul>
<li>这是一条个人笔记</li>
</ul>
<blockquote>
<p>这是小拓展</p>
</blockquote>
<h2 id="1-入门"><a href="#1-入门" class="headerlink" title="1 入门"></a>1 入门</h2><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p><code>gcc -o</code> 设置文件名</p>
<p><code>./name</code> 类Unix操作系统中运行程序必须指定程序所在的目录，除非该程序目录已在PATH环境变量中，所以运行命令</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>C不支持现成的字符串</p>
<p>定义字符串数组需额外加一个字符的空间来容纳<code>/0</code>（NULL字符），字符的索引值为偏移量</p>
<p>单引号通常用来表示单个字符，而双引号通常用来表示字符串。通常应该用双引号来定义字符串。用双引号定义的字符串叫字符串字面值（string literal），比起字符数组，它输入起来也更方便</p>
<p>总线错误（bus error）意味着程序无法更新那一块存储器空间</p>
<h3 id="等号"><a href="#等号" class="headerlink" title="等号"></a>等号</h3><p><code>num = 1</code> 等号用来赋值（assignment）</p>
<p><code>num == 1</code> 检查值是否相等</p>
<p><code>nunm += 2 or num -= 2</code> 加减2</p>
<p><code>num++ or num--</code> 加减1</p>
<h3 id="布尔运算"><a href="#布尔运算" class="headerlink" title="布尔运算"></a>布尔运算</h3><p><code>&amp;&amp; || !</code> 与或非</p>
<p><code>&amp;</code>和<code>|</code>操作符总是计算两个条件，而<code>&amp;&amp;</code>和<code>||</code>可以跳过第二个条件</p>
<p>位运算 <code>6 &amp; 4</code> 等于4</p>
<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>switch语句检查一个单独的值。计算机会在第一个匹配的case语句处开始执行代码。在遇到break或到达switch语句的末尾前，代码会一直运行。</p>
<pre><code class="c">switch(train) &#123;
case 37:
    winnings = winnings + 50;
    break;
case 65:
    puts(&quot;头等奖!&quot;);
    winnings = winnings + 80;		//执行完这条接着再+20这条，直到break
case 12:
    winnings = winnings + 20;
    break;
default:
    winnings = 0;
&#125;
</code></pre>
<h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><pre><code class="c">int counter;
for (counter = 1; counter &lt; 11; counter++) &#123;	//(初始化循环变量；循环运行前检查；循环后执行)
printf(&quot;%i个枣\n&quot;, counter);
&#125;
</code></pre>
<p>可以用<code>break</code>在任意时刻退出循环</p>
<p>可以用<code>continue</code>随时跳到循环条件处</p>
<h3 id="链式赋值"><a href="#链式赋值" class="headerlink" title="链式赋值"></a>链式赋值</h3><p><code>x = y = 4;</code>给多个变量赋相同值</p>
<h2 id="2-指针"><a href="#2-指针" class="headerlink" title="2 指针"></a>2 指针</h2><p>使用指针的主要目的之一就是让函数共享存储器，指针只是一个保存存储器地址的变量，它们是进程存储器中真实编号的地址</p>
<h3 id="储存器"><a href="#储存器" class="headerlink" title="储存器"></a>储存器</h3><p>局部变量保存在栈（Stack），全局变量保存在全局量区（Globals）</p>
<p><code>&amp;x</code>指x的地址 <code>%p</code>来格式化输出</p>
<blockquote>
<p>栈<br>这是存储器用来保存局部变量的部分。每当调用函数，函数的所有局部变量都在栈上创建。它之所以叫栈是因为它看起来就像堆积而成的栈板：当进入函数时，变量会放到栈顶；离开函数时，把变量从栈顶拿走。奇怪的是，栈做起事来颠三倒四，它从存储器的顶部开始，向下增长。</p>
<p>堆<br>堆用于动态存储：程序在运行时创建一些数据，然后使用很长一段时间。</p>
<p>全局量<br>全局量位于所有函数之外，并对所有函数可见。程序一开始运行时就会创建全局量，可以修改它们，不像常量。</p>
<p>常量<br>常量也在程序一开始运行时创建，但它们保存在只读存储器中。常量是一些在程序中要用到的不变量，你不会想修改它们的值，例如字符串字面值。</p>
<p>代码<br>最后是代码段，很多操作系统都把代码放在存储器地址的低位。代码段也是只读的，它是存储器中用来加载机器代码的部分。</p>
</blockquote>
<h3 id="int"><a href="#int" class="headerlink" title="int *"></a>int *</h3><p><code>int *address_of_x = &amp;x;</code></p>
<p><code>*</code>来解引用，如<code>int value_stored = *address_of_x;</code> 、<code>*address_of_x = 99;</code></p>
<h3 id="sizeof（）"><a href="#sizeof（）" class="headerlink" title="sizeof（）"></a>sizeof（）</h3><p>这是个运算符</p>
<pre><code class="c">sizeof(int);
sizeof(&quot;Turtles!&quot;);		//返回9
</code></pre>
<h3 id="数组变量"><a href="#数组变量" class="headerlink" title="数组变量"></a>数组变量</h3><p>数组变量可以被用作指针，指向数组中的第一个元素。函数参数声明如为数组，则其会被当作指针处理</p>
<p>计算机不会为数组变量分配任何空间，编译器仅在出现它的地方把它替换成数组的起始地址，所以不能把它指向任何其他地方</p>
<blockquote>
<p>指针退化</p>
<p>假如把数组赋给指针变量，指针变量只会包含数组的地址信息，而对数组的长度一无所知，相当于指针丢失了一些信息，也就是指针退化。</p>
<p>只要把数组传递给函数，数组免不了退化为指针，但需要记清楚代码中有哪些地方发生过数组退化，因为它们会引发一些不易察觉的错误。</p>
</blockquote>
<pre><code class="c">int drinks[] = &#123;4, 2, 3&#125;;		//drinks[i] == *(drinks + i)
doses[3] == *(doses + 3) == *(3 + doses) == 3[doses]
</code></pre>
<h3 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h3><p>指针之所以有类型，是因为编译器在指针算术运算时需要知道加几</p>
<p>如<code>int nums[] = &#123;1, 2, 3&#125;;</code>中<code>nums</code>与<code>nums+1</code>的地址间隔4个字节（如果int通常占4个字节）</p>
<ul>
<li>这里的数组内的每一个值都是int类型，都占4字节</li>
</ul>
<h3 id="scanf-vs-fgets"><a href="#scanf-vs-fgets" class="headerlink" title="scanf() vs fgets()"></a>scanf() vs fgets()</h3><p><code>scanf()</code>会导致缓冲区溢出,引发段错误（abort trap）,应限制<code>scanf()</code>读取字符串的长度</p>
<p><code>fgets(char指针，sizeof(char指针),stdin)</code> stdin表示数据来自键盘</p>
<p><code>fgets()</code>缓冲区大小把<code>\0</code>字符也算了进去，所以不必像<code>scanf()</code>那样把长度减1</p>
<p>如果要向<code>fgets()</code>函数传递数组变量，就用<code>sizeof</code>，如果只是传指针，就应该输入想要的长度。</p>
<p><code>scanf()</code>不但允许输入多个字段，而且允许输入结构化数据，可以指定两个字段之间以什<br>么字符分割，<code>fgets()</code>只允许向缓冲区中输入一个字符串，而且只能是字符串，不能是其他数据类型，只能有一个缓冲区</p>
<p>当<code>scanf()</code>用<code>%s</code>读取字符串时，遇到空格就会停止。如果想要输入多个单词，需要多次调用<code>scanf()</code>，或使用一些复杂的正则表达式技巧，<code>fgets()</code>总能读取整个字符串</p>
<p><strong>Conclusion</strong>:	如果需要输入由多个字段构成的结构化数据，可以使用<code>scanf()</code>；而如果想要输入一个非结构化的字符串，<code>fgets()</code>将是不二之选</p>
<h3 id="cards-还是-cards"><a href="#cards-还是-cards" class="headerlink" title="cards[ ]还是*cards"></a>cards[ ]还是*cards</h3><p>字符串字面值保存在只读存储器中。如果想要修改字符串，需要在新的数组中创建副本。可以将char指针声明成为<code>const char *</code>，以防代码用它修改字符串</p>
<h2 id="2-5-字符串原理"><a href="#2-5-字符串原理" class="headerlink" title="2.5 字符串原理"></a>2.5 字符串原理</h2><h3 id="创建数组的数组"><a href="#创建数组的数组" class="headerlink" title="创建数组的数组"></a>创建数组的数组</h3><pre><code class="c">char tracks[][80] = &#123;			//第一对方括号用来访问由所有字符串组成的数组
                              //第二对方括号用来访问每个单独的字符串
    &quot;I left my heart in Harvard Med School&quot;,
    &quot;Newark, Newark - a wonderful town&quot;,
    &quot;Dancing with a Dork&quot;,
    &quot;From here to maternity&quot;,
    &quot;The girl from Iwo Jima&quot;,
&#125;;
</code></pre>
<p>可以用<code>char strings[...][...]</code>来创建数组的数组。<br>第一组方括号用来访问外层数组<br>第二组方括号用来访问每个内层数组中的元素</p>
<h3 id="使用string-h"><a href="#使用string-h" class="headerlink" title="使用string.h"></a>使用string.h</h3><pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
strcmp()
可以比较字符串
strchr()
用来在字符串中找到某个字符的位置
strlen()
可以得到字符串的长度
strcpy()
可以复制字符串
</code></pre>
<p>使用以上代码引用头文件</p>
<h3 id="使用strstr（）"><a href="#使用strstr（）" class="headerlink" title="使用strstr（）"></a>使用strstr（）</h3><pre><code class="c">char s0[] = &quot;dysfunctional&quot;;
char s1[] = &quot;fun&quot;;
if (strstr(s0, s1))
    puts(&quot;我在dysfunctional中找到fun了!&quot;);
</code></pre>
<blockquote>
<p>全局变量位于任何函数之外，所有函数都可以调用它们。</p>
</blockquote>
<h3 id="指针的数组"><a href="#指针的数组" class="headerlink" title="指针的数组"></a>指针的数组</h3><pre><code class="c">char *names_for_dog[] = &#123;&quot;Bowser&quot;, &quot;Bonza&quot;, &quot;Snodgrass&quot;&#125;;
//可以像访问数组的数组那样访问指针的数组,一个字符串字面值配一个指针
</code></pre>
<h2 id="3-小工具"><a href="#3-小工具" class="headerlink" title="3 小工具"></a>3 小工具</h2><p>小工具设计遵循以下原则：</p>
<ul>
<li>从标准输入读取数据</li>
<li>在标准输出显示数据</li>
<li>处理文本数据，而不是难以阅读的二进制格式</li>
<li>只做一件简单的事</li>
<li>如果想完成一个不同的任务，应该另外写一个小工具</li>
<li>小工具通常读写文本数据</li>
</ul>
<h3 id="过滤器（filter）"><a href="#过滤器（filter）" class="headerlink" title="过滤器（filter）"></a>过滤器（filter）</h3><p>这是一种小工具，它逐行读取数据，对数据进行处理，再把数据写到某个地方。如果你的计算机是Unix，或你在Windows上安装了Cygwin，就已经拥有很多过滤器工具了。</p>
<blockquote>
<p>head：显示文件前几行的内容<br>tail：显示文件最后几行的内容<br>sed：流编辑器（stream editor），用来搜索和替换文本</p>
</blockquote>
<h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>可以重定向标准输入、标准输出，让程序从键盘以外的地方读数据、往显示器以外的地方写数据，如文件。可用命令</p>
<pre><code class="bash">$ ./geo2json &lt; gpsdata.csv &gt; output.json
</code></pre>
<h3 id="错误状态码"><a href="#错误状态码" class="headerlink" title="错误状态码"></a>错误状态码</h3><p>程序在数据中发现错误就会退出，并把退出状态置为2。怎么在程序结束后检查错误状态呢？</p>
<p>要看操作系统</p>
<p>如果你的计算机是Mac、Linux、其他UNIX，或你在Windows上使用Cygwin，可以用以下命令显示错误状态：</p>
<pre><code class="bash">$ echo $?
</code></pre>
<p>如果用的是Windows的命令提示符，则可以输入：</p>
<pre><code class="bash">C:\&gt; echo %ERRORLEVEL%
</code></pre>
<p>这两条命令做了相同的事：显示程序结束时返回的那个数字。</p>
<h3 id="标准错误"><a href="#标准错误" class="headerlink" title="标准错误"></a>标准错误</h3><p>标准错误——一个用来发送错误消息的二号输出</p>
<p>人有两只耳朵和一张嘴，但进程有一只耳朵（标准输入）和两张嘴（标准输出和标准错误）</p>
<h3 id="fprintf-打印到数据流"><a href="#fprintf-打印到数据流" class="headerlink" title="fprintf()打印到数据流"></a>fprintf()打印到数据流</h3><p>printf()函数可以将数据发送到标准输出，但printf()只是fprintf()一个的特例</p>
<p>scanf()  fscanf(stdin, …)</p>
<pre><code class="c">printf(&quot;我喜欢乌龟！&quot;);
fprintf(stdout, &quot;我喜欢乌龟！&quot;);
//以上命令等价
</code></pre>
<p>stdout 标准输出</p>
<p>stderr  标准错误</p>
<p>stdin 标准输入</p>
<p><code>&gt;</code>重定向标准输出	<code>&lt;</code>重定向标准输入	<code>2&gt;</code>重定向标准错误</p>
<h3 id="用管道连接输入与输出"><a href="#用管道连接输入与输出" class="headerlink" title="用管道连接输入与输出"></a>用管道连接输入与输出</h3><p>符号 | 表示管道（pipe），它能连接一个进程的标准输出与另一个进程的标准输入</p>
<p><code>bermuda | geo2json</code></p>
<pre><code class="bash">&gt; (./bermuda | ./geo2json) &lt; spooky.csv &gt; output.json
</code></pre>
<p>只要在每个程序前加上一个<code>|</code>就可以连接多个程序，一连串相连的进程就叫流水线（pipeline），这时<code>&lt;</code>会把文件内容发送到流水线中第一个进程的标准输入，<code>&gt;</code>会捕获流水线中最后一个进程的标准输出</p>
<p>外面的括号是必需的,这对括号保证了数据文件由bermuda程序的标准输入来读取</p>
<h3 id="创建自己的数据流"><a href="#创建自己的数据流" class="headerlink" title="创建自己的数据流"></a>创建自己的数据流</h3><p>每条数据流用一个指向文件的指针来表示，可以用<code>fopen()</code>函数创建新数据流</p>
<pre><code class="c">FILE *in_file = fopen(&quot;input.txt&quot;, &quot;r&quot;);	//将创建一条数据流，从文件中读取数据
FILE *out_file = fopen(&quot;output.txt&quot;, &quot;w&quot;);	//将创建一条数据流，向文件写数据
</code></pre>
<p>fopen()函数接收两个参数：文件名和模式。共有三种模式</p>
<p>“w”&#x3D; 写（write）	写文件<br>“r”&#x3D; 读（read）	读文件<br>“a”&#x3D; 追加（append）	在文件末尾追加数据</p>
<p>创建数据流后，可以用fprintf()往数据流中打印数据<br>可以用fscanf()函数从文件中读取数据</p>
<pre><code class="c">fprintf(out_file, &quot;%s 和 %s &quot;, &quot;红 &quot;, &quot;绿&quot;);
fscanf(in_file, &quot;%79[^\n]\n&quot;, sentence);
</code></pre>
<p>最当用完数据流，别忘了关闭它。虽然所有的数据流在程序结束后都会自动关闭，但你仍应该自己关闭它们</p>
<pre><code class="c">fclose(in_file);
fclose(out_file);
</code></pre>
<p>通常情况下，一个进程最多可以有256条数据流。但数据流的数量是有限的，用完后应该关闭它们。</p>
<p>最早FILE是用宏定义的，而宏的名字通常都要大写。</p>
<h3 id="首选项"><a href="#首选项" class="headerlink" title="首选项"></a>首选项</h3><p>对GUI程序来说，可以修改程序的首选项；而对于categorize这样的命令行程序，可以传给它命令行参数</p>
<pre><code class="c">int main(int argc, char *argv[])
&#123;
.... 做事情....
&#125;
</code></pre>
<p>main()函数有两个版本，一个有命令行参数，一个没有。命令行参数通过两个变量传递给main()函数，一个是参数的计数（argc），另一个是指针（指向参数字符串）数组</p>
<p>用户运行程序时，命令行中第一个参数是程序名。也就是说，第一个命令行参数其实是argv[1]</p>
<pre><code class="bash">&gt;./categorize mermaid mermaid.csv Elvis elvises.csv the_rest.csv
   argv[0]	 argv[1]				...				argv[5]
</code></pre>
<p>在程序中打开文件准备读写时，最好检查一下有没有错误发生。好在如果数据流打开失败，fopen()函数会返回0，也就是说如果想检查错误，可以将下面这段代码：</p>
<pre><code class="c">FILE *in = fopen(&quot;我不存在.txt&quot;, &quot;r&quot;);
</code></pre>
<p>改成这样：</p>
<pre><code class="c">FILE *in;
if (!(in = fopen(&quot;我不存在.txt&quot;, &quot;r&quot;))) &#123;
    fprintf(stderr, &quot;无法打开文件.\n&quot;);
    return 1;
&#125;
</code></pre>
<h3 id="使用库-getopt"><a href="#使用库-getopt" class="headerlink" title="使用库 getopt()"></a>使用库 getopt()</h3><p>unistd.h头文件不属于C标准库，而是POSIX库中的一员。POSIX的目标是创建一套能够在所有主流操作系统上使用的函数。</p>
<p>getop()使用范例</p>
<pre><code class="bash">&gt; rocket_to -e 4 -a Brasilia Tokyo London
</code></pre>
<pre><code class="c">#include &lt;unistd.h&gt;
...
while ((ch = getopt(argc, argv, &quot;ae:&quot;)) != EOF)
//ae:告诉getopt()函数“a和e是有效选项”，e后面的冒号表示“-e后面需要再跟一个参数”，getopt()会用optarg变量指向这个参数
    switch(ch) &#123;
    ...
    case &#39;e&#39;:
        engine_count = optarg;
    ...
    &#125;
argc -= optind;		//最后这两行用来跳过已读取的选项
argv += optind;		//optind保存了“getopt()函数从命令行读取了几个选项”
</code></pre>
<p>经过一番处理，0号参数不再是程序名了。argv[0]会指向选项后的第一个命令行参数。循环结束以后，为了让程序读取命令行参数，需要调整一下argv和argc变量，跳过所有选项。</p>
<pre><code class="bash">&gt; rocket_to -e 4 -a Brasilia  Tokyo   London
                    argv[0]  argv[1]  argv[2]
</code></pre>
<p>Tips：</p>
<ul>
<li>可以多个选项<code>abc:d</code></li>
<li>可以合并命令行里的选项，如：<code>-td now</code> 与 <code>-d now -t</code></li>
<li>可以改变选项之间顺序，因为我们用循环读取选项，所以 <code>-d now -t</code>、<code>-t -d now</code>、<code>-td now</code>都一样(</li>
<li>只要程序在命令行看到一个前缀为－值，就会把它当成选项处理，前提是它必须在命令行参数之前出现</li>
<li>为了避免歧义，可以用<code>--</code>隔开参数和选项，比如<code>set_temper-ature -c -- -4</code>。getopt()看到<code>--</code>就会停止读取选项，程序会把后面的内容当成普通的命令行参数读取</li>
</ul>
<h2 id="4-使用多个源文件"><a href="#4-使用多个源文件" class="headerlink" title="4 使用多个源文件"></a>4 使用多个源文件</h2><h3 id="简明数据类型指南"><a href="#简明数据类型指南" class="headerlink" title="简明数据类型指南"></a>简明数据类型指南</h3><ul>
<li>char<br>字符在计算机的存储器中以字符编码的形式保存，字符编码是一个数字，因此在计算机看来，A与数字65完全一样（ASCII码）</li>
<li>int<br>如果你要保存一个整数，通常可以使用int。不同计算机中int的大小不同，但至少应该有16位。一般而言，int可以保存几万以内的数字</li>
<li>long<br>但如果想保存一个很大的计数呢？long数据类型就是为此而生的。在某些计算机中，long的大小是int的两倍，所以可以保存几十亿以内的数字；但大部分计算机的long和int一样大，因为在这些计算机中int本身就很大。long至少应该有32位</li>
<li>float<br>float是保存浮点数的基本数据类型。平时你会碰到很多浮点数，比如一杯香橙摩卡冰乐有多少毫升，就可以用float保存</li>
<li>double<br>但如果想表示很精确的浮点数呢？如果想让计算结果精确到小数点以后很多位，可以使用double。double比float多占一倍空间，可以保存更大、更精确的数字</li>
</ul>
<blockquote>
<p>为什么把一个很大的数保存到short中会变成负数？</p>
<p>数字以二进制保存，二进制的100 000看起来像这样：<br>x &lt;- 0001 1000 0110 1010 0000<br>当计算机想把这个值保存到short时，发现只能保存2个字节，所以只保存了数字右半边：<br>y &lt;- 1000 0110 1010 0000<br>最高位是1的二进制有符号数会被当成负数处理，它等价于下面的十进制数：<br>-31072</p>
</blockquote>
<h3 id="使用类型转换临时转换数值的类型"><a href="#使用类型转换临时转换数值的类型" class="headerlink" title="使用类型转换临时转换数值的类型"></a>使用类型转换临时转换数值的类型</h3><pre><code class="c">int x = 7;
int y = 2;
//float z = (float)x / (float)y;
float z = (float)x / y
//如果编译器发现有整数在加、减、乘、除浮点数，会自动完成转换，因此可以减少代码中显式类型转换的次数：
printf(&quot;z = %f\n&quot;, z);
</code></pre>
<h3 id="两个关键字"><a href="#两个关键字" class="headerlink" title="两个关键字"></a>两个关键字</h3><p>unsigned<br>用unsigned修饰的数值只能是非负数。由于无需记录负数，无符号数有更多的位可以使用，因此它可以保存更大的数。unsigned int可以保存0到最大值的数。这个最大值是int可以保存最大值的两倍左右。还有signed关键字，但你几乎从没见过，因为所有数据类型默认都是有符号的。<br><code>unsigned char c;</code></p>
<p>long<br>没错，你可以在数据类型前加long，让它变长。longint是加长版的int；long int可以保存范围更广的数字；long long比long更长；还可以对浮点数用long。(c99和c11支持long long)<br><code>long double d;</code></p>
<blockquote>
<p>%.2f把浮点数格式化为小数点后两位</p>
<p>%hi用来格式化short</p>
</blockquote>
<pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;limits.h&gt; //含有表示整型（比如int和char）大小的值
#include &lt;float.h&gt; //含有表示float和double类型大小的值
int main()
&#123;
printf(&quot;The value of INT_MAX is %i\n&quot;, INT_MAX);
printf(&quot;The value of INT_MIN is %i\n&quot;, INT_MIN);
printf(&quot;An int takes %z bytes\n&quot;, sizeof(int));
printf(&quot;The value of FLT_MAX is %f\n&quot;, FLT_MAX);
printf(&quot;The value of FLT_MIN is %.50f\n&quot;, FLT_MIN);
printf(&quot;A float takes %z bytes\n&quot;, sizeof(float));
    //可把INT和FLT替换成CHAR（char）、DBL（double）、SHRT（short）或LNG（long）
return 0;
&#125;
</code></pre>
<blockquote>
<p>位数是计算机能够处理的数值长度</p>
</blockquote>
<h3 id="声明与定义分离"><a href="#声明与定义分离" class="headerlink" title="声明与定义分离"></a>声明与定义分离</h3><p><code>float add_with_tax()(float f);</code></p>
<p>声明只是一个函数签名：一条包含函数名、形参类型与返回类型的记录</p>
<h3 id="创建头文件"><a href="#创建头文件" class="headerlink" title="创建头文件"></a>创建头文件</h3><p>两步</p>
<ol>
<li>创建一个扩展名为.h的文件，把你的声明写在里面，不用在头文件中包含main()函数，反正也没有函数会调用它</li>
<li>在主代码中包含头文件，应该在代码的顶部加一句include</li>
</ol>
<p><code>#include &#39;asdf.h&#39;</code> <code>#include &lt;stdio.h&gt;</code></p>
<p>通常情况下，引号表示以相对路径查找头文件，如果不加目录名，只包含一个文件名，编译器就会在当前目录下查找头文件；如果用了尖括号，编译器就会以绝对路径查找头文件</p>
<p>当编译器看到尖括号，就会到标准库代码所在目录查找头文件，但现在你的头文件和.c文件在同一目录下，用引号把文件名括起来，编译器就会在本地查找文件。本地头文件也可以带目录名，但通常会把它和C文件放在相同目录中。</p>
<p>当编译器在代码中读到#include，就会读取头文件中的内容，仿佛它们本来就在代码中。</p>
<blockquote>
<p>如果编译器发现你调用了一个它没见过的函数，就会假设这个函数返回int</p>
</blockquote>
<h3 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h3><table>
<thead>
<tr>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
</tr>
</thead>
<tbody><tr>
<td align="center">auto</td>
<td align="center">if</td>
<td align="center">break</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">case</td>
<td align="center">long</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">register</td>
<td align="center">continue</td>
</tr>
<tr>
<td align="center">return</td>
<td align="center">default</td>
<td align="center">short</td>
</tr>
<tr>
<td align="center">do</td>
<td align="center">sizeof</td>
<td align="center">double</td>
</tr>
<tr>
<td align="center">static</td>
<td align="center">else</td>
<td align="center">struct</td>
</tr>
<tr>
<td align="center">entry</td>
<td align="center">switch</td>
<td align="center">extern</td>
</tr>
<tr>
<td align="center">typeof</td>
<td align="center">float</td>
<td align="center">union</td>
</tr>
<tr>
<td align="center">for</td>
<td align="center">unsigned</td>
<td align="center">goto</td>
</tr>
<tr>
<td align="center">while</td>
<td align="center">enum</td>
<td align="center">void</td>
</tr>
<tr>
<td align="center">const</td>
<td align="center">signed</td>
<td align="center">volatile</td>
</tr>
</tbody></table>
<h3 id="共享代码"><a href="#共享代码" class="headerlink" title="共享代码"></a>共享代码</h3><p>为了共享代码，可以把代码放到一个单独的C文件中。<br>需要把函数声明放到一个单独的.h头文件中。<br>在所有需要使用共享代码的C文件中包含这个头文件。<br>在编译的命令中列出所有C文件。</p>
<pre><code class="c">//encrypt.h
void encrypt(char *message);
</code></pre>
<pre><code class="c">//encrypt.c
#include &quot;encrypt.h&quot;
void encrypt(char *message)&#123;
    char c;
    while (*message) &#123;
    *message = *message ^ 31;
    message++;
    &#125;
&#125;
</code></pre>
<pre><code class="c">//mainprog.c
#include &lt;stdio.h&gt;
#include &quot;encrypt.h&quot;
int main()&#123;
    char msg[80];
    while (fgets(msg, 80, stdin)) &#123;
    encrypt(msg);
    printf(&quot;%s&quot;, msg);
    &#125;
&#125;
</code></pre>
<pre><code class="bash">./ gcc message_hider.c encrypt.c -o message_hider
</code></pre>
<blockquote>
<p>共享变量<br>为了防止两个源文件中的同名变量相互干扰，变量的作用域仅限于某个文件内。如果你想共享变量，就应该在头文件中声明，并在变量名前加上extern关键字：<br><code>extern int passcode;</code></p>
</blockquote>
<h3 id="gccの编译"><a href="#gccの编译" class="headerlink" title="gccの编译"></a>gccの编译</h3><p>gcc -c会编译代码，但不会链接目标文件</p>
<pre><code class="bash">./ gcc -c *.c
</code></pre>
<p>gcc -o 链接，在例子中把目标文件链接为一个叫launch的可执行程序</p>
<pre><code class="bash">./ gcc *.o -o launch
</code></pre>
<h3 id="Make"><a href="#Make" class="headerlink" title="Make"></a>Make</h3><p>如果你掌握了某样东西的简单规则，别多想，自动化它</p>
<p>make编译的文件叫目标（target）。目标可以是任何用其他文件生成的文件，也就是说目标可以是一批文件压缩而成的压缩文档</p>
<p>make需要知道：依赖项、生成方法。依赖项和生成方法合在一起构成了一条规则。有了规则，make就知道如何生成目标</p>
<blockquote>
<p>versions :</p>
<p>UNIX make</p>
<p>MinGW mingw32-make</p>
<p>Microsoft  NMAKE</p>
</blockquote>
<p>makefile文件书写</p>
<pre><code class="makefile">launch.o: launch.c launch.h thruster.h		//目标：依赖项
    gcc -c launch.c							//生成方法（必须以tab开头）
                                            //这是规则
thruster.o: thruster.h thruster.c
    gcc -c thruster.c
launch: launch.o thruster.o
    gcc launch.o thruster.o -o launch
</code></pre>
<p>之后直接</p>
<pre><code class="bash">./ make launch
</code></pre>
<blockquote>
<p>更自动化的工具：autoconf</p>
</blockquote>
<p>-&gt; <a target="_blank" rel="noopener" href="http://tinyurl.com/yczmjx">GUN Make Manual</a></p>
<h2 id="5-结构、联合与位字段"><a href="#5-结构、联合与位字段" class="headerlink" title="5 结构、联合与位字段"></a>5 结构、联合与位字段</h2><h3 id="结构-Struct"><a href="#结构-Struct" class="headerlink" title="结构 Struct"></a>结构 Struct</h3><p>结构化数据结构 structured data type</p>
<p>结构是一种由一系列其他数据类型组成的数据类型。</p>
<pre><code class="c">struct fish &#123;
    const char *name;
    const char *species;
    int teeth;
    int age;
&#125;;
</code></pre>
<p>创建一个新自定义的数据类型，由其它一批数据组成。</p>
<ul>
<li>结构的大小固定</li>
<li>结构中的数据都有名字</li>
</ul>
<p>创建数据：</p>
<pre><code class="c">struct fish snappy = &#123;&quot;Snappy&quot;, &quot;Piranha&quot;, 69, 4&#125;
</code></pre>
<p>把参数封装在结构中，代码会更稳定</p>
<p>结构变量是结构本身的名字</p>
<p>读取时只能按名访问，使用“.”运算符读取结构字段：&lt;结构&gt;.&lt;字段名&gt;语法（也叫“点表示法”）</p>
<pre><code class="c">struct fish snappy = &#123;&quot;Snappy&quot;, &quot;piranha&quot;, 69, 4&#125;;
printf(&quot;Name = %s\n&quot;, snappy.name);
</code></pre>
<p>为结构变量赋值相当于叫计算机复制数据</p>
<h3 id="结构中的结构"><a href="#结构中的结构" class="headerlink" title="结构中的结构"></a>结构中的结构</h3><p>为什么要嵌套定义结构？</p>
<p>之所以要这么做是为了对抗复杂性 。通过使用结构，我们可以建立更大的数据块。通过把结构组合在一起，我们可以创建更大的数据结构。本来你只能用int、short，但有了结构以后，就可以描述十分复杂的东西，比如网络流和视频图像。</p>
<pre><code class="c">struct preferences &#123;
    const char *food;
    float exercise_hours;
&#125;;
struct fish &#123;
    const char *name;
    const char *species;
    int teeth;
    int age;
    struct preferences care; //nesting 嵌套
   struct fish snappy = &#123;&quot;Snappy&quot;, &quot;Piranha&quot;, 69, 4, &#123;&quot;Meat&quot;, 7.5&#125;&#125;;
   printf(&quot;Snappy 喜欢吃 %s&quot;, snappy.care.food);
    printf(&quot;Snappy 喜欢锻炼 %f hours&quot;, snappy.care.exercise_hours); //访问
&#125;;
</code></pre>
<h3 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h3><p>在C语言中可以为结构创建别名，你只要在struct关键字前加上typedef，并在右花括号后写上类型名，就可以在任何地方使用这种新类型。</p>
<pre><code class="c">typedef struct cell_phone &#123;
    int cell_no;
    const char *wallpaper;
    float minutes_of_charge;
&#125; phone;
</code></pre>
<p>当你用typedef为结构创建别名，需要决定别名叫什么。别名其实就是类型名，也就是说结构有两个名字：一个是结构名（struct cell_phone），另一个是类型名（phone）。为什么要有两个名字？一般一个就够了。如果只写类型名而不写结构名，编译器也没意见：</p>
<pre><code class="c">typedef struct &#123;
    int cell_no;
    const char *wallpaper;
    float minutes_of_charge;
&#125; phone;
phone p = &#123;5557879, &quot;s.png&quot;, 1.35&#125;;
</code></pre>
<p>这样的结构称为匿名结构。</p>
<h3 id="更新结构"><a href="#更新结构" class="headerlink" title="更新结构"></a>更新结构</h3><pre><code class="c">fish snappy = &#123;&quot;Snappy&quot;, &quot;piranha&quot;, 69, 4&#125;;
printf(&quot;Hello %s\n&quot;, snappy.name);
snappy.teeth = 68;
</code></pre>
<p>计算机通过把值赋给函数形参的方式向函数传值，所有赋值都会复制</p>
<p>如果想让函数更新结构变量，就不能把结构作为参数传递，因为这样做仅仅是将数据的副本复制给<br>了函数。取而代之，可以传递结构的地址</p>
<p>还有一种表示结构指针的方法，它更易于阅读。</p>
<p><code>(*t).age</code> 和 <code>t-&gt;age</code> 等价</p>
<p>“指针-&gt;字段”等于“(*指针).字段”	“-&gt;”表示法省掉了括号，代码更易阅读。</p>
<h3 id="联合？"><a href="#联合？" class="headerlink" title="联合？"></a>联合？</h3><p>每次创建结构实例，计算机都会在存储器中相继摆放字段</p>
<p>联合则不同。当定义联合时，计算机只为其中一个字段分配空间，并且计算机会为其中最大的字段分配空间，然后由你决定里面保存什么值</p>
<blockquote>
<p>计算机需要保证联合的大小固定。唯一的办法就是让它足够大，任何一个字段都能装得下</p>
</blockquote>
<pre><code class="c">typedef union &#123;			//这里的关键字是union
    short count;
    float weight;
    float volume;
&#125; quantity;
</code></pre>
<h3 id="使用联合"><a href="#使用联合" class="headerlink" title="使用联合"></a>使用联合</h3><ul>
<li><p>C89 方式</p>
<p>把值赋给联合中第一个字段</p>
<pre><code class="c">quantity q = &#123;4&#125;;
</code></pre>
</li>
<li><p>指定初始化器（designated initializer）</p>
<pre><code class="c">quantity q = &#123; .weight = 1.5 &#125;;
</code></pre>
</li>
<li><p>点 表示法</p>
<p>在第一行创建变量，然后在第二行设置字段的值</p>
<pre><code class="c">quantity q;
q.volume = 3.7;
</code></pre>
</li>
</ul>
<p>无论用哪种方法设置联合的值，都只会保存一条数据。联合只是提供了一种创建支持不同数据类型的变量的方法</p>
<p>“指定初始化器”也可以用来设置结构字段的初值，并提高代码的可读性</p>
<pre><code class="c">typedef struct &#123;
    const char *color;
    int gears;
    int height;
&#125; bike;

bike b = &#123;.height=17, .gears=21&#125;;
</code></pre>
<h3 id="联合与结构"><a href="#联合与结构" class="headerlink" title="联合与结构"></a>联合与结构</h3><pre><code class="c">typedef struct &#123;
    const char *name ;
    const char *country;
    quantity amount;
&#125; fruit_order;

fruit_order apples = &#123;&quot;apples&quot;,&quot;English&quot;,.amount.weight = 4.2&#125;
printf(&quot;This order contains %2.2f lbs of %s\n&quot;,apples.amount.weight, apples.name);
</code></pre>
<h3 id="枚举变量保存符号"><a href="#枚举变量保存符号" class="headerlink" title="枚举变量保存符号"></a>枚举变量保存符号</h3><p>你需要某种方法记录我们在联合中保存了什么值。</p>
<p>结构与联合用分号（;）来分割数据项，而枚举用逗号。</p>
<pre><code class="c">enum colors &#123;RED, GREEN, PUCE&#125;;		//可以用typedef为类型起个名字
enum colors favorite = PUCE;
</code></pre>
<p><em><strong>so？枚举好处？？？</strong></em> 限制我能给的值？ 实例感受下：</p>
<pre><code class="c">typedef enum &#123;
    COUNT,
    POUNDS,
    PINTS
&#125;unit_of_measure;

typedef struct &#123;
    const char *name;
    const char *country;
    quantity amount;
    unit_of_measure units;
&#125;fruit_order;

void display(fruit_order order) &#123;
    printf(&quot;This order contains &quot;);
    if (order.units==PINTS) printf(&quot;%2.2f pints of %s\n&quot;, order.amount.volume, order.name);

    else if (order.units==POUNDS) printf(&quot;%2.2f lbs of %s\n&quot;, order.amount.weight, order.name);
    else printf(&quot;%i %s\n&quot;, order.amount.count, order.name);
&#125;

int main() &#123;
    fruit_order strawberries= &#123;
        &quot;strawberries&quot;,
        &quot;Spain&quot;,
        .amount.weight=17.6,
        POUNDS
    &#125;;
    display(strawberries);
    return 0;
&#125;
</code></pre>
<h3 id="位字段（bitfield）"><a href="#位字段（bitfield）" class="headerlink" title="位字段（bitfield）"></a>位字段（bitfield）</h3><p>C语言不支持二进制字面值，不过它支持十六进制字面值。每当C语言看到0x开头的数字，就认为它是以16为基数的数字（0x54）</p>
<p>可以用位字段指定一个字段有多少位</p>
<pre><code class="c">typedef struct &#123;
    unsigned int low_pass_vcf:1;		//位字段应当声明为unsigned int
    unsigned int filter_coupler:1;		//表示该字段只使用1位存储空间
    unsigned int reverb:1;
    unsigned int sequential:4;
    ...
&#125; synth;
</code></pre>
<p>如果你有一连串的位字段，计算机会放在一起，以节省空间，也就是说如果有8个1位的位字段，计算机就会把它们保存在一个字节中</p>
<p>如果编译器发现结构中只有一个位字段，还是会把它填充成一个字，这就是为什么位字段总是组合在一起</p>
<h2 id="6-数据结构与动态存储"><a href="#6-数据结构与动态存储" class="headerlink" title="6 数据结构与动态存储"></a>6 数据结构与动态存储</h2><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>保存可变数量的数据</p>
<p>链表是一种抽象数据结构。链表是通用的，可以用来保存<br>很多不同类型的数据</p>
<p>链表保存了一条数据和一个链向另一条数据的链接</p>
<p>如果一个结构包含一个链向同种结构的链接，那么这个结构就被称为递归结构</p>
<p>只要在结构中保存指针，island数据就含有下一个我们将游览的island的地址。只要我们的代码能访问一个island，就能够跳到下一个island。</p>
<p>在递归结构中，需要包含一个相同类型的指针， C语言的语法不允许用typedef别名来声明它，因此必须为结构起一个名字</p>
<h2 id="11-网络与套接字"><a href="#11-网络与套接字" class="headerlink" title="11 网络与套接字"></a>11 网络与套接字</h2><h2 id="十大遗漏知识点"><a href="#十大遗漏知识点" class="headerlink" title="十大遗漏知识点"></a>十大遗漏知识点</h2><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul>
<li><p>递增与递减</p>
<p>++和–的位置决定了表达式返回i的原始值还是新值，前新后旧</p>
</li>
<li><p>三目运算符</p>
<pre><code class="c">if (x == 1)
    return 2;
else
    return 3;

return (x == 1) ? 2 : 3;	//这里上下等价
</code></pre>
</li>
<li><p>位运算</p>
<p>C语言可以用来编写底层代码，为此它提供了一组位运算符：</p>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">~a</td>
<td>a中所有位都取反</td>
</tr>
<tr>
<td align="center">a &amp; b</td>
<td>a中的位“与”b中的位</td>
</tr>
<tr>
<td align="center">a | b</td>
<td>a中的位“或”b中的位</td>
</tr>
<tr>
<td align="center">a ^ b</td>
<td>a中的位“异或”b中的位</td>
</tr>
<tr>
<td align="center">&lt;&lt;</td>
<td>位左移（值增加）</td>
</tr>
<tr>
<td align="center">&gt;&gt;</td>
<td>位右移（值减小）</td>
</tr>
</tbody></table>
<p>&lt;&lt;运算符可以用来快速地将某个整型值乘以2的幂，但小心千万别溢出</p>
</li>
<li><p>用逗号分割表达式<br>for循环在每次循环的末尾都会出现递增操作。<br>但如果你想在循环末尾执行多个运算怎么办？可以使用逗号运算符：<br><code>for (i = 0; i &lt; 10; i++, j++)</code> 递增i和j。<br>之所以要有逗号运算符是因为有时你不想用分号来分割表达式</p>
</li>
</ul>
<h3 id="预处理指令"><a href="#预处理指令" class="headerlink" title="预处理指令"></a>预处理指令</h3>
        <!-- 分类文章 -->
        
      </div>
      <div class="post-content-inner-space">
        
          <div class="space-toc-main animate__animated  animate__fadeInUp">
            <ol class="space-toc"><li class="space-toc-item space-toc-level-2"><a class="space-toc-link" href="#0-%E5%85%B3%E4%BA%8E"><span class="space-toc-text">0 关于</span></a></li><li class="space-toc-item space-toc-level-2"><a class="space-toc-link" href="#1-%E5%85%A5%E9%97%A8"><span class="space-toc-text">1 入门</span></a></li><li class="space-toc-item space-toc-level-2"><a class="space-toc-link" href="#2-%E6%8C%87%E9%92%88"><span class="space-toc-text">2 指针</span></a></li><li class="space-toc-item space-toc-level-2"><a class="space-toc-link" href="#2-5-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%9F%E7%90%86"><span class="space-toc-text">2.5 字符串原理</span></a></li><li class="space-toc-item space-toc-level-2"><a class="space-toc-link" href="#3-%E5%B0%8F%E5%B7%A5%E5%85%B7"><span class="space-toc-text">3 小工具</span></a></li><li class="space-toc-item space-toc-level-2"><a class="space-toc-link" href="#4-%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E6%BA%90%E6%96%87%E4%BB%B6"><span class="space-toc-text">4 使用多个源文件</span></a></li><li class="space-toc-item space-toc-level-2"><a class="space-toc-link" href="#5-%E7%BB%93%E6%9E%84%E3%80%81%E8%81%94%E5%90%88%E4%B8%8E%E4%BD%8D%E5%AD%97%E6%AE%B5"><span class="space-toc-text">5 结构、联合与位字段</span></a></li><li class="space-toc-item space-toc-level-2"><a class="space-toc-link" href="#6-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%8A%A8%E6%80%81%E5%AD%98%E5%82%A8"><span class="space-toc-text">6 数据结构与动态存储</span></a></li><li class="space-toc-item space-toc-level-2"><a class="space-toc-link" href="#11-%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="space-toc-text">11 网络与套接字</span></a></li><li class="space-toc-item space-toc-level-2"><a class="space-toc-link" href="#%E5%8D%81%E5%A4%A7%E9%81%97%E6%BC%8F%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="space-toc-text">十大遗漏知识点</span></a></li></ol>
           </div>
        
      </div>
   </div>
    <!-- 评论 -->
    
  </div>
</article>
  </div>
</div>



<!-- 如果是home模式的话，不在首页就显示footer，如果不是home模式的话 所有都显示footer -->

  <div class="footer-outer animate__animated  animate__fadeInUp">
    <div class="footer-inner">
    <div class="footer-text">
    <p>Keep Thinking of Beloved y³</p>

    </div>
    <div class="footer-contact">
    <ul class="footer-ul">
        
        <li class="footer-li">
            <a href="https://github.com/FuShaoLei/hexo-theme-white" target="_blank">
                <i class="ri-github-line"></i>
            </a>
        </li>
        
        <li class="footer-li">
            <a href="mailto:1563250958@qq.com" target="_blank">
                <i class="ri-mail-line"></i>
            </a>
        </li>
        
    </ul>
    </div>
    </div>
</div>






<script src="/js/white.js"></script>



    
      
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.1/build/highlight.min.js"></script>

      <script>hljs.initHighlightingOnLoad();</script>
    

</body>
</html>
