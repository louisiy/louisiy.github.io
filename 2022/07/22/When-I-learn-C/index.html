


<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>  When I Learn C |    Louisiy.</title>
  <meta name="description" content="A coder&#39;s blog.">
  <!-- 标签页图标 -->
  

  <!-- 图标库 -->
  <link href="https://cdn.jsdelivr.net/npm/remixicon@2.2.0/fonts/remixicon.css" rel="stylesheet">
  <!-- 动画库 -->
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fushaolei/cdn-white@1.0/css/animate.css"/>
  
  <!-- css文件 -->
  
<link rel="stylesheet" href="/css/white.css">

  <!-- 代码高亮 -->
  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>

<div class="menu-outer">
    <div class="menu-inner">
      <div class="menu-site-name  animate__animated  animate__fadeInUp">
        <a href="/">
          Louisiy.
        </a>
        
      </div>
      <div class="menu-group">
        <ul class="menu-ul">
        
          <a href="/" class="nav-link">
            <li class="menu-li  animate__animated  animate__fadeInUp">
              HOME
            </li>
          </a>
        
          <a href="/archives" class="nav-link">
            <li class="menu-li  animate__animated  animate__fadeInUp">
              BLOG
            </li>
          </a>
        
        
        
          <li class="menu-li animate__animated  animate__fadeInUp" id="mobile-menu">
            <i class="ri-menu-line"></i>
          </li>
        
        </ul>

      </div>

    </div>
</div>
<div id="mobile-main" class="animate__animated  animate__fadeIn">
  <div class="mobile-menu-inner">
    <div class="mobile-menu-site-name animate__animated  animate__fadeInUp">
      <a href="/">
        Louisiy.
      </a>
    </div>
    <div class="mobile-menu-group" id="mobile-close">
      <i class="ri-close-line"></i>
    </div>

  </div>

  <div class="mobile-menu-div">
  
    <a href="/" class="mobile-nav-link">
      <div class="mobile-menu-child animate__animated  animate__fadeInUp">
        <span>HOME</span>
      </div>
    </a>
  
    <a href="/archives" class="mobile-nav-link">
      <div class="mobile-menu-child animate__animated  animate__fadeInUp">
        <span>BLOG</span>
      </div>
    </a>
  
  
  </div>


</div>

<div class="body-outer">
  <div class="body-inner">
    
<article class="post-inner">
  <div class="post-content-outer">
    <div class="post-intro">
      <div class="post-title animate__animated  animate__fadeInUp">When I learn C</div>
      <div class="meta-intro animate__animated  animate__fadeInUp">7月 22 2022</div>
      
    </div>
    <div class="post-content-inner">
      <div class="post-content-inner-space">

      </div>
      <div class="post-content-main animate__animated  animate__fadeInUp">
        <!-- top型目录 -->
        
        <h1 id="HERE-IS-NOTE-FOR-Head-First-C-😃"><a href="#HERE-IS-NOTE-FOR-Head-First-C-😃" class="headerlink" title="HERE IS NOTE FOR Head First C 😃"></a>HERE IS NOTE FOR <em>Head First C</em> 😃</h1><h2 id="0-关于"><a href="#0-关于" class="headerlink" title="0 关于"></a>0 关于</h2><p>这里是符号说明，形如</p>
<ul>
<li>这是一条个人笔记</li>
</ul>
<blockquote>
<p>这是小拓展</p>
</blockquote>
<h2 id="1-入门"><a href="#1-入门" class="headerlink" title="1 入门"></a>1 入门</h2><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p><code>gcc -o</code> 设置文件名</p>
<p><code>./name</code> 类Unix操作系统中运行程序必须指定程序所在的目录，除非该程序目录已在PATH环境变量中，所以运行命令</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>C不支持现成的字符串</p>
<p>定义字符串数组需额外加一个字符的空间来容纳<code>/0</code>（NULL字符），字符的索引值为偏移量</p>
<p>单引号通常用来表示单个字符，而双引号通常用来表示字符串。通常应该用双引号来定义字符串。用双引号定义的字符串叫字符串字面值（string literal），比起字符数组，它输入起来也更方便</p>
<p>总线错误（bus error）意味着程序无法更新那一块存储器空间</p>
<h3 id="等号"><a href="#等号" class="headerlink" title="等号"></a>等号</h3><p><code>num = 1</code> 等号用来赋值（assignment）</p>
<p><code>num == 1</code> 检查值是否相等</p>
<p><code>nunm += 2 or num -= 2</code> 加减2</p>
<p><code>num++ or num--</code> 加减1</p>
<h3 id="布尔运算"><a href="#布尔运算" class="headerlink" title="布尔运算"></a>布尔运算</h3><p><code>&amp;&amp; || !</code> 与或非</p>
<p><code>&amp;</code>和<code>|</code>操作符总是计算两个条件，而<code>&amp;&amp;</code>和<code>||</code>可以跳过第二个条件</p>
<p>位运算 <code>6 &amp; 4</code> 等于4</p>
<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>switch语句检查一个单独的值。计算机会在第一个匹配的case语句处开始执行代码。在遇到break或到达switch语句的末尾前，代码会一直运行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(train) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">37</span>:</span><br><span class="line">	winnings = winnings + <span class="number">50</span>;</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">65</span>:</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;头等奖!&quot;</span>);</span><br><span class="line">	winnings = winnings + <span class="number">80</span>;		<span class="comment">//执行完这条接着再+20这条，直到break</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">	winnings = winnings + <span class="number">20</span>;</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">	winnings = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> counter;</span><br><span class="line"><span class="keyword">for</span> (counter = <span class="number">1</span>; counter &lt; <span class="number">11</span>; counter++) &#123;	<span class="comment">//(初始化循环变量；循环运行前检查；循环后执行)</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%i个枣\n&quot;</span>, counter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以用<code>break</code>在任意时刻退出循环</p>
<p>可以用<code>continue</code>随时跳到循环条件处</p>
<h3 id="链式赋值"><a href="#链式赋值" class="headerlink" title="链式赋值"></a>链式赋值</h3><p><code>x = y = 4;</code>给多个变量赋相同值</p>
<h2 id="2-指针"><a href="#2-指针" class="headerlink" title="2 指针"></a>2 指针</h2><p>使用指针的主要目的之一就是让函数共享存储器，指针只是一个保存存储器地址的变量，它们是进程存储器中真实编号的地址</p>
<h3 id="储存器"><a href="#储存器" class="headerlink" title="储存器"></a>储存器</h3><p>局部变量保存在栈（Stack），全局变量保存在全局量区（Globals）</p>
<p><code>&amp;x</code>指x的地址 <code>%p</code>来格式化输出</p>
<blockquote>
<p>栈<br>这是存储器用来保存局部变量的部分。每当调用函数，函数的所有局部变量都在栈上创建。它之所以叫栈是因为它看起来就像堆积而成的栈板：当进入函数时，变量会放到栈顶；离开函数时，把变量从栈顶拿走。奇怪的是，栈做起事来颠三倒四，它从存储器的顶部开始，向下增长。</p>
<p>堆<br>堆用于动态存储：程序在运行时创建一些数据，然后使用很长一段时间。</p>
<p>全局量<br>全局量位于所有函数之外，并对所有函数可见。程序一开始运行时就会创建全局量，可以修改它们，不像常量。</p>
<p>常量<br>常量也在程序一开始运行时创建，但它们保存在只读存储器中。常量是一些在程序中要用到的不变量，你不会想修改它们的值，例如字符串字面值。</p>
<p>代码<br>最后是代码段，很多操作系统都把代码放在存储器地址的低位。代码段也是只读的，它是存储器中用来加载机器代码的部分。</p>
</blockquote>
<h3 id="int"><a href="#int" class="headerlink" title="int *"></a>int *</h3><p><code>int *address_of_x = &amp;x;</code></p>
<p><code>*</code>来解引用，如<code>int value_stored = *address_of_x;</code> 、<code>*address_of_x = 99;</code></p>
<h3 id="sizeof（）"><a href="#sizeof（）" class="headerlink" title="sizeof（）"></a>sizeof（）</h3><p>这是个运算符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"><span class="keyword">sizeof</span>(<span class="string">&quot;Turtles!&quot;</span>);		<span class="comment">//返回9</span></span><br></pre></td></tr></table></figure>

<h3 id="数组变量"><a href="#数组变量" class="headerlink" title="数组变量"></a>数组变量</h3><p>数组变量可以被用作指针，指向数组中的第一个元素。函数参数声明如为数组，则其会被当作指针处理</p>
<p>计算机不会为数组变量分配任何空间，编译器仅在出现它的地方把它替换成数组的起始地址，所以不能把它指向任何其他地方</p>
<blockquote>
<p>指针退化</p>
<p>假如把数组赋给指针变量，指针变量只会包含数组的地址信息，而对数组的长度一无所知，相当于指针丢失了一些信息，也就是指针退化。</p>
<p>只要把数组传递给函数，数组免不了退化为指针，但需要记清楚代码中有哪些地方发生过数组退化，因为它们会引发一些不易察觉的错误。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> drinks[] = &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;		<span class="comment">//drinks[i] == *(drinks + i)</span></span><br><span class="line">doses[<span class="number">3</span>] == *(doses + <span class="number">3</span>) == *(<span class="number">3</span> + doses) == <span class="number">3</span>[doses]</span><br></pre></td></tr></table></figure>

<h3 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h3><p>指针之所以有类型，是因为编译器在指针算术运算时需要知道加几</p>
<p>如<code>int nums[] = &#123;1, 2, 3&#125;;</code>中<code>nums</code>与<code>nums+1</code>的地址间隔4个字节（如果int通常占4个字节）</p>
<ul>
<li>这里的数组内的每一个值都是int类型，都占4字节</li>
</ul>
<h3 id="scanf-vs-fgets"><a href="#scanf-vs-fgets" class="headerlink" title="scanf() vs fgets()"></a>scanf() vs fgets()</h3><p><code>scanf()</code>会导致缓冲区溢出,引发段错误（abort trap）,应限制<code>scanf()</code>读取字符串的长度</p>
<p><code>fgets(char指针，sizeof(char指针),stdin)</code> stdin表示数据来自键盘</p>
<p><code>fgets()</code>缓冲区大小把<code>\0</code>字符也算了进去，所以不必像<code>scanf()</code>那样把长度减1</p>
<p>如果要向<code>fgets()</code>函数传递数组变量，就用<code>sizeof</code>，如果只是传指针，就应该输入想要的长度。</p>
<p><code>scanf()</code>不但允许输入多个字段，而且允许输入结构化数据，可以指定两个字段之间以什<br>么字符分割，<code>fgets()</code>只允许向缓冲区中输入一个字符串，而且只能是字符串，不能是其他数据类型，只能有一个缓冲区</p>
<p>当<code>scanf()</code>用<code>%s</code>读取字符串时，遇到空格就会停止。如果想要输入多个单词，需要多次调用<code>scanf()</code>，或使用一些复杂的正则表达式技巧，<code>fgets()</code>总能读取整个字符串</p>
<p><strong>Conclusion</strong>:	如果需要输入由多个字段构成的结构化数据，可以使用<code>scanf()</code>；而如果想要输入一个非结构化的字符串，<code>fgets()</code>将是不二之选</p>
<h3 id="cards-还是-cards"><a href="#cards-还是-cards" class="headerlink" title="cards[ ]还是*cards"></a>cards[ ]还是*cards</h3><p>字符串字面值保存在只读存储器中。如果想要修改字符串，需要在新的数组中创建副本。可以将char指针声明成为<code>const char *</code>，以防代码用它修改字符串</p>
<h2 id="2-5-字符串原理"><a href="#2-5-字符串原理" class="headerlink" title="2.5 字符串原理"></a>2.5 字符串原理</h2><h3 id="创建数组的数组"><a href="#创建数组的数组" class="headerlink" title="创建数组的数组"></a>创建数组的数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> tracks[][<span class="number">80</span>] = &#123;			<span class="comment">//第一对方括号用来访问由所有字符串组成的数组</span></span><br><span class="line">    						  <span class="comment">//第二对方括号用来访问每个单独的字符串</span></span><br><span class="line">	<span class="string">&quot;I left my heart in Harvard Med School&quot;</span>,</span><br><span class="line">	<span class="string">&quot;Newark, Newark - a wonderful town&quot;</span>,</span><br><span class="line">	<span class="string">&quot;Dancing with a Dork&quot;</span>,</span><br><span class="line">	<span class="string">&quot;From here to maternity&quot;</span>,</span><br><span class="line">	<span class="string">&quot;The girl from Iwo Jima&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以用<code>char strings[...][...]</code>来创建数组的数组。<br>第一组方括号用来访问外层数组<br>第二组方括号用来访问每个内层数组中的元素</p>
<h3 id="使用string-h"><a href="#使用string-h" class="headerlink" title="使用string.h"></a>使用string.h</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="built_in">strcmp</span>()</span><br><span class="line">可以比较字符串</span><br><span class="line"><span class="built_in">strchr</span>()</span><br><span class="line">用来在字符串中找到某个字符的位置</span><br><span class="line"><span class="built_in">strlen</span>()</span><br><span class="line">可以得到字符串的长度</span><br><span class="line"><span class="built_in">strcpy</span>()</span><br><span class="line">可以复制字符串</span><br></pre></td></tr></table></figure>

<p>使用以上代码引用头文件</p>
<h3 id="使用strstr（）"><a href="#使用strstr（）" class="headerlink" title="使用strstr（）"></a>使用strstr（）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s0[] = <span class="string">&quot;dysfunctional&quot;</span>;</span><br><span class="line"><span class="type">char</span> s1[] = <span class="string">&quot;fun&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strstr</span>(s0, s1))</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;我在dysfunctional中找到fun了!&quot;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>全局变量位于任何函数之外，所有函数都可以调用它们。</p>
</blockquote>
<h3 id="指针的数组"><a href="#指针的数组" class="headerlink" title="指针的数组"></a>指针的数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *names_for_dog[] = &#123;<span class="string">&quot;Bowser&quot;</span>, <span class="string">&quot;Bonza&quot;</span>, <span class="string">&quot;Snodgrass&quot;</span>&#125;;</span><br><span class="line"><span class="comment">//可以像访问数组的数组那样访问指针的数组,一个字符串字面值配一个指针</span></span><br></pre></td></tr></table></figure>



<h2 id="3-小工具"><a href="#3-小工具" class="headerlink" title="3 小工具"></a>3 小工具</h2><p>小工具设计遵循以下原则：</p>
<ul>
<li>从标准输入读取数据</li>
<li>在标准输出显示数据</li>
<li>处理文本数据，而不是难以阅读的二进制格式</li>
<li>只做一件简单的事</li>
<li>如果想完成一个不同的任务，应该另外写一个小工具</li>
<li>小工具通常读写文本数据</li>
</ul>
<h3 id="过滤器（filter）"><a href="#过滤器（filter）" class="headerlink" title="过滤器（filter）"></a>过滤器（filter）</h3><p>这是一种小工具，它逐行读取数据，对数据进行处理，再把数据写到某个地方。如果你的计算机是Unix，或你在Windows上安装了Cygwin，就已经拥有很多过滤器工具了。</p>
<blockquote>
<p>head：显示文件前几行的内容<br>tail：显示文件最后几行的内容<br>sed：流编辑器（stream editor），用来搜索和替换文本</p>
</blockquote>
<h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>可以重定向标准输入、标准输出，让程序从键盘以外的地方读数据、往显示器以外的地方写数据，如文件。可用命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./geo2json &lt; gpsdata.csv &gt; output.json</span><br></pre></td></tr></table></figure>

<h3 id="错误状态码"><a href="#错误状态码" class="headerlink" title="错误状态码"></a>错误状态码</h3><p>程序在数据中发现错误就会退出，并把退出状态置为2。怎么在程序结束后检查错误状态呢？</p>
<p>要看操作系统</p>
<p>如果你的计算机是Mac、Linux、其他UNIX，或你在Windows上使用Cygwin，可以用以下命令显示错误状态：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> $?</span><br></pre></td></tr></table></figure>

<p>如果用的是Windows的命令提示符，则可以输入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt; <span class="built_in">echo</span> %ERRORLEVEL%</span><br></pre></td></tr></table></figure>

<p>这两条命令做了相同的事：显示程序结束时返回的那个数字。</p>
<h3 id="标准错误"><a href="#标准错误" class="headerlink" title="标准错误"></a>标准错误</h3><p>标准错误——一个用来发送错误消息的二号输出</p>
<p>人有两只耳朵和一张嘴，但进程有一只耳朵（标准输入）和两张嘴（标准输出和标准错误）</p>
<h3 id="fprintf-打印到数据流"><a href="#fprintf-打印到数据流" class="headerlink" title="fprintf()打印到数据流"></a>fprintf()打印到数据流</h3><p>printf()函数可以将数据发送到标准输出，但printf()只是fprintf()一个的特例</p>
<p>scanf()  fscanf(stdin, …)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;我喜欢乌龟！&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;我喜欢乌龟！&quot;</span>);</span><br><span class="line"><span class="comment">//以上命令等价</span></span><br></pre></td></tr></table></figure>

<p>stdout 标准输出</p>
<p>stderr  标准错误</p>
<p>stdin 标准输入</p>
<p><code>&gt;</code>重定向标准输出	<code>&lt;</code>重定向标准输入	<code>2&gt;</code>重定向标准错误</p>
<h3 id="用管道连接输入与输出"><a href="#用管道连接输入与输出" class="headerlink" title="用管道连接输入与输出"></a>用管道连接输入与输出</h3><p>符号 | 表示管道（pipe），它能连接一个进程的标准输出与另一个进程的标准输入</p>
<p><code>bermuda | geo2json</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; (./bermuda | ./geo2json) &lt; spooky.csv &gt; output.json</span><br></pre></td></tr></table></figure>

<p>只要在每个程序前加上一个<code>|</code>就可以连接多个程序，一连串相连的进程就叫流水线（pipeline），这时<code>&lt;</code>会把文件内容发送到流水线中第一个进程的标准输入，<code>&gt;</code>会捕获流水线中最后一个进程的标准输出</p>
<p>外面的括号是必需的,这对括号保证了数据文件由bermuda程序的标准输入来读取</p>
<h3 id="创建自己的数据流"><a href="#创建自己的数据流" class="headerlink" title="创建自己的数据流"></a>创建自己的数据流</h3><p>每条数据流用一个指向文件的指针来表示，可以用<code>fopen()</code>函数创建新数据流</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FILE *in_file = fopen(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);	<span class="comment">//将创建一条数据流，从文件中读取数据</span></span><br><span class="line">FILE *out_file = fopen(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);	<span class="comment">//将创建一条数据流，向文件写数据</span></span><br></pre></td></tr></table></figure>

<p>fopen()函数接收两个参数：文件名和模式。共有三种模式</p>
<p>“w”&#x3D; 写（write）	写文件<br>“r”&#x3D; 读（read）	读文件<br>“a”&#x3D; 追加（append）	在文件末尾追加数据</p>
<p>创建数据流后，可以用fprintf()往数据流中打印数据<br>可以用fscanf()函数从文件中读取数据</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(out_file, <span class="string">&quot;%s 和 %s &quot;</span>, <span class="string">&quot;红 &quot;</span>, <span class="string">&quot;绿&quot;</span>);</span><br><span class="line"><span class="built_in">fscanf</span>(in_file, <span class="string">&quot;%79[^\n]\n&quot;</span>, sentence);</span><br></pre></td></tr></table></figure>

<p>最当用完数据流，别忘了关闭它。虽然所有的数据流在程序结束后都会自动关闭，但你仍应该自己关闭它们</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fclose(in_file);</span><br><span class="line">fclose(out_file);</span><br></pre></td></tr></table></figure>

<p>通常情况下，一个进程最多可以有256条数据流。但数据流的数量是有限的，用完后应该关闭它们。</p>
<p>最早FILE是用宏定义的，而宏的名字通常都要大写。</p>
<h3 id="首选项"><a href="#首选项" class="headerlink" title="首选项"></a>首选项</h3><p>对GUI程序来说，可以修改程序的首选项；而对于categorize这样的命令行程序，可以传给它命令行参数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">.... 做事情....</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>main()函数有两个版本，一个有命令行参数，一个没有。命令行参数通过两个变量传递给main()函数，一个是参数的计数（argc），另一个是指针（指向参数字符串）数组</p>
<p>用户运行程序时，命令行中第一个参数是程序名。也就是说，第一个命令行参数其实是argv[1]</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;./categorize mermaid mermaid.csv Elvis elvises.csv the_rest.csv</span><br><span class="line">   argv[0]	 argv[1]				...				argv[5]</span><br></pre></td></tr></table></figure>

<p>在程序中打开文件准备读写时，最好检查一下有没有错误发生。好在如果数据流打开失败，fopen()函数会返回0，也就是说如果想检查错误，可以将下面这段代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE *in = fopen(<span class="string">&quot;我不存在.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>改成这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FILE *in;</span><br><span class="line"><span class="keyword">if</span> (!(in = fopen(<span class="string">&quot;我不存在.txt&quot;</span>, <span class="string">&quot;r&quot;</span>))) &#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;无法打开文件.\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用库-getopt"><a href="#使用库-getopt" class="headerlink" title="使用库 getopt()"></a>使用库 getopt()</h3><p>unistd.h头文件不属于C标准库，而是POSIX库中的一员。POSIX的目标是创建一套能够在所有主流操作系统上使用的函数。</p>
<p>getop()使用范例</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; rocket_to -e 4 -a Brasilia Tokyo London</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">while</span> ((ch = getopt(argc, argv, <span class="string">&quot;ae:&quot;</span>)) != EOF)</span><br><span class="line"><span class="comment">//ae:告诉getopt()函数“a和e是有效选项”，e后面的冒号表示“-e后面需要再跟一个参数”，getopt()会用optarg变量指向这个参数</span></span><br><span class="line">	<span class="keyword">switch</span>(ch) &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">		engine_count = optarg;</span><br><span class="line">	...</span><br><span class="line">	&#125;</span><br><span class="line">argc -= optind;		<span class="comment">//最后这两行用来跳过已读取的选项</span></span><br><span class="line">argv += optind;		<span class="comment">//optind保存了“getopt()函数从命令行读取了几个选项”</span></span><br></pre></td></tr></table></figure>

<p>经过一番处理，0号参数不再是程序名了。argv[0]会指向选项后的第一个命令行参数。循环结束以后，为了让程序读取命令行参数，需要调整一下argv和argc变量，跳过所有选项。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; rocket_to -e 4 -a Brasilia  Tokyo   London</span><br><span class="line">					argv[0]  argv[1]  argv[2]</span><br></pre></td></tr></table></figure>

<p>Tips：</p>
<ul>
<li>可以多个选项<code>abc:d</code></li>
<li>可以合并命令行里的选项，如：<code>-td now</code> 与 <code>-d now -t</code></li>
<li>可以改变选项之间顺序，因为我们用循环读取选项，所以 <code>-d now -t</code>、<code>-t -d now</code>、<code>-td now</code>都一样(</li>
<li>只要程序在命令行看到一个前缀为－值，就会把它当成选项处理，前提是它必须在命令行参数之前出现</li>
<li>为了避免歧义，可以用<code>--</code>隔开参数和选项，比如<code>set_temper-ature -c -- -4</code>。getopt()看到<code>--</code>就会停止读取选项，程序会把后面的内容当成普通的命令行参数读取</li>
</ul>
<h2 id="4-使用多个源文件"><a href="#4-使用多个源文件" class="headerlink" title="4 使用多个源文件"></a>4 使用多个源文件</h2><h3 id="简明数据类型指南"><a href="#简明数据类型指南" class="headerlink" title="简明数据类型指南"></a>简明数据类型指南</h3><ul>
<li>char<br>字符在计算机的存储器中以字符编码的形式保存，字符编码是一个数字，因此在计算机看来，A与数字65完全一样（ASCII码）</li>
<li>int<br>如果你要保存一个整数，通常可以使用int。不同计算机中int的大小不同，但至少应该有16位。一般而言，int可以保存几万以内的数字</li>
<li>long<br>但如果想保存一个很大的计数呢？long数据类型就是为此而生的。在某些计算机中，long的大小是int的两倍，所以可以保存几十亿以内的数字；但大部分计算机的long和int一样大，因为在这些计算机中int本身就很大。long至少应该有32位</li>
<li>float<br>float是保存浮点数的基本数据类型。平时你会碰到很多浮点数，比如一杯香橙摩卡冰乐有多少毫升，就可以用float保存</li>
<li>double<br>但如果想表示很精确的浮点数呢？如果想让计算结果精确到小数点以后很多位，可以使用double。double比float多占一倍空间，可以保存更大、更精确的数字</li>
</ul>
<blockquote>
<p>为什么把一个很大的数保存到short中会变成负数？</p>
<p>数字以二进制保存，二进制的100 000看起来像这样：<br>x &lt;- 0001 1000 0110 1010 0000<br>当计算机想把这个值保存到short时，发现只能保存2个字节，所以只保存了数字右半边：<br>y &lt;- 1000 0110 1010 0000<br>最高位是1的二进制有符号数会被当成负数处理，它等价于下面的十进制数：<br>-31072</p>
</blockquote>
<h3 id="使用类型转换临时转换数值的类型"><a href="#使用类型转换临时转换数值的类型" class="headerlink" title="使用类型转换临时转换数值的类型"></a>使用类型转换临时转换数值的类型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//float z = (float)x / (float)y;</span></span><br><span class="line"><span class="type">float</span> z = (<span class="type">float</span>)x / y</span><br><span class="line"><span class="comment">//如果编译器发现有整数在加、减、乘、除浮点数，会自动完成转换，因此可以减少代码中显式类型转换的次数：</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;z = %f\n&quot;</span>, z);</span><br></pre></td></tr></table></figure>

<h3 id="两个关键字"><a href="#两个关键字" class="headerlink" title="两个关键字"></a>两个关键字</h3><p>unsigned<br>用unsigned修饰的数值只能是非负数。由于无需记录负数，无符号数有更多的位可以使用，因此它可以保存更大的数。unsigned int可以保存0到最大值的数。这个最大值是int可以保存最大值的两倍左右。还有signed关键字，但你几乎从没见过，因为所有数据类型默认都是有符号的。<br><code>unsigned char c;</code></p>
<p>long<br>没错，你可以在数据类型前加long，让它变长。longint是加长版的int；long int可以保存范围更广的数字；long long比long更长；还可以对浮点数用long。(c99和c11支持long long)<br><code>long double d;</code></p>
<blockquote>
<p>%.2f把浮点数格式化为小数点后两位</p>
<p>%hi用来格式化short</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span> <span class="comment">//含有表示整型（比如int和char）大小的值</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;float.h&gt;</span> <span class="comment">//含有表示float和double类型大小的值</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The value of INT_MAX is %i\n&quot;</span>, INT_MAX);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The value of INT_MIN is %i\n&quot;</span>, INT_MIN);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;An int takes %z bytes\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The value of FLT_MAX is %f\n&quot;</span>, FLT_MAX);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The value of FLT_MIN is %.50f\n&quot;</span>, FLT_MIN);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;A float takes %z bytes\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">float</span>));</span><br><span class="line">    <span class="comment">//可把INT和FLT替换成CHAR（char）、DBL（double）、SHRT（short）或LNG（long）</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>位数是计算机能够处理的数值长度</p>
</blockquote>
<h3 id="声明与定义分离"><a href="#声明与定义分离" class="headerlink" title="声明与定义分离"></a>声明与定义分离</h3><p><code>float add_with_tax()(float f);</code></p>
<p>声明只是一个函数签名：一条包含函数名、形参类型与返回类型的记录</p>
<h3 id="创建头文件"><a href="#创建头文件" class="headerlink" title="创建头文件"></a>创建头文件</h3><p>两步</p>
<ol>
<li>创建一个扩展名为.h的文件，把你的声明写在里面，不用在头文件中包含main()函数，反正也没有函数会调用它</li>
<li>在主代码中包含头文件，应该在代码的顶部加一句include</li>
</ol>
<p><code>#include &#39;asdf.h&#39;</code> <code>#include &lt;stdio.h&gt;</code></p>
<p>通常情况下，引号表示以相对路径查找头文件，如果不加目录名，只包含一个文件名，编译器就会在当前目录下查找头文件；如果用了尖括号，编译器就会以绝对路径查找头文件</p>
<p>当编译器看到尖括号，就会到标准库代码所在目录查找头文件，但现在你的头文件和.c文件在同一目录下，用引号把文件名括起来，编译器就会在本地查找文件。本地头文件也可以带目录名，但通常会把它和C文件放在相同目录中。</p>
<p>当编译器在代码中读到#include，就会读取头文件中的内容，仿佛它们本来就在代码中。</p>
<blockquote>
<p>如果编译器发现你调用了一个它没见过的函数，就会假设这个函数返回int</p>
</blockquote>
<h3 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h3><table>
<thead>
<tr>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
</tr>
</thead>
<tbody><tr>
<td align="center">auto</td>
<td align="center">if</td>
<td align="center">break</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">case</td>
<td align="center">long</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">register</td>
<td align="center">continue</td>
</tr>
<tr>
<td align="center">return</td>
<td align="center">default</td>
<td align="center">short</td>
</tr>
<tr>
<td align="center">do</td>
<td align="center">sizeof</td>
<td align="center">double</td>
</tr>
<tr>
<td align="center">static</td>
<td align="center">else</td>
<td align="center">struct</td>
</tr>
<tr>
<td align="center">entry</td>
<td align="center">switch</td>
<td align="center">extern</td>
</tr>
<tr>
<td align="center">typeof</td>
<td align="center">float</td>
<td align="center">union</td>
</tr>
<tr>
<td align="center">for</td>
<td align="center">unsigned</td>
<td align="center">goto</td>
</tr>
<tr>
<td align="center">while</td>
<td align="center">enum</td>
<td align="center">void</td>
</tr>
<tr>
<td align="center">const</td>
<td align="center">signed</td>
<td align="center">volatile</td>
</tr>
</tbody></table>
<h3 id="共享代码"><a href="#共享代码" class="headerlink" title="共享代码"></a>共享代码</h3><p>为了共享代码，可以把代码放到一个单独的C文件中。<br>需要把函数声明放到一个单独的.h头文件中。<br>在所有需要使用共享代码的C文件中包含这个头文件。<br>在编译的命令中列出所有C文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//encrypt.h</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">encrypt</span><span class="params">(<span class="type">char</span> *message)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//encrypt.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;encrypt.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">encrypt</span><span class="params">(<span class="type">char</span> *message)</span>&#123;</span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">	<span class="keyword">while</span> (*message) &#123;</span><br><span class="line">	*message = *message ^ <span class="number">31</span>;</span><br><span class="line">	message++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mainprog.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;encrypt.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">char</span> msg[<span class="number">80</span>];</span><br><span class="line">	<span class="keyword">while</span> (fgets(msg, <span class="number">80</span>, <span class="built_in">stdin</span>)) &#123;</span><br><span class="line">	encrypt(msg);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, msg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ gcc message_hider.c encrypt.c -o message_hider</span><br></pre></td></tr></table></figure>

<blockquote>
<p>共享变量<br>为了防止两个源文件中的同名变量相互干扰，变量的作用域仅限于某个文件内。如果你想共享变量，就应该在头文件中声明，并在变量名前加上extern关键字：<br><code>extern int passcode;</code></p>
</blockquote>
<h3 id="gccの编译"><a href="#gccの编译" class="headerlink" title="gccの编译"></a>gccの编译</h3><p>gcc -c会编译代码，但不会链接目标文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ gcc -c *.c</span><br></pre></td></tr></table></figure>

<p>gcc -o 链接，在例子中把目标文件链接为一个叫launch的可执行程序</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ gcc *.o -o launch</span><br></pre></td></tr></table></figure>

<h3 id="Make"><a href="#Make" class="headerlink" title="Make"></a>Make</h3><p>如果你掌握了某样东西的简单规则，别多想，自动化它</p>
<p>make编译的文件叫目标（target）。目标可以是任何用其他文件生成的文件，也就是说目标可以是一批文件压缩而成的压缩文档</p>
<p>make需要知道：依赖项、生成方法。依赖项和生成方法合在一起构成了一条规则。有了规则，make就知道如何生成目标</p>
<blockquote>
<p>versions :</p>
<p>UNIX make</p>
<p>MinGW mingw32-make</p>
<p>Microsoft  NMAKE</p>
</blockquote>
<p>makefile文件书写</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">launch.o: launch.c launch.h thruster.h		//目标：依赖项</span></span><br><span class="line">	gcc -c launch.c							//生成方法（必须以tab开头）</span><br><span class="line">											//这是规则</span><br><span class="line"><span class="section">thruster.o: thruster.h thruster.c</span></span><br><span class="line">	gcc -c thruster.c</span><br><span class="line"><span class="section">launch: launch.o thruster.o</span></span><br><span class="line">	gcc launch.o thruster.o -o launch</span><br></pre></td></tr></table></figure>

<p>之后直接</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ make launch</span><br></pre></td></tr></table></figure>

<blockquote>
<p>更自动化的工具：autoconf</p>
</blockquote>
<p>-&gt; <a target="_blank" rel="noopener" href="http://tinyurl.com/yczmjx">GUN Make Manual</a></p>
<h2 id="5-结构、联合与位字段"><a href="#5-结构、联合与位字段" class="headerlink" title="5 结构、联合与位字段"></a>5 结构、联合与位字段</h2><h3 id="结构-Struct"><a href="#结构-Struct" class="headerlink" title="结构 Struct"></a>结构 Struct</h3><p>结构化数据结构 structured data type</p>
<p>结构是一种由一系列其他数据类型组成的数据类型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fish</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *species;</span><br><span class="line">	<span class="type">int</span> teeth;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>创建一个新自定义的数据类型，由其它一批数据组成。</p>
<ul>
<li>结构的大小固定</li>
<li>结构中的数据都有名字</li>
</ul>
<p>创建数据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fish</span> <span class="title">snappy</span> =</span> &#123;<span class="string">&quot;Snappy&quot;</span>, <span class="string">&quot;Piranha&quot;</span>, <span class="number">69</span>, <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure>

<p>把参数封装在结构中，代码会更稳定</p>
<p>结构变量是结构本身的名字</p>
<p>读取时只能按名访问，使用“.”运算符读取结构字段：&lt;结构&gt;.&lt;字段名&gt;语法（也叫“点表示法”）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fish</span> <span class="title">snappy</span> =</span> &#123;<span class="string">&quot;Snappy&quot;</span>, <span class="string">&quot;piranha&quot;</span>, <span class="number">69</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Name = %s\n&quot;</span>, snappy.name);</span><br></pre></td></tr></table></figure>

<p>为结构变量赋值相当于叫计算机复制数据</p>
<h3 id="结构中的结构"><a href="#结构中的结构" class="headerlink" title="结构中的结构"></a>结构中的结构</h3><p>为什么要嵌套定义结构？</p>
<p>之所以要这么做是为了对抗复杂性 。通过使用结构，我们可以建立更大的数据块。通过把结构组合在一起，我们可以创建更大的数据结构。本来你只能用int、short，但有了结构以后，就可以描述十分复杂的东西，比如网络流和视频图像。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">preferences</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *food;</span><br><span class="line">	<span class="type">float</span> exercise_hours;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fish</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *species;</span><br><span class="line">	<span class="type">int</span> teeth;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">preferences</span> <span class="title">care</span>;</span> <span class="comment">//nesting 嵌套</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">fish</span> <span class="title">snappy</span> =</span> &#123;<span class="string">&quot;Snappy&quot;</span>, <span class="string">&quot;Piranha&quot;</span>, <span class="number">69</span>, <span class="number">4</span>, &#123;<span class="string">&quot;Meat&quot;</span>, <span class="number">7.5</span>&#125;&#125;;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Snappy 喜欢吃 %s&quot;</span>, snappy.care.food);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Snappy 喜欢锻炼 %f hours&quot;</span>, snappy.care.exercise_hours); <span class="comment">//访问</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h3><p>在C语言中可以为结构创建别名，你只要在struct关键字前加上typedef，并在右花括号后写上类型名，就可以在任何地方使用这种新类型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cell_phone</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> cell_no;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *wallpaper;</span><br><span class="line">	<span class="type">float</span> minutes_of_charge;</span><br><span class="line">&#125; phone;</span><br></pre></td></tr></table></figure>

<p>当你用typedef为结构创建别名，需要决定别名叫什么。别名其实就是类型名，也就是说结构有两个名字：一个是结构名（struct cell_phone），另一个是类型名（phone）。为什么要有两个名字？一般一个就够了。如果只写类型名而不写结构名，编译器也没意见：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> cell_no;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *wallpaper;</span><br><span class="line">	<span class="type">float</span> minutes_of_charge;</span><br><span class="line">&#125; phone;</span><br><span class="line">phone p = &#123;<span class="number">5557879</span>, <span class="string">&quot;s.png&quot;</span>, <span class="number">1.35</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>这样的结构称为匿名结构。</p>
<h3 id="更新结构"><a href="#更新结构" class="headerlink" title="更新结构"></a>更新结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fish snappy = &#123;<span class="string">&quot;Snappy&quot;</span>, <span class="string">&quot;piranha&quot;</span>, <span class="number">69</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello %s\n&quot;</span>, snappy.name);</span><br><span class="line">snappy.teeth = <span class="number">68</span>;</span><br></pre></td></tr></table></figure>

<p>计算机通过把值赋给函数形参的方式向函数传值，所有赋值都会复制</p>
<p>如果想让函数更新结构变量，就不能把结构作为参数传递，因为这样做仅仅是将数据的副本复制给<br>了函数。取而代之，可以传递结构的地址</p>
<p>还有一种表示结构指针的方法，它更易于阅读。</p>
<p><code>(*t).age</code> 和 <code>t-&gt;age</code> 等价</p>
<p>“指针-&gt;字段”等于“(*指针).字段”	“-&gt;”表示法省掉了括号，代码更易阅读。</p>
<h3 id="联合？"><a href="#联合？" class="headerlink" title="联合？"></a>联合？</h3><p>每次创建结构实例，计算机都会在存储器中相继摆放字段</p>
<p>联合则不同。当定义联合时，计算机只为其中一个字段分配空间，并且计算机会为其中最大的字段分配空间，然后由你决定里面保存什么值</p>
<blockquote>
<p>计算机需要保证联合的大小固定。唯一的办法就是让它足够大，任何一个字段都能装得下</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> &#123;</span>			<span class="comment">//这里的关键字是union</span></span><br><span class="line">	<span class="type">short</span> count;</span><br><span class="line">	<span class="type">float</span> weight;</span><br><span class="line">	<span class="type">float</span> volume;</span><br><span class="line">&#125; quantity;</span><br></pre></td></tr></table></figure>

<h3 id="使用联合"><a href="#使用联合" class="headerlink" title="使用联合"></a>使用联合</h3><ul>
<li><p>C89 方式</p>
<p>把值赋给联合中第一个字段</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quantity q = &#123;<span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定初始化器（designated initializer）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quantity q = &#123; .weight = <span class="number">1.5</span> &#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>点 表示法</p>
<p>在第一行创建变量，然后在第二行设置字段的值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">quantity q;</span><br><span class="line">q.volume = <span class="number">3.7</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>无论用哪种方法设置联合的值，都只会保存一条数据。联合只是提供了一种创建支持不同数据类型的变量的方法</p>
<p>“指定初始化器”也可以用来设置结构字段的初值，并提高代码的可读性</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *color;</span><br><span class="line">	<span class="type">int</span> gears;</span><br><span class="line">	<span class="type">int</span> height;</span><br><span class="line">&#125; bike;</span><br><span class="line"></span><br><span class="line">bike b = &#123;.height=<span class="number">17</span>, .gears=<span class="number">21</span>&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="联合与结构"><a href="#联合与结构" class="headerlink" title="联合与结构"></a>联合与结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name ;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *country;</span><br><span class="line">    quantity amount;</span><br><span class="line">&#125; fruit_order;</span><br><span class="line"></span><br><span class="line">fruit_order apples = &#123;<span class="string">&quot;apples&quot;</span>,<span class="string">&quot;English&quot;</span>,.amount.weight = <span class="number">4.2</span>&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;This order contains %2.2f lbs of %s\n&quot;</span>,apples.amount.weight, apples.name);</span><br></pre></td></tr></table></figure>

<h3 id="枚举变量保存符号"><a href="#枚举变量保存符号" class="headerlink" title="枚举变量保存符号"></a>枚举变量保存符号</h3><p>你需要某种方法记录我们在联合中保存了什么值。</p>
<p>结构与联合用分号（;）来分割数据项，而枚举用逗号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">colors</span> &#123;</span>RED, GREEN, PUCE&#125;;		<span class="comment">//可以用typedef为类型起个名字</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">colors</span> <span class="title">favorite</span> =</span> PUCE;</span><br></pre></td></tr></table></figure>

<p><em><strong>so? 枚举好处？？？</strong></em> 限制我能给的值？ 实例感受下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    COUNT,</span><br><span class="line">    POUNDS,</span><br><span class="line">    PINTS</span><br><span class="line">&#125;unit_of_measure;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *country;</span><br><span class="line">    quantity amount;</span><br><span class="line">    unit_of_measure units;</span><br><span class="line">&#125;fruit_order;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">display</span><span class="params">(fruit_order order)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This order contains &quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (order.units==PINTS) <span class="built_in">printf</span>(<span class="string">&quot;%2.2f pints of %s\n&quot;</span>, order.amount.volume, order.name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (order.units==POUNDS) <span class="built_in">printf</span>(<span class="string">&quot;%2.2f lbs of %s\n&quot;</span>, order.amount.weight, order.name);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%i %s\n&quot;</span>, order.amount.count, order.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    fruit_order strawberries= &#123;</span><br><span class="line">        <span class="string">&quot;strawberries&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Spain&quot;</span>,</span><br><span class="line">        .amount.weight=<span class="number">17.6</span>,</span><br><span class="line">        POUNDS</span><br><span class="line">    &#125;;</span><br><span class="line">    display(strawberries);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="位字段（bitfield）"><a href="#位字段（bitfield）" class="headerlink" title="位字段（bitfield）"></a>位字段（bitfield）</h3><p>C语言不支持二进制字面值，不过它支持十六进制字面值。每当C语言看到0x开头的数字，就认为它是以16为基数的数字（0x54）</p>
<p>可以用位字段指定一个字段有多少位</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> low_pass_vcf:<span class="number">1</span>;		<span class="comment">//位字段应当声明为unsigned int</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> filter_coupler:<span class="number">1</span>;		<span class="comment">//表示该字段只使用1位存储空间</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> reverb:<span class="number">1</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> sequential:<span class="number">4</span>;</span><br><span class="line">	...</span><br><span class="line">&#125; synth;</span><br></pre></td></tr></table></figure>

<p>如果你有一连串的位字段，计算机会放在一起，以节省空间，也就是说如果有8个1位的位字段，计算机就会把它们保存在一个字节中</p>
<p>如果编译器发现结构中只有一个位字段，还是会把它填充成一个字，这就是为什么位字段总是组合在一起</p>
<h2 id="6-数据结构与动态存储"><a href="#6-数据结构与动态存储" class="headerlink" title="6 数据结构与动态存储"></a>6 数据结构与动态存储</h2><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>保存可变数量的数据</p>
<p>链表是一种抽象数据结构。链表是通用的，可以用来保存<br>很多不同类型的数据</p>
<p>链表保存了一条数据和一个链向另一条数据的链接</p>
<p>如果一个结构包含一个链向同种结构的链接，那么这个结构就被称为递归结构</p>
<p>只要在结构中保存指针，island数据就含有下一个我们将游览的island的地址。只要我们的代码能访问一个island，就能够跳到下一个island。</p>
<p>在递归结构中，需要包含一个相同类型的指针， C语言的语法不允许用typedef别名来声明它，因此必须为结构起一个名字</p>
<h2 id="11-网络与套接字"><a href="#11-网络与套接字" class="headerlink" title="11 网络与套接字"></a>11 网络与套接字</h2><h2 id="十大遗漏知识点"><a href="#十大遗漏知识点" class="headerlink" title="十大遗漏知识点"></a>十大遗漏知识点</h2><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul>
<li><p>递增与递减</p>
<p>++和–的位置决定了表达式返回i的原始值还是新值，前新后旧</p>
</li>
<li><p>三目运算符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x == <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (x == <span class="number">1</span>) ? <span class="number">2</span> : <span class="number">3</span>;	<span class="comment">//这里上下等价</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>位运算</p>
<p>C语言可以用来编写底层代码，为此它提供了一组位运算符：</p>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">~a</td>
<td>a中所有位都取反</td>
</tr>
<tr>
<td align="center">a &amp; b</td>
<td>a中的位“与”b中的位</td>
</tr>
<tr>
<td align="center">a | b</td>
<td>a中的位“或”b中的位</td>
</tr>
<tr>
<td align="center">a ^ b</td>
<td>a中的位“异或”b中的位</td>
</tr>
<tr>
<td align="center">&lt;&lt;</td>
<td>位左移（值增加）</td>
</tr>
<tr>
<td align="center">&gt;&gt;</td>
<td>位右移（值减小）</td>
</tr>
</tbody></table>
<p>&lt;&lt;运算符可以用来快速地将某个整型值乘以2的幂，但小心千万别溢出</p>
</li>
<li><p>用逗号分割表达式<br>for循环在每次循环的末尾都会出现递增操作。<br>但如果你想在循环末尾执行多个运算怎么办？可以使用逗号运算符：<br><code>for (i = 0; i &lt; 10; i++, j++)</code> 递增i和j。<br>之所以要有逗号运算符是因为有时你不想用分号来分割表达式</p>
</li>
</ul>
<h3 id="预处理指令"><a href="#预处理指令" class="headerlink" title="预处理指令"></a>预处理指令</h3>
        <!-- 分类文章 -->
        
      </div>
      <div class="post-content-inner-space">
        
          <div class="space-toc-main animate__animated  animate__fadeInUp">
            <ol class="space-toc"><li class="space-toc-item space-toc-level-2"><a class="space-toc-link" href="#0-%E5%85%B3%E4%BA%8E"><span class="space-toc-text">0 关于</span></a></li><li class="space-toc-item space-toc-level-2"><a class="space-toc-link" href="#1-%E5%85%A5%E9%97%A8"><span class="space-toc-text">1 入门</span></a></li><li class="space-toc-item space-toc-level-2"><a class="space-toc-link" href="#2-%E6%8C%87%E9%92%88"><span class="space-toc-text">2 指针</span></a></li><li class="space-toc-item space-toc-level-2"><a class="space-toc-link" href="#2-5-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%9F%E7%90%86"><span class="space-toc-text">2.5 字符串原理</span></a></li><li class="space-toc-item space-toc-level-2"><a class="space-toc-link" href="#3-%E5%B0%8F%E5%B7%A5%E5%85%B7"><span class="space-toc-text">3 小工具</span></a></li><li class="space-toc-item space-toc-level-2"><a class="space-toc-link" href="#4-%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E6%BA%90%E6%96%87%E4%BB%B6"><span class="space-toc-text">4 使用多个源文件</span></a></li><li class="space-toc-item space-toc-level-2"><a class="space-toc-link" href="#5-%E7%BB%93%E6%9E%84%E3%80%81%E8%81%94%E5%90%88%E4%B8%8E%E4%BD%8D%E5%AD%97%E6%AE%B5"><span class="space-toc-text">5 结构、联合与位字段</span></a></li><li class="space-toc-item space-toc-level-2"><a class="space-toc-link" href="#6-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%8A%A8%E6%80%81%E5%AD%98%E5%82%A8"><span class="space-toc-text">6 数据结构与动态存储</span></a></li><li class="space-toc-item space-toc-level-2"><a class="space-toc-link" href="#11-%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="space-toc-text">11 网络与套接字</span></a></li><li class="space-toc-item space-toc-level-2"><a class="space-toc-link" href="#%E5%8D%81%E5%A4%A7%E9%81%97%E6%BC%8F%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="space-toc-text">十大遗漏知识点</span></a></li></ol>
           </div>
        
      </div>
   </div>
    <!-- 评论 -->
    
  </div>
</article>
  </div>
</div>



<!-- 如果是home模式的话，不在首页就显示footer，如果不是home模式的话 所有都显示footer -->

  <div class="footer-outer animate__animated  animate__fadeInUp">
    <div class="footer-inner">
    <div class="footer-text">
    <p>Power by <a target="_blank" rel="noopener" href="http://hexo.io/">Hexo</a> Theme by <a target="_blank" rel="noopener" href="https://github.com/FuShaoLei/hexo-theme-white">White</a> Beloved y³</p>

    </div>
    <div class="footer-contact">
    <ul class="footer-ul">
        
        <li class="footer-li">
            <a href="https://github.com/louisiy" target="_blank">
                <i class="ri-github-line"></i>
            </a>
        </li>
        
        <li class="footer-li">
            <a href="mailto:louisiy@qq.com" target="_blank">
                <i class="ri-mail-line"></i>
            </a>
        </li>
        
    </ul>
    </div>
    </div>
</div>






<script src="/js/white.js"></script>



</body>
</html>
