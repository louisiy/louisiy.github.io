<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>来到Win11</title>
      <link href="/2023/08/Towin11/"/>
      <url>/2023/08/Towin11/</url>
      
        <content type="html"><![CDATA[<h2 id="奇幻之旅"><a href="#奇幻之旅" class="headerlink" title="奇幻之旅"></a>奇幻之旅</h2><p>最近把2020款的拯救者从win10升级到了win11，界面体验很新，但是还是有诸多不习惯的地方</p><h2 id="反人类的右键"><a href="#反人类的右键" class="headerlink" title="反人类的右键"></a>反人类的右键</h2><p>通过修改注册表，我们就可以回退到老版右键菜单</p><p>运行<code>regedit</code>，开启注册表编辑器，定位到<code>HKEY_CURRENT_USER\SOFTWARE\CLASSES\CLSID</code></p><p>右键点击<code>CLSID</code>键值，新建一个名为<code>&#123;86ca1aa0-34aa-4e8b-a509-50c905bae2a2&#125;</code>的项</p><p>右键点击新创建的项，新建一个名为<code>InprocServer32</code>的项，按下回车键保存</p><p>最后选择新创建的项，然后双击右侧窗格中的默认条目，什么内容都不需要输入，按下回车键</p><p>保存注册表后，重启<code>explorer.exe</code>，即可看到右键菜单恢复成旧样式了。</p><p>如果想要恢复成为Win11的设计，那么删掉<code>InprocServer32</code>的项就可以了。</p><p>圆角设计的老版本右键菜单还是蛮好看的</p><h2 id="消失的开始菜单磁贴"><a href="#消失的开始菜单磁贴" class="headerlink" title="消失的开始菜单磁贴"></a>消失的开始菜单磁贴</h2><p>安装了破解版本的startdock11，还原了win10风格的磁贴，观感和使用好了太多了</p><h2 id="别扭的显示放大比例"><a href="#别扭的显示放大比例" class="headerlink" title="别扭的显示放大比例"></a>别扭的显示放大比例</h2><p>125%虽然是推荐，但是感觉太大了</p><p>100%的大小很舒服，但是有点模糊，又蛮难受</p><h2 id="太宽的任务栏"><a href="#太宽的任务栏" class="headerlink" title="太宽的任务栏"></a>太宽的任务栏</h2><p>老规矩，进注册表</p><p><code>\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Advanced</code></p><p>右击空白处并新建一个TaskbarSi”的DWORD值（32）</p><p>修改其值为0（小）1（中）2（大）</p>]]></content>
      
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Note for Aspen</title>
      <link href="/2023/08/noteapsen/"/>
      <url>/2023/08/noteapsen/</url>
      
        <content type="html"><![CDATA[<h2 id="化工设计"><a href="#化工设计" class="headerlink" title="化工设计"></a>化工设计</h2><p>化工设计为设计一种流程，将原材料转化为需要的化工产品</p><ul><li>反应设计</li><li>分离混合物</li><li>换热网络</li><li>公用工程</li></ul><h3 id="反应器"><a href="#反应器" class="headerlink" title="反应器"></a>反应器</h3><p>用于实现液相单相反应过程和液液、气液、液固、气液固等多相反应过程</p><ul><li>固定床反应器<ul><li>反应器内装填颗粒状固体催化剂或固体反应物，形成一定高度的堆积床层，气体或液体物料通过颗粒间隙流过静止固定床层的同时，实现非均相反应过程</li></ul></li><li>流化床反应器<ul><li>气体在由固体物料或催化剂构成的沸腾床层内进行化学反应</li></ul></li><li>反应塔<ul><li>反应和精馏同时发生，适用于可逆反应</li></ul></li></ul><h3 id="分离设备"><a href="#分离设备" class="headerlink" title="分离设备"></a>分离设备</h3><p>分离混合物，以提纯需要的组分</p><ul><li>精馏塔<ul><li>塔式气液接触装置。利用混合物中各组分具有不同的挥发度，即在同一温度下各组分的蒸气压不同这一性质，使液相中的轻组分(低沸物)转移到气相中，而气相中的重组分(高沸物)转移到液相中，从而实现分离的目的</li></ul></li><li>分离器<ul><li>利用分子大小或性质的区别，穿过分离模进行分离</li></ul></li><li>膜分离<ul><li>利用相平衡等原理，分离气相和液相的混合物</li></ul></li></ul><h3 id="换热设备"><a href="#换热设备" class="headerlink" title="换热设备"></a>换热设备</h3><p>使热量从热流体传递到冷流体</p><ul><li>管壳式换热器<ul><li>冷流体和热流体在管程和壳程之间进行换热</li></ul></li><li>加热炉<ul><li>利用火焰燃烧辐射热给工艺介质加热</li></ul></li></ul><p>概念设计-&gt;中试设计-&gt;基础设计-&gt;工程设计</p><h2 id="Aspen相关"><a href="#Aspen相关" class="headerlink" title="Aspen相关"></a>Aspen相关</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul><li>物性环境(Property Environment) — 全面定义物性所需的所有步骤<ul><li>组分选择和特性描述</li><li>选择物性方法和数据库</li><li>收集实验物性数据，以检查或拟合您的模型</li><li>物性估计／结构绘制</li><li>物性分析</li><li>物性数据回归</li></ul></li><li>模拟环境(Simulation Environment) — 用来构建及运行模型<ul><li>构建及详细规定工艺流程</li><li>创建及运行交互分析（灵敏度／案例研究等）</li><li>根据流程或实验室数据调整模型</li><li>初步设备设计、尺寸估算及校核</li><li>相关成本估计（经济评估）</li></ul></li></ul><h3 id="构建环境"><a href="#构建环境" class="headerlink" title="构建环境"></a>构建环境</h3><ul><li>物性环境：<ul><li>指定流程中的化学组分<ul><li>Aspen Plus 数据库或用户定义</li></ul></li><li>指定热力学模型（物性方法），以体现流程中的物性组分及混合物<ul><li>内置模型或自定义模型</li></ul></li></ul></li><li>模拟环境：<ul><li>定义工艺流程：</li><li>单元操作和流股连接</li><li>以图形方式从模型选择窗口构建流程与模型</li><li>指定进料流股组分流量和条件</li><li>指定单元操作模型的操作条件及其他参数</li><li>可选操作：如果执行能量与成本分析，则指定工艺的公用工程及成本因素</li></ul></li></ul><h3 id="建立新的模拟"><a href="#建立新的模拟" class="headerlink" title="建立新的模拟"></a>建立新的模拟</h3><p>模型中将各行业的常用设置设为默认值</p><ul><li><p>单位制</p></li><li><p>生成报告的物流组成信息和物性</p></li><li><p>物流生成报告的格式</p></li><li><p>游离水的默认设定</p></li><li><p>物性方法</p></li><li><p>其它模拟相关的默认值</p></li></ul><h3 id="界面"><a href="#界面" class="headerlink" title="界面"></a>界面</h3><p>用户界面</p><ul><li>功能区启用相关功能</li><li>从模型选择窗口（Model Palette）构建工艺流程</li></ul><p>导航窗格</p><ul><li>用于导航到输入文件夹、表单及工作表</li><li>包含对象管理器（Object Managers），其可允许对不同的对象进行操作</li></ul><p>Next Button（下一步按钮）：检查当前表单是否已完成，并移至下一个需要输入的表单</p><h4 id="导航窗格"><a href="#导航窗格" class="headerlink" title="导航窗格"></a>导航窗格</h4><p>导航窗格是已定义的可用模拟输入、结果及对象的分层树结构视图；其被用于导航文件夹、表单及工作表</p><p>        <span class="lazyload-img-span">        <img              data-src="D:\Personal\inTHU\大一暑期小学期\2.png" >        </sapn>      </p>]]></content>
      
      
      
        <tags>
            
            <tag> Aspen </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Notes for SummerSchool Python</title>
      <link href="/2023/08/notePython/"/>
      <url>/2023/08/notePython/</url>
      
        <content type="html"><![CDATA[<h2 id="环境前提"><a href="#环境前提" class="headerlink" title="环境前提"></a>环境前提</h2><p>Anaconda是一个用于科学计算的Python发行版，支持Linux，Mac，Windows系统，提供了包管理与环境管理的功能，可以很方便地解决多版本python并存，切换以及各种第三方包安装问题</p><p>anaconda利用工具&#x2F;命令<code>conda</code>来进行package和environment的管理，并且已经包含了Python和相关的配套工具</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Anaconda是一个打包的集合，预装了conda，某个版本的python，很多package，科学计算工具等，称为一个发行版</p><p>conda是一个工具，也是一个可执行命令，核心功能是包管理和环境管理。包管理与pip的使用类似，环境管理则允许用户方便地安装不同版本的python并可以快速切换</p><p>Miniconda是一个简单包，只包含最基本的内容，python和conda，以及相关的必须依赖项</p><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><ul><li>交互式编程<ul><li>交互式编程不需要创建脚本文件，是通过Python解释器的交互模式来编写代码</li></ul></li><li>脚本式编程<ul><li>通过脚本参数调用解释器开始执行脚本，知道脚本执行完毕。当脚本执行完成后，解释器不再有效</li></ul></li></ul><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>英文字母、数字、下划线组成，不能以数字开头</p><p>区分大小写</p><p>以下划线开头的标识符是有特殊意义的</p><p>Python可以同一行显示多条语句，方法是用分号；分开，如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>);<span class="built_in">print</span>(<span class="string">&quot;Tsinghua&quot;</span>);</span><br><span class="line">hello</span><br><span class="line">Tsinghua</span><br></pre></td></tr></table></figure><p>保留字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> keyword</span><br><span class="line">keyword.kwlist</span><br></pre></td></tr></table></figure><p>查看当前系统的关键字</p><table><thead><tr><th>and</th><th>exec</th><th>not</th></tr></thead><tbody><tr><td>assert</td><td>finally</td><td>or</td></tr><tr><td>break</td><td>for</td><td>pass</td></tr><tr><td>class</td><td>from</td><td>print</td></tr><tr><td>continue</td><td>global</td><td>raise</td></tr><tr><td>def</td><td>if</td><td>return</td></tr><tr><td>del</td><td>import</td><td>try</td></tr><tr><td>elif</td><td>in</td><td>while</td></tr><tr><td>else</td><td>is</td><td>with</td></tr><tr><td>except</td><td>lambda</td><td>yield</td></tr></tbody></table><h3 id="行和缩进"><a href="#行和缩进" class="headerlink" title="行和缩进"></a>行和缩进</h3><p>用缩进来写模块</p><p>缩进的空白数量是可变的，但是所有代码快语句必须包含相同的缩进空白数量</p><p>Indentation Error: unindent does not match any outer indentation level</p><h3 id="引号和注释"><a href="#引号和注释" class="headerlink" title="引号和注释"></a>引号和注释</h3><p>可以用引号（’）、双引号( “ )、三引号( ‘’’ 或 “”” ) 来表示字符串，引号的开始与结束须是相同类型</p><p>单行注释采用 # 开头。多行注释使用三个单引号 ‘’’ 或三个双引号 “””</p><p>函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。空行与代码缩进不同，空行并不是Python语法的一部分</p><h3 id="print输出"><a href="#print输出" class="headerlink" title="print输出"></a>print输出</h3><p>print默认输出是换行的</p><p>可以在 print() 函数中添加 end&#x3D;”” 参数，这样就可以实现不换行效果</p><p>参数 end 默认值为 “\n”，即end&#x3D;”\n”，表示换行，给 end 赋值为空, 即end&#x3D;””，就不会换行了</p><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><p>变量赋值不需要类型声明。<br>每个变量在内存中创建，都包括变量的标识，名称和数据这些信息<br>每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建<br>等号 &#x3D; 用来给变量赋值<br>等号 &#x3D; 运算符左边是一个变量名，等号 &#x3D; 运算符右边是存储在变量中的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=b=c=<span class="number">1</span></span><br><span class="line">a,b,c=<span class="number">1</span>,<span class="number">2</span>,<span class="string">&quot;john&quot;</span></span><br></pre></td></tr></table></figure><p>五个标准数据类型</p><ul><li>Numbers（数字）</li><li>String（字符串）</li><li>List（列表）</li><li>Tuple（元组）</li><li>Dictionary（字典）</li></ul><h4 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h4><p>数字数据类型用于存储数值</p><p>他们是不可改变的数据类型，这意味着改变数字数据类型会分配一个新的对象。</p><p>当你指定一个值时，Number 对象就会被创建</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var1 = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>可以使用del语句删除一些对象的引用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> var</span><br></pre></td></tr></table></figure><p>Python支持四种不同的数字类型：</p><ul><li>int（有符号整型）</li><li>long（长整型， Python3.X 版本中 long 类型被移除，使用 int 替代）</li><li>float（浮点型）</li><li>complex（复数）<ul><li>复数由实数部分和虚数部分构成，可以用 a+bj，或者 complex(a,b) 表示， 复数的实部 a 和虚部 b 都是浮点型</li></ul></li></ul><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>字符串或串(String)是由数字、字母、下划线组成的一串字符，它是编程语言中表示文本的数据类型</p><p>Python的字串列表有2种取值顺序:</p><ul><li>从左到右索引默认0开始的，最大范围是字符串长度少1</li><li>从右到左索引默认-1开始的，最大范围是字符串开头</li></ul><p>        <span class="lazyload-img-span">        <img              data-src="https://cdn.jsdelivr.net/gh/louisiy/ImageStorage/img/1.png" >        </sapn>      </p><p>实现从字符串中获取一段子字符串的话，可以使用 [头下标:尾下标] 来截取相应的字符串，其中下标是从 0 开始算起，可以是正数或负数，下标可以为空表示取到头或尾。[头下标:尾下标] 获取的子字符串包含头下标的字符，但不包含尾下标的字符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&#x27;abcdef&#x27;</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">1</span>:<span class="number">5</span>] </span><br><span class="line"><span class="string">&#x27;bcde&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;Hello World!’</span></span><br><span class="line"><span class="string">print(str) # 输出完整字符串</span></span><br><span class="line"><span class="string">print(str[0]) # 输出字符串中的第一个字符</span></span><br><span class="line"><span class="string">print(str[2:5]) # 输出字符串中第三个至第六个之间的字符串</span></span><br><span class="line"><span class="string">print(str[2:]) # 输出从第三个字符开始的字符串</span></span><br><span class="line"><span class="string">print(str * 2) # 输出字符串两次</span></span><br><span class="line"><span class="string">print(str + &quot;TEST&quot;) # 输出连接的字符串</span></span><br></pre></td></tr></table></figure><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>List（列表） 是 Python 中使用最高频的数据类型</p><p>列表可以完成大多数集合类的数据结构实现。它支持字符，数字，字符串甚至可以包含列表（即嵌套）<br>列表用 <code>[]</code> 标识，是 Python 最通用的复合数据类型</p><p>列表中值的切割也可以用到变量 [头下标:尾下标] ，就可以截取相应的列表，从左到右索引默认 0 开始，从右到左索引默认 -1 开始，下标可以为空表示取到头或尾</p><p>列表截取可以接收第三个参数，参数作用是截取的步长，以下实例在索引 1 到索引 4 的位置并设置<br>步长为 2（间隔一个位置）来截取字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = [<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;o&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters[<span class="number">1</span>:<span class="number">4</span>:<span class="number">2</span>]</span><br><span class="line">[<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]</span><br></pre></td></tr></table></figure><h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><p>元组是另一个数据类型，类似于 List（列表）</p><p>元组用 () 标识。内部元素用逗号隔开。但是元组不能二次赋值，相当于只读列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tuple</span> = (<span class="string">&#x27;tsinghua&#x27;</span>, <span class="number">786</span>, <span class="number">2.23</span>, <span class="string">&#x27;john&#x27;</span>, <span class="number">70.2</span>)</span><br><span class="line">tinytuple = (<span class="number">123</span>, <span class="string">&#x27;john&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">tuple</span> = ( <span class="string">&#x27;tsinghua&#x27;</span>, <span class="number">786</span> , <span class="number">2.23</span>, <span class="string">&#x27;john&#x27;</span>, <span class="number">70.2</span> )</span><br><span class="line"><span class="built_in">list</span> = [ <span class="string">&#x27;tsinghua&#x27;</span>, <span class="number">786</span> , <span class="number">2.23</span>, <span class="string">&#x27;john&#x27;</span>, <span class="number">70.2</span> ]</span><br><span class="line"><span class="built_in">tuple</span>[<span class="number">2</span>] = <span class="number">1000</span> <span class="comment"># 元组中是非法应用</span></span><br><span class="line"><span class="built_in">list</span>[<span class="number">2</span>] = <span class="number">1000</span> <span class="comment"># 列表中是合法应用</span></span><br></pre></td></tr></table></figure><h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><p>字典(dictionary)是除列表以外python之中最灵活的内置数据结构类型。列表是有序的对象集合，<br>字典是无序的对象集合</p><p>两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取</p><p>字典用”{ }”标识。字典由索引(key)和它对应的值value组成</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dict</span> = &#123;&#125;</span><br><span class="line"><span class="built_in">dict</span>[<span class="string">&#x27;one&#x27;</span>] = <span class="string">&quot;This is one&quot;</span></span><br><span class="line"><span class="built_in">dict</span>[<span class="number">2</span>] = <span class="string">&quot;This is two&quot;</span></span><br><span class="line">tinydict = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tsinghua&#x27;</span>, <span class="string">&#x27;code&#x27;</span>: <span class="number">6734</span>, <span class="string">&#x27;dept&#x27;</span>: <span class="string">&#x27;sales&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">dict</span>[<span class="string">&#x27;one’] # 输出键为&#x27;</span>one<span class="string">&#x27; 的值</span></span><br><span class="line"><span class="string">     </span></span><br><span class="line"><span class="string">dict[2] # 输出键为 2 的值</span></span><br><span class="line"><span class="string">tinydict # 输出完整的字典</span></span><br><span class="line"><span class="string">tinydict.keys() # 输出所有键</span></span><br><span class="line"><span class="string">tinydict.values() # 输出所有值</span></span><br></pre></td></tr></table></figure><h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>int(x [,base])</td><td>将x转换为一个整数</td></tr><tr><td>long(x [,base] )</td><td>将x转换为一个长整数</td></tr><tr><td>float(x)</td><td>将x转换到一个浮点数</td></tr><tr><td>complex(real [,imag])</td><td>创建一个复数</td></tr><tr><td>str(x)</td><td>将对象 x 转换为字符串</td></tr><tr><td>&gt;repr(x)</td><td>将对象 x 转换为表达式字符串</td></tr><tr><td>eval(str)</td><td>用来计算在字符串中的有效Python表达式,并返回一个对象</td></tr><tr><td>tuple(s)</td><td>将序列 s 转换为一个元组</td></tr><tr><td>list(s)</td><td>将序列 s 转换为一个列表</td></tr><tr><td>set(s)</td><td>转换为可变集合</td></tr><tr><td>dict(d)</td><td>创建一个字典。d 必须是一个序列 (key,value)元组。</td></tr><tr><td>frozenset(s)</td><td>转换为不可变集合</td></tr><tr><td>chr(x)</td><td>将一个整数转换为一个字符</td></tr><tr><td>unichr(x)</td><td>将一个整数转换为Unicode字符</td></tr><tr><td>ord(x)</td><td>将一个字符转换为它的整数值</td></tr><tr><td>hex(x)</td><td>将一个整数转换为一个十六进制字符串</td></tr><tr><td>oct(x)</td><td>将一个整数转换为一个八进制字符串</td></tr></tbody></table><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="赋值、比较、赋值运算符"><a href="#赋值、比较、赋值运算符" class="headerlink" title="赋值、比较、赋值运算符"></a>赋值、比较、赋值运算符</h3><p>a &#x3D; 10, b &#x3D; 20</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>+</td><td>加 - 两个对象相加</td><td>a + b 输出结果 30</td></tr><tr><td>-</td><td>减 - 得到负数或是一个数减去另一个数</td><td>a - b 输出结果 -10</td></tr><tr><td>*</td><td>乘 - 两个数相乘或是返回一个被重复若干次的字符串</td><td>a * b 输出结果 200</td></tr><tr><td>&#x2F;</td><td>除 - x除以y</td><td>b &#x2F; a 输出结果 2</td></tr><tr><td>%</td><td>取模 - 返回除法的余数</td><td>b % a 输出结果 0</td></tr><tr><td>**</td><td>幂 - 返回x的y次幂</td><td>a**b 为10的20次方， 输出结果100000000000000000000</td></tr><tr><td>&#x2F;&#x2F;</td><td>取整除 - 返回商的整数部分（向下取整）</td><td>&gt;&gt;&gt; 9&#x2F;&#x2F;2 4 &gt;&gt;&gt; -9&#x2F;&#x2F;2 -5</td></tr><tr><td>&#x3D;&#x3D;</td><td>等于 - 比较对象是否相等</td><td>(a &#x3D;&#x3D; b) 返回 False</td></tr><tr><td>!&#x3D;</td><td>不等于 - 比较两个对象是否不相等</td><td>(a !&#x3D; b) 返回 True</td></tr><tr><td>&lt;&gt;</td><td>不等于 - 比较两个对象是否不相等。<strong>python3 已废弃</strong></td><td>(a &lt;&gt; b) 返回 True。这个运算符类似 !&#x3D;</td></tr><tr><td>&gt;</td><td>大于 - 返回x是否大于y</td><td>(a &gt; b) 返回 False</td></tr><tr><td>&lt;</td><td>小于 - 返回x是否小于y</td><td>(a &lt; b) 返回 True</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于 - 返回x是否大于等于y</td><td>(a &gt;&#x3D; b) 返回 False</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于 - 返回x是否小于等于y</td><td>(a &lt;&#x3D; b) 返回 True</td></tr><tr><td>&#x3D;</td><td>简单的赋值运算符</td><td>c &#x3D; a + b 将 a + b 的运算结果赋值为 c</td></tr><tr><td>+&#x3D;</td><td>加法赋值运算符</td><td>c +&#x3D; a 等效于 c &#x3D; c + a</td></tr><tr><td>-&#x3D;</td><td>减法赋值运算符</td><td>c -&#x3D; a 等效于 c &#x3D; c - a</td></tr><tr><td>*&#x3D;</td><td>乘法赋值运算符</td><td>c *&#x3D; a 等效于 c &#x3D; c * a</td></tr><tr><td>&#x2F;&#x3D;</td><td>除法赋值运算符</td><td>c &#x2F;&#x3D; a 等效于 c &#x3D; c &#x2F; a</td></tr><tr><td>%&#x3D;</td><td>取模赋值运算符</td><td>c %&#x3D; a 等效于 c &#x3D; c % a</td></tr><tr><td>**&#x3D;</td><td>幂赋值运算符</td><td>c **&#x3D; a 等效于 c &#x3D; c ** a</td></tr><tr><td>&#x2F;&#x2F;&#x3D;</td><td>取整除赋值运算符</td><td>c &#x2F;&#x2F;&#x3D; a 等效于 c &#x3D; c &#x2F;&#x2F; a</td></tr></tbody></table><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><ul><li>&amp;<ul><li>按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0</li></ul></li><li>|<ul><li>按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1</li></ul></li><li>^<ul><li>按位异或运算符：当两对应的二进位相异时，结果为1</li></ul></li><li>~<ul><li>按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1 。~x 类似于 -x-1</li></ul></li><li>&lt;&lt;<ul><li>左移动运算符：运算数的各二进位全部左移若干位，由 &lt;&lt; 右边的数字指定了移动的位数，高位丢弃，低位补0</li><li>60 &lt;&lt; 2为240</li></ul></li><li>&gt;&gt;<ul><li>右移动运算符：把”&gt;&gt;”左边的运算数的各二进位全部右移若干位，&gt;&gt; 右边的数字指定了移动的位数</li></ul></li></ul><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>a &#x3D; 10, b &#x3D; 20</p><table><thead><tr><th>运算符</th><th>逻辑表达式</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>and</td><td>x and y</td><td>布尔”与” - 如果 x 为 False，x and y 返回False，否则它返回 y 的计算值</td><td>(a and b) 返回 20</td></tr><tr><td>or</td><td>x or y</td><td>布尔”或” - 如果 x 是非 0，它返回 x 的计算值，否则它返回 y 的计算值</td><td>(a or b) 返回 10</td></tr><tr><td>not</td><td>not x</td><td>布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True</td><td>not(a and b) 返回 False</td></tr></tbody></table><h3 id="成员运算符"><a href="#成员运算符" class="headerlink" title="成员运算符"></a>成员运算符</h3><ul><li>in<ul><li>如果在指定的序列中找到值返回 True，否则返回 False</li></ul></li><li>not in<ul><li>如果在指定的序列中没有找到值返回 True，否则返回 False</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">20</span></span><br><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ];</span><br><span class="line"><span class="keyword">if</span> ( a <span class="keyword">in</span> <span class="built_in">list</span> ):</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;1 - 变量 a 在给定的列表中 list 中&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;1 - 变量 a 不在给定的列表中 list 中&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> (b <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">list</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;2 - 变量 b 不在给定的列表中 list 中&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;2 - 变量 b 在给定的列表中 list 中&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="身份运算符"><a href="#身份运算符" class="headerlink" title="身份运算符"></a>身份运算符</h3><ul><li>is<ul><li>is 是判断两个标识符是不是引用自一个对象</li></ul></li><li>is not<ul><li>is not 是判断两个标识符是不是引用自不同对象</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b <span class="keyword">is</span> a</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b == a</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a[:]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b <span class="keyword">is</span> a</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b == a</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><blockquote><p>is 与 &#x3D;&#x3D; 区别：<br>is 用于判断两个变量引用对象是否为同一个(同一块内存空间)， &#x3D;&#x3D; 用于判断引用变量的值是否相等</p></blockquote><h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>**</td><td>指数 (最高优先级)</td></tr><tr><td>~+-</td><td>按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)</td></tr><tr><td>* &#x2F; % &#x2F;&#x2F;</td><td>乘，除，取模和取整除</td></tr><tr><td>+ -</td><td>加法减法</td></tr><tr><td>&gt;&gt; &lt;&lt;</td><td>右移，左移运算符</td></tr><tr><td>&amp;</td><td>位 ‘AND’</td></tr><tr><td>^ |</td><td>位运算符</td></tr><tr><td>&lt;&#x3D; &lt; &gt; &gt;&#x3D;</td><td>比较运算符</td></tr><tr><td>&lt;&gt; &#x3D;&#x3D; !&#x3D;</td><td>等于运算符</td></tr><tr><td>&#x3D; %&#x3D; &#x2F;&#x3D; &#x2F;&#x2F;&#x3D; -&#x3D; +&#x3D; *&#x3D; **&#x3D;</td><td>赋值运算符</td></tr><tr><td>is is not</td><td>身份运算符</td></tr><tr><td>in not in</td><td>成员运算符</td></tr><tr><td>not and or</td><td>逻辑运算符</td></tr></tbody></table><h2 id="程序控制结构"><a href="#程序控制结构" class="headerlink" title="程序控制结构"></a>程序控制结构</h2><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 判断条件：</span><br><span class="line">执行语句……</span><br><span class="line"><span class="keyword">else</span>：</span><br><span class="line">执行语句……</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 判断条件<span class="number">1</span>:</span><br><span class="line">执行语句<span class="number">1</span>……</span><br><span class="line"><span class="keyword">elif</span> 判断条件<span class="number">2</span>:</span><br><span class="line">执行语句<span class="number">2</span>……</span><br><span class="line"><span class="keyword">elif</span> 判断条件<span class="number">3</span>:</span><br><span class="line">执行语句<span class="number">3</span>……</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">执行语句<span class="number">4</span>……</span><br></pre></td></tr></table></figure><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><p>while、for</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> []:</span><br><span class="line">    []</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>[]:</span><br><span class="line">    []</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> [] <span class="keyword">in</span> []:<span class="comment">#for iterating_var in sequence:statements(s)</span></span><br><span class="line">    []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> [] <span class="keyword">in</span> []:</span><br><span class="line">    []</span><br><span class="line"><span class="keyword">else</span>:</span><br></pre></td></tr></table></figure><p>else 中的语句会在循环正常执行完</p><ul><li><p>break</p><ul><li>在语句块执行中终止循环，并且跳出整个循环</li></ul></li><li><p>continue</p><ul><li>在语句块执行过程中终止当前循环，跳出该次循环</li></ul></li><li><p>pass</p><ul><li>空语句，为了保持程序结构的完整性</li></ul></li></ul><h3 id="range"><a href="#range" class="headerlink" title="range()"></a>range()</h3><p>如果你需要遍历数字序列，可以使用内置range()函数。它会生成数列，例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>): <span class="built_in">print</span>(i)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>, <span class="number">3</span>) : <span class="built_in">print</span>(i)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(-<span class="number">10</span>, -<span class="number">100</span>, -<span class="number">30</span>) : <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><p>可以结合range()和len()函数以遍历一个序列的索引,如下所示:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Baidu&#x27;</span>, <span class="string">&#x27;Bing&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>, <span class="string">&#x27;QQ&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a)):</span><br><span class="line"><span class="built_in">print</span>(i, a[i])</span><br></pre></td></tr></table></figure><p>还可以使用range()函数来创建一个列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">5</span>))</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>定义一个函数：可定义一个由自己想要功能的函数，以下是简单的规则：</p><ul><li>函数代码块以 def 关键词开头，后接函数标识符名称和圆括号()</li><li>任何传入参数和自变量必须放在圆括号中间。圆括号之间可以用于定义参数</li><li>函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明</li><li>函数内容以冒号起始，并且缩进</li><li>return [表达式] 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None</li></ul><p>        <span class="lazyload-img-span">        <img              data-src="https://cdn.jsdelivr.net/gh/louisiy/ImageStorage/img/3.png" >        </sapn>      </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">functionname</span>(<span class="params"> parameters </span>):</span><br><span class="line">function_suite</span><br><span class="line"><span class="keyword">return</span> [expression]</span><br></pre></td></tr></table></figure><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>Python 中，类型属于对象，变量没有类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">a = <span class="string">&quot;Tsinghua&quot;</span></span><br></pre></td></tr></table></figure><p>[1,2,3] 是 List 类型，“Tsinghua” 是 String 类型，而变量 a 是没有类型，它仅仅是一个对象的引用（一个指针），可以是 List 类型对象，也可以指向String 类型对象</p><p>在 Python 中，strings, tuples, 和 numbers是不可更改的对象，而 list, dict 等则是可以修改的对象</p><ul><li>不可变类型：变量赋值 a&#x3D;5 后再赋值 a&#x3D;10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变a的值，相当于新生成了a</li><li>可变类型：变量赋值 la&#x3D;[1,2,3,4] 后再赋值 la[2]&#x3D;5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了</li></ul><h3 id="参数类型"><a href="#参数类型" class="headerlink" title="参数类型"></a>参数类型</h3><p>以下是调用函数时可使用的正式参数类型：</p><ul><li><p>必备参数</p><ul><li>必备参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样</li></ul></li><li><p>关键字参数</p><ul><li><p>关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值</p></li><li><p>&#96;&#96;&#96;python<br>def printinfo(name, age):<br>“打印任何传入的字符串”<br>print(“Name: “, name)<br>print(“Age “, age)<br>return</p><h1 id="调用printinfo函数"><a href="#调用printinfo函数" class="headerlink" title="调用printinfo函数"></a>调用printinfo函数</h1><p>printinfo(age&#x3D;50, name&#x3D;”miki”)</p></li></ul></li><li><p>默认参数</p><ul><li>调用函数时，默认参数的值如果没有传入，则被认为是默认值</li></ul></li><li><p>不定长参数 </p><ul><li>需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述参数不同，声明时不会命名</li></ul></li></ul><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>使用 lambda 来创建匿名函数<br>所谓匿名，意即不再使用 def 语句这样标准的形式定义一个函数</p><p>lambda 只是一个表达式，函数体比 def 简单很多。主体是一个表达式，而不是一个代码块。仅仅能在 lambda 表达式中封装有限的逻辑进去。lambda 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> [arg1 [,arg2,.....argn]]:expression</span><br><span class="line"></span><br><span class="line">实例 (设置参数 a 加上 <span class="number">10</span>)</span><br><span class="line">x = <span class="keyword">lambda</span> a : a + <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(x(<span class="number">5</span>))</span><br></pre></td></tr></table></figure><p>可将匿名函数封装在一个函数内，这样可以使用同样的代码来创建多个匿名函数。</p><p>以下实例将匿名函数封装在 myfunc 函数中，通过传入不同的参数来创建不同的匿名函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">myfunc</span>(<span class="params">n</span>):</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">lambda</span> a: a * n</span><br><span class="line">mydoubler = myfunc(<span class="number">2</span>)</span><br><span class="line">mytripler = myfunc(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(mydoubler(<span class="number">11</span>))</span><br><span class="line"><span class="built_in">print</span>(mytripler(<span class="number">11</span>))</span><br></pre></td></tr></table></figure><p>return [表达式] 语句用于退出函数，选择性地向调用方返回一个表达式。不带参数值的 return 语句返回 None</p><h2 id="PYTHON面向对象"><a href="#PYTHON面向对象" class="headerlink" title="PYTHON面向对象"></a>PYTHON面向对象</h2><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><ul><li>类(Class)<ul><li>用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例</li></ul></li><li>方法<ul><li>类中定义的函数</li></ul></li><li>类变量<ul><li>类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用</li></ul></li><li>数据成员<ul><li>类变量或者实例变量用于处理类及其实例对象的相关的数据</li></ul></li><li>方法重写<ul><li>如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写</li></ul></li><li>局部变量<ul><li>定义在方法中的变量，只作用于当前实例的类</li></ul></li><li>实例变量<ul><li>在类的声明中，属性是用变量来表示的，这种变量就称为实例变量，实例变量就是一个用 self修饰的变量</li></ul></li><li>继承<ul><li>即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待</li></ul></li><li>实例化<ul><li>创建一个类的实例，类的具体对象</li></ul></li><li>对象<ul><li>通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法</li></ul></li></ul><h3 id="类对象"><a href="#类对象" class="headerlink" title="类对象"></a>类对象</h3><p>类对象支持两种操作：属性引用和实例化</p><p>属性引用使用和 Python 中所有的属性引用一样的标准语法：obj.name</p><p>类对象创建后，类命名空间中所有的命名都是有效属性名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span></span><br><span class="line">&lt;statement-<span class="number">1</span>&gt;</span><br><span class="line">    &lt;statement-N&gt;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line"><span class="string">&quot;&quot;&quot;一个简单的类实例&quot;&quot;&quot;</span></span><br><span class="line">i = <span class="number">12345</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"><span class="comment"># 实例化类</span></span><br><span class="line">x = MyClass()</span><br><span class="line"><span class="comment"># 访问类的属性和方法</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;MyClass 类的属性 i 为：&quot;</span>, x.i)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;MyClass 类的方法 f 输出为：&quot;</span>, x.f())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># MyClass 类的属性 i 为： 12345</span></span><br><span class="line"><span class="comment"># MyClass 类的方法 f 输出为： hello world</span></span><br></pre></td></tr></table></figure><p>类有一个名为 _<em>init</em>_() 的特殊方法（构造方法），该方法在类实例化时会自动调用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">self.data = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">people</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age</span>):</span><br><span class="line">self.name=name</span><br><span class="line">self.age=age</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> ‘这个人的名字是%s,已经有%d岁了！’%(self.name,self.age)</span><br><span class="line"></span><br><span class="line">a = people(“孙悟空<span class="string">&quot;,999)</span></span><br><span class="line"><span class="string">print(a)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">           </span></span><br><span class="line"><span class="string">class Complex:</span></span><br><span class="line"><span class="string">def __init__(self, realpart, imagpart):</span></span><br><span class="line"><span class="string">self.r = realpart</span></span><br><span class="line"><span class="string">self.i = imagpart</span></span><br><span class="line"><span class="string">x = Complex(3.0, -4.5)</span></span><br><span class="line"><span class="string">print(x.r, x.i)           </span></span><br></pre></td></tr></table></figure><p>类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的第一个参数名称, 按照惯例它的名称是 self</p><p>self代表的是类的实例，代表当前对象的地址，而self.class则指向类</p><h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><p>子类（派生类 DerivedClassName）会继承父类（基类 BaseClassName）的属性和方法。</p><p>BaseClassName（实例中的基类名）必须与派生类定义在一个作用域内</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># !/usr/bin/python3</span></span><br><span class="line"><span class="comment"># 类定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">people</span>:</span><br><span class="line"><span class="comment"># 定义基本属性</span></span><br><span class="line">name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">age = <span class="number">0</span></span><br><span class="line"><span class="comment"># 定义私有属性,私有属性在类外部无法直接进行访问</span></span><br><span class="line">__weight = <span class="number">0</span></span><br><span class="line"><span class="comment"># 定义构造方法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n, a, w</span>):</span><br><span class="line">self.name = n</span><br><span class="line">self.age = a</span><br><span class="line">self.__weight = w</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%s 说: 我 %d 岁。&quot;</span> % (self.name, self.age))</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 单继承示例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>(<span class="title class_ inherited__">people</span>):</span><br><span class="line">grade = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n, a, w, g</span>):</span><br><span class="line"><span class="comment"># 调用父类的构函</span></span><br><span class="line">people.__init__(self, n, a, w)</span><br><span class="line">self.grade = g</span><br><span class="line"><span class="comment"># 覆写父类的方法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;</span> %(self.name, self.age, self.grade))</span><br><span class="line"></span><br><span class="line">s = student(<span class="string">&#x27;ken&#x27;</span>, <span class="number">10</span>, <span class="number">60</span>, <span class="number">3</span>)</span><br><span class="line">s.speak()</span><br></pre></td></tr></table></figure><h3 id="类的属性与方法"><a href="#类的属性与方法" class="headerlink" title="类的属性与方法"></a>类的属性与方法</h3><h4 id="类的私有属性"><a href="#类的私有属性" class="headerlink" title="类的私有属性"></a>类的私有属性</h4><p>__private_attrs：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 self.__private_attrs</p><h4 id="类的私有方法"><a href="#类的私有方法" class="headerlink" title="类的私有方法"></a>类的私有方法</h4><p>__init__ : 构造函数，在生成对象时调用<br>__del__ : 析构函数，释放对象时使用<br>__repr__ : 打印，转换<br>__setitem__ : 按照索引赋值<br>__getitem__: 按照索引获取值<br>__len__: 获得长度<br>__cmp__: 比较运算<br>__call__: 函数调用<br>__add__: 加运算<br>__sub__: 减运算<br>__mul__: 乘运算<br>__truediv__: 除运算<br>__mod__: 求余运算<br>__pow__: 乘方</p><h4 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, a, b</span>):</span><br><span class="line">self.a = a</span><br><span class="line">self.b = b</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;Vector (%d, %d)&#x27;</span> % (self.a, self.b)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other</span>):</span><br><span class="line"><span class="keyword">return</span> Vector(self.a + other.a, self.b + other.b)</span><br><span class="line"></span><br><span class="line">v1 = Vector(<span class="number">2</span>, <span class="number">10</span>)</span><br><span class="line">v2 = Vector(<span class="number">5</span>, -<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(v1 + v2)</span><br></pre></td></tr></table></figure><h2 id="W1-补充"><a href="#W1-补充" class="headerlink" title="W1 补充"></a>W1 补充</h2><h3 id="随机数生成"><a href="#随机数生成" class="headerlink" title="随机数生成"></a>随机数生成</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">random.randint(a,b)</span><br><span class="line"><span class="comment">#函数返回数字 N ，N 为 a 到 b 之间的数字（a &lt;= N &lt;= b），包含 a 和 b</span></span><br></pre></td></tr></table></figure><h3 id="列表头尾元素对调"><a href="#列表头尾元素对调" class="headerlink" title="列表头尾元素对调"></a>列表头尾元素对调</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">swapList</span>(<span class="params">newList</span>):</span><br><span class="line">    newList[<span class="number">0</span>], newList[-<span class="number">1</span>] = newList[-<span class="number">1</span>], newList[<span class="number">0</span>] <span class="comment">#同时赋值，分别用原值</span></span><br><span class="line">    <span class="keyword">return</span> newList</span><br><span class="line"></span><br><span class="line">newList = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(swapList(newList))</span><br></pre></td></tr></table></figure><h3 id="日历-日期"><a href="#日历-日期" class="headerlink" title="日历\日期"></a>日历\日期</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 引入日历模块</span></span><br><span class="line"><span class="keyword">import</span> calendar </span><br><span class="line"><span class="comment"># 输入指定年月 </span></span><br><span class="line">yy = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;输入年份: &quot;</span>)) </span><br><span class="line">mm = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;输入月份: &quot;</span>)) </span><br><span class="line"><span class="comment"># 显示日历 print(calendar.month(yy,mm))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> datetime </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getYesterday</span>(): </span><br><span class="line">yesterday = datetime.date.today() + datetime.timedelta(-<span class="number">1</span>) </span><br><span class="line"><span class="keyword">return</span> yesterday </span><br><span class="line"><span class="comment"># 输出 </span></span><br><span class="line"><span class="built_in">print</span>(getYesterday()) </span><br></pre></td></tr></table></figure><h3 id="秒表"><a href="#秒表" class="headerlink" title="秒表"></a>秒表</h3><p>主要是用了try-except的组合</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;按下回车开始计时，按下 Ctrl + C 停止计时&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>: </span><br><span class="line"><span class="built_in">input</span>(<span class="string">&quot;&quot;</span>) </span><br><span class="line">starttime = time.time() </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;开始&#x27;</span>) </span><br><span class="line"><span class="keyword">try</span>: </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>: </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;计时: &#x27;</span>, <span class="built_in">round</span>(time.time() - starttime, <span class="number">0</span>), <span class="string">&#x27;秒&#x27;</span>, end=<span class="string">&quot;\r&quot;</span>) </span><br><span class="line">time.sleep(<span class="number">1</span>) </span><br><span class="line"><span class="keyword">except</span> KeyboardInterrupt: </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;结束&#x27;</span>) </span><br><span class="line">endtime = time.time() </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;总共的时间为:&#x27;</span>, <span class="built_in">round</span>(endtime - starttime, <span class="number">2</span>), <span class="string">&#x27;secs&#x27;</span>) </span><br><span class="line"><span class="keyword">break</span></span><br></pre></td></tr></table></figure><h2 id="科学计算"><a href="#科学计算" class="headerlink" title="科学计算"></a>科学计算</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p><strong>NumPy</strong> (Numerical Python) 是 Python 语言的一个扩展程序库，支持大量的维度数组与<br>矩阵运算，此外也针对数组运算提供大量的数学函数库</p><p>NumPy 通常与 SciPy（Scientific Python）和 Matplotlib（绘图库）一起使用， 这种组合<br>广泛用于替代 Matlab，是一个强大的科学计算环境，有助于我们通过 Python 学习数据科<br>学或者机器学习</p><p><strong>SciPy</strong> 是一个开源的 Python 算法库和数学工具包。SciPy 包含的模块有最优化、线性代数、<br>积分、插值、特殊函数、快速傅里叶变换、信号处理和图像处理、常微分方程求解和其他科<br>学与工程中常用的计算</p><p><strong>Matplotlib</strong> 是 Python 编程语言及其数值数学扩展包 NumPy 的可视化操作界面。它为利<br>用通用的图形用户界面工具包，如 Tkinter, wxPython, Qt 或 GTK+ 向应用程序嵌入式绘图<br>提供了应用程序接口（API）</p><h3 id="NUMPY"><a href="#NUMPY" class="headerlink" title="NUMPY"></a>NUMPY</h3><p><a href="https://www.numpy.org.cn/">https://www.numpy.org.cn/</a></p><p>NumPy 最重要的一个特点是其 N 维数组对象 ndarray，它是一系列同类型数据的集合，以 0 下标为开始进行集合中元素的索引</p><p>ndarray 对象是用于存放同类型元素的多维数组。ndarray 中的每个元素在内存中都有相同存储大小的区域。ndarray 内部由以下内容组成：</p><ul><li>一个指向数据（内存或内存映射文件中的一块数据）的指针</li><li>数据类型或 dtype，描述在数组中的固定大小值的格子</li><li>一个表示数组形状（shape）的元组，表示各维度大小的元组 </li><li>一个跨度元组（stride），其中的整数指的是为了前进到当前维度下一个元素需要”跨过”的字节数</li></ul><p>ndarray 的内部结构: </p><p>        <span class="lazyload-img-span">        <img              data-src="https://cdn.jsdelivr.net/gh/louisiy/ImageStorage/img/4.png" >        </sapn>      </p><h4 id="数组类"><a href="#数组类" class="headerlink" title="数组类"></a>数组类</h4><p>NumPy的数组类被调用ndarray。它也被别名所知 array。请注意，numpy.array这与标准Python库类不同array.array，后者只处理一维数组并提供较少的功能。ndarray对象更重要的属性是：</p><ul><li>ndarray.ndim - 数组的轴（维度）的个数。在Python世界中，维度的数量被称为rank</li><li>ndarray.shape - 数组的维度。这是一个整数的元组，表示每个维度中数组的大小。对于有 n 行和 m 列的矩阵，shape 将是 (n,m)。因此，shape 元组的长度就是rank或维度的个数 ndim</li><li>ndarray.size - 数组元素的总数。这等于 shape 的元素的乘积</li><li>ndarray.dtype - 一个描述数组中元素类型的对象。可以使用标准的Python类型创建或指定dtype。另外NumPy提供它自己的类型。例如numpy.int32、numpy.int16和numpy.float64</li><li>ndarray.itemsize - 数组中每个元素的字节大小。例如，元素为 float64 类型的数组的 itemsize 为8（&#x3D;64&#x2F;8），而 complex32 类型的数组的 itemsize 为4（&#x3D;32&#x2F;8）。它等于 ndarray.dtype.itemsize</li></ul><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.arry(<span class="built_in">object</span>, dtype = <span class="literal">None</span>, copy = <span class="literal">True</span>, order = <span class="literal">None</span>, subok = <span class="literal">False</span>, ndmin = <span class="number">0</span>)</span><br></pre></td></tr></table></figure><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>object</td><td>数组或嵌套的数列</td></tr><tr><td>dtype</td><td>数组元素的数据类型，可选</td></tr><tr><td>copy</td><td>对象是否需要复制，可选</td></tr><tr><td>order</td><td>创建数组的样式，C为行方向，F为列方向，A为任意方向（默认）</td></tr><tr><td>subok</td><td>默认返回一个与基类类型一致的数组</td></tr><tr><td>ndmin</td><td>指定生成数组的最小维度</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">b = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br></pre></td></tr></table></figure><p>可以使用array函数从常规Python列表或元组中创建数组。得到的数组的类型是从Python列表中元素的类型推导出来的</p><p>array 还可以将序列的序列转换成二维数组、三维数组等，也可以在创建时显式指定数组的类型</p><p>通常，数组的元素最初是未知的，但它的大小是已知的。因此，NumPy提供了几个函数来创建具有初始占位符内容的数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#生成3行4列零矩阵</span></span><br><span class="line">np.zero((<span class="number">3</span>,<span class="number">4</span>)) </span><br><span class="line"><span class="comment">#生成3维元素全为1的矩阵</span></span><br><span class="line">np.ones((<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>),dtype = np.int16) </span><br><span class="line"><span class="comment">#初始内容是随机的，取决于内存的状态。默认情况下，创建的数组的dtype是 float64 类型的</span></span><br><span class="line">np.empty((<span class="number">2</span>,<span class="number">3</span>)) </span><br></pre></td></tr></table></figure><p>为了创建数字组成的数组，NumPy提供了一个类似于range的函数，该函数返回数组而不是列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.arange(<span class="number">10</span>,<span class="number">30</span>,<span class="number">5</span>)</span><br><span class="line">array([<span class="number">10</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">25</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.arange(<span class="number">0</span>,<span class="number">2</span>,<span class="number">0.3</span>)</span><br><span class="line">array([<span class="number">0.</span> ,<span class="number">0.3</span> ,<span class="number">0.6</span> ,<span class="number">0.9</span> , <span class="number">1.2</span>, <span class="number">1.5</span>, <span class="number">1.8</span>])</span><br></pre></td></tr></table></figure><p>当arange与浮点参数一起使用时，由于有限的浮点精度，通常不可能预测所获得的元素的数量。出于这个原因，通常最好使用linspace函数来接收我们想要的元素数量的函数，而不是步长（step）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> numpy <span class="keyword">import</span> pi</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.linspace(<span class="number">0</span>, <span class="number">2</span>, <span class="number">9</span>)</span><br><span class="line">array([<span class="number">0</span>, <span class="number">0.25</span>, <span class="number">0.5</span>, <span class="number">0.75</span>, <span class="number">1.</span> ,<span class="number">1.25</span> ,<span class="number">1.5</span>, <span class="number">1.75</span>, <span class="number">2.</span>])</span><br><span class="line">&gt;&gt;&gt;x = np.linspace(<span class="number">0</span>, <span class="number">2</span>*pi, <span class="number">100</span>)</span><br><span class="line">&gt;&gt;&gt;f = np.sin(x)</span><br></pre></td></tr></table></figure><h4 id="索引、切片"><a href="#索引、切片" class="headerlink" title="索引、切片"></a>索引、切片</h4><p>一维的数组可以进行索引、切片和迭代操作的，就像列表和其他Python序列类型一样</p><p>多维的数组每个轴可以有一个索引。这些索引以逗号分隔的元组给出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b[<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b[<span class="number">0</span>:<span class="number">5</span>, <span class="number">1</span>]<span class="comment"># each row in the second column of b</span></span><br><span class="line">b[ : ,<span class="number">1</span>]<span class="comment"># equivalent to the previous example</span></span><br><span class="line">b[<span class="number">1</span>:<span class="number">3</span>, :]<span class="comment"># each column in the second an third row of b</span></span><br></pre></td></tr></table></figure><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><p>对多维数组进行 迭代（Iterating） 是相对于第一个轴完成的</p><p>如果想要对数组中的每个元素执行操作，可以使用flat属性，该属性是数组的所有元素的迭代</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> b:</span><br><span class="line">    <span class="built_in">print</span>(row)</span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> b.flat:</span><br><span class="line">    <span class="built_in">print</span>(element)</span><br></pre></td></tr></table></figure><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>不附表</p><h4 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h4><p>NumPy提供熟悉的数学函数，例如sin，cos和exp。在NumPy中，这些被称为“通函数”（ufunc）。在NumPy中，这些函数在数组上按元素进行运算，产生一个数组作为输出</p><blockquote><p>舍入函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">numpy.around() <span class="comment"># 函数返回指定数字的四舍五入值。</span></span><br><span class="line">numpy.around(a,decimals)</span><br></pre></td></tr></table></figure><p>参数说明：<br>•a: 数组<br>•decimals: 舍入的小数位数。 默认值为0。 如果为负，整数将四舍五入到小数点左侧的位置</p></blockquote><h4 id="算数函数"><a href="#算数函数" class="headerlink" title="算数函数"></a>算数函数</h4><p>NumPy 算术函数包含简单的加减乘除: <code>add()</code>，<code>subtract()</code>，<code>multiply() </code>和 <code>divide()</code>。需要注意的是数组必须具有相同的形状或符合数组广播规则</p><p>numpy.reciprocal() 函数返回参数逐元素的倒数。如 1&#x2F;4 倒数为 4&#x2F;1</p><h4 id="矩阵运算"><a href="#矩阵运算" class="headerlink" title="矩阵运算"></a>矩阵运算</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([[<span class="number">1.0</span>,<span class="number">2.0</span>],[<span class="number">3.0</span>,<span class="number">4.0</span>]])</span><br><span class="line">u = np.eye(<span class="number">2</span>) <span class="comment"># unit 2x2 matrix; &quot;eye&quot; represents &quot;I&quot;</span></span><br><span class="line">j = np.array([[<span class="number">0.0</span>,-<span class="number">1.0</span>],[<span class="number">1.0</span>,<span class="number">0.0</span>]])</span><br><span class="line">y = np.array([[<span class="number">5.</span>],[<span class="number">7.</span>]])</span><br><span class="line"></span><br><span class="line">a.transpose() <span class="comment"># 转置</span></span><br><span class="line">np.linalg.inv(a) <span class="comment"># 求逆</span></span><br><span class="line">np.trace(a) <span class="comment"># 迹</span></span><br><span class="line">np.linalg.solve(a,y) <span class="comment"># 解矩阵方程</span></span><br><span class="line">np.linage.eig(j) <span class="comment"># 特征值和右特征向量</span></span><br></pre></td></tr></table></figure><p>与许多矩阵语言不同，乘积运算符*在NumPy数组中按元素进行运算。矩阵乘积可以使用@运算符（在python&gt; &#x3D; 3.5中）或dot函数或方法执行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A = np.array([[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">1</span>]])</span><br><span class="line">B = np.array([[<span class="number">2</span>,<span class="number">0</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line"></span><br><span class="line">A * B <span class="comment"># elementwise product</span></span><br><span class="line">A @ B <span class="comment"># matrix product</span></span><br><span class="line">A.dot(B) <span class="comment"># another matrix product</span></span><br></pre></td></tr></table></figure><h4 id="Broadcast-广播"><a href="#Broadcast-广播" class="headerlink" title="Broadcast 广播"></a>Broadcast 广播</h4><p>广播(Broadcast)是 numpy 对不同形状(shape)的数组进行数值计算的方式， 对数组的算术运算通常在相应的元素上进行</p><p>如果两个数组 a 和 b 形状相同，即满足 a.shape &#x3D;&#x3D; b.shape，那么 a*b 的结果就是 a 与 b 数组对应位相乘。这要求维数相同，且各维度的长度相同</p><p>4x3 的二维数组与长为 3 的一维数组相加，等效于把数组 b 在二维上重复 4 次再运算</p><p>        <span class="lazyload-img-span">        <img              data-src="https://cdn.jsdelivr.net/gh/louisiy/ImageStorage/img/5.png" >        </sapn>      </p><p>广播的规则:</p><ul><li>让所有输入数组都向其中形状最长的数组看齐，形状中不足的部分都通过在前面加 1 补齐</li><li>输出数组的形状是输入数组形状的各个维度上的最大值</li><li>如果输入数组的某个维度和输出数组的对应维度的长度相同或者其长度为 1 时，这个数组能够用来计算，否则出错</li><li>当输入数组的某个维度的长度为 1 时，沿着此维度运算时都用此维度上的第一组值</li></ul><p>简单理解：对两个数组，分别比较他们的每一个维度（若其中一个数组没有当前维度则忽略），满足：</p><ul><li>数组拥有相同形状</li><li>当前维度的值相等</li><li>当前维度的值有一个是 1</li></ul><p>若条件不满足，抛出 “ValueError: frames are not aligned” 异常</p><h3 id="SCIPY"><a href="#SCIPY" class="headerlink" title="SCIPY"></a>SCIPY</h3><h4 id="模块列表"><a href="#模块列表" class="headerlink" title="模块列表"></a>模块列表</h4><p>不附表</p><h4 id="常量模块"><a href="#常量模块" class="headerlink" title="常量模块"></a>常量模块</h4><p>不附表</p><h4 id="Optimize"><a href="#Optimize" class="headerlink" title="Optimize"></a>Optimize</h4>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Note for Arduino</title>
      <link href="/2023/07/noteArduino/"/>
      <url>/2023/07/noteArduino/</url>
      
        <content type="html"><![CDATA[<h2 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h2><h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><p>项目文件夹位置：默认开发程序储存地点</p><h3 id="选择开发版的型号端口"><a href="#选择开发版的型号端口" class="headerlink" title="选择开发版的型号端口"></a>选择开发版的型号端口</h3><p>工具-开发板</p><p>工具-端口</p><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>文件名称为sketch</p><p>文件-保存 </p>]]></content>
      
      
      
        <tags>
            
            <tag> Arduino </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Notes for Nginx</title>
      <link href="/2023/07/noteNginx/"/>
      <url>/2023/07/noteNginx/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>C10k &#x3D; 10000 concurrent connection处理10000个并发连接</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="包管理器安装"><a href="#包管理器安装" class="headerlink" title="包管理器安装"></a>包管理器安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//Linux apt yum</span><br><span class="line">$ sudo apt update</span><br><span class="line">$ sudo apt install nginx</span><br><span class="line">//Mac Homebrew</span><br><span class="line">$ brew install nginx</span><br><span class="line">//Windows scoop chocolatey</span><br><span class="line">$ scoop install nginx</span><br><span class="line">$ choco install nginx</span><br></pre></td></tr></table></figure><h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ./configue//预编译</span><br><span class="line">--sbin-path=/usr/local/nginx/nginx</span><br><span class="line">--conf-path=/usr/local/nginx/nginx.conf</span><br><span class="line">--pid-path=/usr/local/nginx/nginx.pid</span><br><span class="line">--with-http_ssl_module</span><br><span class="line">--with-pcre=../pcre2-10.39</span><br><span class="line">--with-zlib=../zlibb-1.2.11</span><br><span class="line">$ make  //编译</span><br><span class="line">$ make install       //安装</span><br></pre></td></tr></table></figure><h3 id="使用Docker安装"><a href="#使用Docker安装" class="headerlink" title="使用Docker安装"></a>使用Docker安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull nginx</span><br></pre></td></tr></table></figure><h2 id="服务启停"><a href="#服务启停" class="headerlink" title="服务启停"></a>服务启停</h2><p>启动服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nginx</span><br></pre></td></tr></table></figure><p>没有提示消息即表明顺利启动，启动失败会有提示</p><p>浏览器输入</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localhost</span><br></pre></td></tr></table></figure><p>查看到默认欢迎页面即可</p><p>在命令行输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ps -ef|grep nginx</span><br></pre></td></tr></table></figure><p>可以查看Nginx的进程</p><p>Nginx的进程模型为master为主进程，负责读取和验证配置文件以及管理worker进程，worker进程为工作进程，负责处理实际的请求，worker文件可以有多个</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lsof -i:80//查看端口的利用情况后缀为只查看的端口</span><br></pre></td></tr></table></figure><p>可以用如下命令停止服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nginx -s stop</span><br></pre></td></tr></table></figure><h2 id="静态站点部署"><a href="#静态站点部署" class="headerlink" title="静态站点部署"></a>静态站点部署</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nginx -V</span><br></pre></td></tr></table></figure><p>可以用来查看安装目录，编译参数等各种信息</p><p>也可以通过</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nginx -t</span><br></pre></td></tr></table></figure><p>来查看配置文件的位置</p><p>放在默认文件夹下即可</p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>修改配置文件后，需要使用命令来检查配置文件是否正确</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nginx -t</span><br></pre></td></tr></table></figure><p>worker_processes进程数量，保持同服务器CPU内核的数量相同是比较合适的，也可以设置为auto来自动配置进程数量</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">worker_processes auto;   //全局块设置</span><br><span class="line"></span><br><span class="line">events &#123;//events块服务器和客户端网络连接配置</span><br><span class="line">worker_connections 1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;//http块</span><br><span class="line">include  mime.types;</span><br><span class="line">default_type    application/octet-stream;</span><br><span class="line">sendfile   on;</span><br><span class="line">keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">server &#123;////多个server块</span><br><span class="line">listen  80;</span><br><span class="line">server_name localhost;</span><br><span class="line">return 301  https://$server_name$request_uri;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">listen  8000;</span><br><span class="line">listen  somename:8080;</span><br><span class="line">server_name somenamealiasanother.alias;</span><br><span class="line">location / &#123;</span><br><span class="line">roothtml;</span><br><span class="line">indexindex.html index.htm;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">include servers/*;//把servers目录下的所有配置文件都包含进来</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>代理服务端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">upstream backend&#123;</span><br><span class="line">ip_hash;</span><br><span class="line">server 127.0.0.1:8000weight = 3;</span><br><span class="line">server 127.0.0.1:8001;</span><br><span class="line">server 127.0.0.1:8002;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">location /app&#123;</span><br><span class="line">proxy_pass http://backend;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改完需重载配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nginx -s reload</span><br></pre></td></tr></table></figure><p>默认轮询的方式来代理</p><p>可以使用权重weight来分配负载均衡</p><p>ip_hash策略来使同一个客户端的请求分配到同一台服务器上，解决一些session的问题</p><h2 id="https配置"><a href="#https配置" class="headerlink" title="https配置"></a>https配置</h2><p>http默认端口80，https默认端口443</p><blockquote><p>使用openssl生成证书</p><p>生成私钥文件（private key）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out private.key 2048</span><br></pre></td></tr></table></figure><p>根据私钥生成证书签名请求文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key private.key -out cert.csr</span><br></pre></td></tr></table></figure><p>使用私钥对证书申请进行签名从而生成证书文件（pem文件）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -req -in cert.csr -out cacert.pem -signkey private.key</span><br><span class="line"></span><br><span class="line">在配置文件中进行配置</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>server{<br>    listen 80;<br>    server_name adf;<br>    return 301 https:&#x2F;&#x2F;$server_name$request_url;<br>}</p></blockquote><p>server{<br>    listen 443 ssl;<br>    server_name locahost;&#x2F;&#x2F;一般填写自己的域名</p><pre><code>ssl_certificate路径;ssl_certificate_key 路径;//加密协议和算法相关的配置ssl_session_timeout 5m;//缓存有效期ssl_protocolsTLSv1TLSv1.1TLSv1.2TLSv1.3;ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:! aNULL:! MD5:!RC4:!DHE;ssl_prefer_server_ciphers on;</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 配置文件</span><br><span class="line"></span><br><span class="line">通过server来设置虚拟主机</span><br><span class="line"></span><br><span class="line">可以在/server下新建文件，然后重载也可以</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="vue-conf"><a href="#vue-conf" class="headerlink" title="vue.conf"></a>vue.conf</h1><p>server{<br>    listen 5173;<br>    server_name locahost;<br>    location &#x2F;{<br>        root路径;<br>        indexindex.html index.htm;<br>    }<br>}<br>&#96;&#96;&#96;</p>]]></content>
      
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Notes for csapp</title>
      <link href="/2023/06/noteCS_APP/"/>
      <url>/2023/06/noteCS_APP/</url>
      
        <content type="html"><![CDATA[<h2 id="1-计算机系统漫游"><a href="#1-计算机系统漫游" class="headerlink" title="1 计算机系统漫游"></a>1 计算机系统漫游</h2><p>计算机系统是由硬件和系统软件组成。</p><h3 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h3><p>源文件是位序列</p><p>ASCII字符构成的文件称为文本文件，其它的为二进制文件</p><p>区分不同数据对象的唯一办法是读取这些数据对象的上下文</p><p>数字的机器表示方法，与实际的整数和实数是不同的，它们是对真值的有限近似值</p><p>C语言是系统级编程的首选，同时它也非常适用于应用级程序的编写，但C语言缺乏对非常有用的抽象的显性支持，例如类、对象和异常。像C++和Java这样针对应用级程序的新程序语言解决了这些问题</p><h3 id="1-2"><a href="#1-2" class="headerlink" title="1.2"></a>1.2</h3><p>高级C语言程序-&gt;低级机器语言指令-&gt;可执行目标程序的格式</p><p>编译器驱动程序完成这个过程</p><p>分为四个阶段：</p><p>源文件.c</p><ul><li>预处理器（cpp）<ul><li>.i 修改了的源文件</li></ul></li><li>编译器（ccl）<ul><li>.s 汇编程序</li></ul></li><li>汇编器（as）<ul><li>.o 可重定位目标程序</li></ul></li><li>链接器（ld）<ul><li>可执行目标程序</li></ul></li></ul><p>GUN环境+Linux内核 &#x3D; 类UNIX系统</p><h3 id="1-3"><a href="#1-3" class="headerlink" title="1.3"></a>1.3</h3><ul><li>优化程序性能</li><li>理解链接时出现的错误</li><li>避免安全漏洞</li></ul><h3 id="1-4"><a href="#1-4" class="headerlink" title="1.4"></a>1.4</h3><p>shell是一个命令行解释器，它输出一个提示符，等待输入一个命令行，然后执行这个命令</p><p><strong>系统的硬件组成</strong></p><ul><li>总线<ul><li>字长时一个基本的系统参数</li></ul></li><li>I&#x2F;O设备<ul><li>每个I&#x2F;O设备都通过一个控制器或适配器与I&#x2F;O总线相连</li><li>控制器和适配器的区别在于它们的封装方式<ul><li>控制器时I&#x2F;O设备本身或者系统的主印制电路板（主板）上的芯片组</li><li>适配器是一块插在主板插槽上的卡</li></ul></li></ul></li><li>主存<ul><li>DRAM</li><li>线性字节数组，每个字节都有唯一的地址（数组索引），这些地址是从零开始的</li><li>一般来说，组成程序的每条机器指令都由不同数量的字节构成</li></ul></li><li>处理器<ul><li>寄存器，大小一个字，程序计数器（PC），指向主存中的某条机器语言指令（即含有该条指令的地址）</li><li>指令执行模型是由指令集架构决定的</li><li>寄存器文件，小的储存设备，由一些单个字长的寄存器组成，每个寄存器都有唯一的名字</li><li>可能会执行的操作<ul><li>加载：从主存复制一个字节或者一个字到寄存器，以覆盖寄存器原来的内容</li><li>存储：从寄存器复制一个字节或者一个字到主存的某个位置，以覆盖这个位置上原来的内容</li><li>操作：把两个寄存器的内容复制到ALU，ALU对这两个字做算术运算，并将结果存放到一个寄存器中，以覆盖寄存器中原来的内容</li><li>跳转：从指令本身中抽取一个字，并将这个字复制到程序计数器（PC）中，以覆盖PC中原来的值</li></ul></li><li>指令集架构<ul><li>描述的是每条机器代码指令的效果</li></ul></li><li>微体系结构<ul><li>描述的是处理器实际上是如何实现的</li></ul></li></ul></li></ul><p>通过直接储存器存取（DMA）技术，数据可以不通过处理器而直接从磁盘到达内存</p><h3 id="1-5"><a href="#1-5" class="headerlink" title="1.5"></a>1.5</h3><p>根据机械原理，较大的存储设备要比较小的存储设备运行得慢，而快速设备的造价要远高于同类的低速设备</p><p>随着半导体技术的进步，处理器与主存之间的差距还在持续增大。加快处理器的运行速度比加快主存的运行速度要容易和便宜得多</p><p>高速缓存存储器（cache memory，高速缓存）更小更快，作为暂时的集结区域，存放处理器近期可能会需要的信息</p><p>一个典型的寄存器文件只存储几百字节的信息，而主存里可存放几十亿字节</p><p>位于处理器芯片上的L1高速缓存的容量可以达到数万字节。一个容量为数十万和数百万字节的更大的L2高速缓存通过一条特殊的总线连接到处理器。</p><p>进程访问L2高速缓存的时间要比访问L1高速缓存的时间长5倍，但是这仍然比访问主存的时间快5-10倍</p><p>L1、L2高速缓存是用一种叫做静态随机访问存储器（SRAM）的硬件技术实现的</p><p>更新的、处理能力更强的系统甚至有三级高速缓存：L1、L2、L3。系统可以获得一个访问速度很快的很大的存储器。因为利用了高速缓存的局部性原理，即程序内具有访问局部区域里的数据和代码的趋势</p><p>利用高速缓存可以将程序的性能提升一个数量级</p><h3 id="1-6"><a href="#1-6" class="headerlink" title="1.6"></a>1.6</h3><p>在处理器和一个较大较慢的设备（例如主存）之间插入一个更小更快的存储设备（例如高速缓存）已成为普遍观念。实际上，每个计算机系统中的存储设备都被组织成了一个存储器层次结构</p><p>！图（）</p><p>存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存</p><h3 id="1-7"><a href="#1-7" class="headerlink" title="1.7"></a>1.7</h3><p>把操作系统看成是应用程序和硬件之间插入的一层软件，所有应用程序对硬件的操作尝试都必须通过操作系统</p><p>操作系统的两大功能</p><ul><li>防止硬件被失控的应用程序滥用</li><li>向应用程序提供简单一致的机制来控制复杂又通常大不相同的低级硬件设备</li></ul><p>通过三个基本的抽象概念来实现</p><ul><li>进程<ul><li>对处理器、主存和I&#x2F;O设备的抽象表示</li><li>进程是操作系统对一个正在运行的程序的一种抽象</li><li>并发运行说的是一个进程的指令和另一个进程的指令是交错执行的</li><li>通过处理器在进程之间切换来实现并发地执行多个进程，这种交错执行的机制称为上下文切换</li><li>操作系统保持跟踪进程运行所需的所有状态信息。这种状态即是上下文，包括很多信息，比如PC和寄存器文件的当前值，以及主存的内容</li><li>在任何一个时刻，单处理器系统都只能执行一个进程的代码。当操作系统决定要把控制权从当前进程转移到某个新进程时，就会进行上下文切换，即保存当前进程的上下文、恢复新进程的上下文，然后将控制权传递到新进程。新进程会从它上次停止的地方开始</li><li>从一个进程到另一个进程的转换是由操作系统内核（kernel）管理的。内核是操作系统代码常驻主存的地方。当应用程序需要操作系统的某些操作时，它就执行一条特殊的系统调用（system call）指令，将控制权传递给内核。然后内核执行被请求的操作并返回应用程序</li><li>内核不是一个独立的进程，它是系统管理全部进程所用代码和数据结构的集合</li><li><strong>线程</strong><ul><li>一个进程可以由多个称为线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据</li><li>多线程之间比多进程之间更容易共享数据，也因为线程一般来说都比进程更有效。当有多处理器可用的时候，多线程也是一种使得程序可以运行得更快的方法</li></ul></li></ul></li><li>虚拟内存<ul><li>对主存和磁盘I&#x2F;O设备的抽象表示</li><li>每个进程看到的内存都是一致的，称为虚拟地址空间。实现的基本思想是把一个进程虚拟内存的内容存储到磁盘上，然后用主存作为磁盘的高速缓存</li><li>每个进程看到的虚拟地址空间由大量准确定义的区构成，，每个区都有专门的功能<ul><li>程序代码和数据<ul><li>对所有的进程来说，代码是从同一固定地址开始，紧接着的是和C全局变量相对应的数据位置</li><li>代码和数据区是直接按照可执行目标文件的内容初始化的，在进程一开始运行时就被指定了大小</li></ul></li><li>堆<ul><li>紧接在上一层后，称运行时堆</li><li>当调用像<code>malloc</code>和<code>free</code>这样的C标准库函数时，堆可以在运行时动态地扩展和收缩</li></ul></li><li>共享库<ul><li>大约在地址空间的中间部分是一块用来存放像C标准库和数学库这样的共享库的代码和数据的区域</li></ul></li><li>栈<ul><li>位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数调用。和堆一样，用户栈在程序执行期间可以动态地扩展和收缩。每次调用一个函数时，栈就会增长；从一个函数返回时，栈就会收缩</li></ul></li><li>内核虚拟内存<ul><li>地址空间顶部地区域是为内核保留的。不允许应用程序读写这个区域地内容或者直接调用内核代码定义的函数。相反，应用程序必须调用内核来执行这些操作</li></ul></li></ul></li></ul></li><li>文件<ul><li>对I&#x2F;O设备的抽象表示</li><li>就是字节序列</li><li>每个I&#x2F;O设备，包括磁盘、键盘、显示器，甚至网络，都可以看成是文件</li><li>系统中的所有输入输出都是用过使用一小组称为Unix I&#x2F;O的系统函数调用读写文件来实现的</li><li>向应用程序提供了一个统一的视图，来看待系统中可能含有的所有各式各样的I&#x2F;O设备</li></ul></li></ul><h3 id="1-8"><a href="#1-8" class="headerlink" title="1.8"></a>1.8</h3><p>系统不只是一个孤立的硬件和软件的集合体。实际上，现代系统经常通过网络和其他系统连接到一起。对于单独的设备，网络可以视为一个I&#x2F;O设备。系统可以从主存复制一串字节到网络适配器，数据流经网络到达另一台机器，系统也可以读取从其他机器发送来的数据，并把数据复制到自己的主存</p><h3 id="1-9"><a href="#1-9" class="headerlink" title="1.9"></a>1.9</h3><h4 id="Amdahl定律"><a href="#Amdahl定律" class="headerlink" title="Amdahl定律"></a>Amdahl定律</h4><p>若系统执行某应用程序需要时间为$T_{old}$，假设系统某部分所需的执行时间与该时间的比例为$\alpha$，而该部分性能提升比例为$k$，则总的运行时间应为</p><p>$$T_{new}&#x3D;(1-\alpha)T_{old}+\frac{\alpha T_{old}}{k}$$</p><p>则可以计算加速比为</p><p>$$S &#x3D; \frac{1}{(1-\alpha)+\frac{\alpha}{k}}$$</p><p>主要观点：要想显著加速整个系统，必须提升全系统中相当大的部分的速度</p><blockquote><p><strong>表示相对性能</strong></p><p>性能提升最好的表示方法就是用比例的形式$\frac{T_{new}}{T_{old}}$，如果有所改进，则比值应大于1。用后缀<code>×</code>来表示比例，因此“2.2×”即为“2.2倍”</p><p>更传统的方法是用百分比，这种方法适用于变化小的情况，但其定义是模糊的</p></blockquote><p>考虑一个特殊情况，即$k$趋向于$\infty$时。意味着，可以取系统的某一部分将其加速到一个点，在这个点上，这部分花费的时间可以忽略不计，有式子</p><p>$$S_{\infty}&#x3D;\frac{1}{1-\alpha}$$</p><p>例如能将60%的系统加速到不花时间的程度，获得的净加速比将仍只有2.5×</p><p>Amdahl定律描述了改善任何过程的一般原则。获得较高的加速比例因子只有通过优化系统的大部分组件才能获得</p><h4 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h4><p>并发（concurrency）指一个同时具有多个活动的系统，并行（parallelism）指的是用并发来使一个系统运行得更快。并且可以在计算机系统得多个抽象层次上使用。</p><ul><li>线程级并发<ul><li>构建在进程上，可以设计同时有多个程序执行得系统，使用线程，甚至能够在一个进程中执行多个控制流</li><li>传统意义上，这种并发执行只是模拟出来的，使通过使一台计算机在它正在执行的进程间快速切换来实现的</li><li>这种并发形式允许多个用户同时与系统交互</li><li>以上配置为单核处理器系统</li><li>当构建一个由单个操作系统内核控制的多个处理器组成的系统时，我们就得到一个多处理器系统</li><li>最近，随着多核处理器和超线程（hyperthreading）的出现，这类系统才变得常见<ul><li>多核处理器是将多个CPU（称为“核”）集成。典型的组织结构为<ul><li>微处理器芯片有4个CPU核，每个核有独立的L2高速缓存，其中的L1高速缓存分为两部分——一个保存最近取到的指令，另一个存放数据这些核共享更高层次的高速缓存，以及到主存的接口。</li></ul></li><li>超线程，有时候又称为多线程（simultaneous multi-threading）是一项允许一个CPU执行多个控制流的技术<ul><li>它涉及的CPU某些硬件有多个备份，如程序计数器和寄存器，而其他硬件部分只有一份，比如执行浮点算术运算的单元</li><li>常规处理器需要在20000个时钟周期做不同的线程的转换，而超线程的处理器可以在单个周期的基础上决定要执行哪一个线程</li><li>这使得CPU可以更好地利用它的处理资源</li></ul></li></ul></li><li>多处理器系统的使用可以<ul><li>减少在执行多个任务时模拟并发的需要</li><li>使应用程序运行得更快，安东尼是要求程序是以多线程方式来书写</li></ul></li></ul></li><li>指令级并发<ul><li>在较低的抽象层次上，现代处理器可以同时执行多条指令的属性称为指令级并行</li><li>现代处理器可以保持每个时钟周期2-4条指令的执行效率</li><li>每条指令从开始到结束需要长得多的时间，大约20个或更多周期，但是处理器使用了流水线等技巧来同时处理多条指令<ul><li>在流水线中，将执行一条指令所需要的活动划分成不同的步骤，将处理器的硬件组织成一系列的阶段，每个阶段执行一个步骤，这些阶段可以并行地操作，用来处理不同指令地不同部分</li></ul></li><li>如果处理器可以达到比一个周期一条指令更快地执行速率，就称之为超标量（superscalar）处理器</li></ul></li><li>单指令、多数据并行<ul><li>现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作，这种方式称为单指令、多数据，即SIMD并行</li><li>提供这些SIMD指令多是为了提高处理影像、声音和视频数据应用的执行速度。</li><li>虽然有些编译器会试图从C程序中自动抽取SIMD并行性，但是更可靠的方法是用编译器支持的特殊的向量数据类型来写程序</li></ul></li></ul><h4 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h4><p>抽象的使用是计算机科学中最为重要的概念之一</p><p>在处理器里，指令集架构提供了对实际处理器硬件的抽象。只要执行模型一样，不同的处理器实现也能执行同样的机器代码，而又提供不同的开销和性能</p><p>在操作系统中，文件是对I&#x2F;O设备的抽象，虚拟内存是对程序储存器的抽象，而进程是对一个正在运行的程序的抽象。在此基础上再增加一个抽象：虚拟机，它提供对整个计算机的抽象，包括操作系统、处理器和程序。最近显示出优势，因为一些计算机必须能够运行为不同的操作系统或同一操作系统的不同版本设计的程序</p><h2 id="2-信息的表示和处理"><a href="#2-信息的表示和处理" class="headerlink" title="2 信息的表示和处理"></a>2 信息的表示和处理</h2><p>数字表示</p><ul><li>无符号编码（unsigned）<ul><li>基于传统的二进制表示法，表示大于或等于零的数字</li></ul></li><li>补码（two’s-complement）<ul><li>表示有符号整数的最常见的方式，可以为正或者为负的数。</li></ul></li><li>浮点数（floating-point）<ul><li>以2为基数的科学计数法</li></ul></li></ul><p>表示方法为有限位，结果太大而不能表示时就会溢出（overflow）</p><p>整数的表示虽然只能编码一个相对较小的数值范围，但是这种表示是精确的，而浮点数虽然可以编码一个较大的数值范围，但是这种表示只是近似的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> csapp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程设课笔记</title>
      <link href="/2023/05/noteTHUc&amp;c++/"/>
      <url>/2023/05/noteTHUc&amp;c++/</url>
      
        <content type="html"><![CDATA[<h2 id="C-对C的扩充"><a href="#C-对C的扩充" class="headerlink" title="C++对C的扩充"></a>C++对C的扩充</h2><p>在C++中引入术语stream(流)，指的是来自设备的一个数据流。</p><p>在输入操作中，字节从输入设备流向内存</p><p>在输出操作中，字节从内存流向输出设备</p><p>头文件iostream中定义了输入流cin和输出流cout对象</p><h3 id="用cout进行输出"><a href="#用cout进行输出" class="headerlink" title="用cout进行输出"></a>用<code>cout</code>进行输出</h3><p>cout表示输出流对象，与它相关联的设备是显示器。cout必须和输出运算符&lt;&lt;一起使用，表示将其后面的数据插入到输出流中去。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout = c + out</span><br><span class="line"><span class="comment">//c -&gt; char</span></span><br></pre></td></tr></table></figure><p>举例:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i =<span class="number">1</span>;</span><br><span class="line">    <span class="type">float</span> f = <span class="number">3.14</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;A&#x27;</span>, str[]=<span class="string">&quot;hello,world\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; i;</span><br><span class="line">    cout &lt;&lt; f;</span><br><span class="line">    cout &lt;&lt; c;</span><br><span class="line">    cout &lt;&lt; str;</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; f &lt;&lt; c &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用cin进行输出"><a href="#用cin进行输出" class="headerlink" title="用cin进行输出"></a>用<code>cin</code>进行输出</h3><p>cin表示输入流对象，与它相关联的输入输出设备是键盘。当我们从键盘输入字符串时，形成了输入流（数据流），用提取操作符&gt;&gt;将数据流储存到一个事先定义好的变量中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cin = c + in;</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line">    <span class="type">char</span> c, str[<span class="number">20</span>];</span><br><span class="line">    cin &gt;&gt; i &gt;&gt; f &gt;&gt; c &gt;&gt; str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以空白字符（空格、制表符、换行、回车）作为输入数据之间的间隔</span></span><br><span class="line"><span class="comment">//输入一个字符可以使用：</span></span><br><span class="line">cin.<span class="built_in">get</span>(c);</span><br><span class="line"><span class="comment">//输入一个字符串可用：</span></span><br><span class="line">cin.<span class="built_in">getline</span>(str,<span class="number">20</span>);</span><br></pre></td></tr></table></figure><h3 id="C-对数据类型的扩充"><a href="#C-对数据类型的扩充" class="headerlink" title="C++对数据类型的扩充"></a>C++对数据类型的扩充</h3><h4 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h4><p>取值为：true或false</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> RealMonkey = <span class="literal">true</span>;</span><br><span class="line"><span class="type">bool</span> RealMonkey, PrettyWoman;</span><br><span class="line">RealMoney = <span class="literal">false</span>;</span><br><span class="line">PrettyWoman =<span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><p>引用（reference）的作用是为一个变量起一个别名</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> LiBai;</span><br><span class="line"><span class="type">int</span> &amp;LiTaiBai = LiBai; <span class="comment">// 必须初始化</span></span><br><span class="line"><span class="type">int</span> &amp;QingLianJuShi =LiBai;</span><br><span class="line"><span class="type">int</span> &amp;ShiXian = LiBai;</span><br><span class="line"><span class="type">int</span> &amp;JiuXian = LiBai;</span><br><span class="line">LiBai = <span class="number">49</span>;</span><br><span class="line">LiTaiBai ++;</span><br></pre></td></tr></table></figure><h4 id="引用作为函数参数"><a href="#引用作为函数参数" class="headerlink" title="引用作为函数参数"></a>引用作为函数参数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使得在被调用的函数中可以修改作为实参的变量的值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> salary, nCars, nHouses;</span><br><span class="line">    salary = <span class="number">6000</span>;</span><br><span class="line">    nCars = <span class="number">0</span>;</span><br><span class="line">    nHouses = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">DayDreaming</span>(salary, nCars, nHouses);</span><br><span class="line">    cout &lt;&lt; salary &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; nCars &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; nHouses;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DayDreaming</span><span class="params">(<span class="type">int</span> &amp;salary, <span class="type">int</span> &amp;cars, <span class="type">int</span> &amp;houses)</span></span>&#123;</span><br><span class="line">    salary = salary * <span class="number">3</span>;</span><br><span class="line">    cars += <span class="number">2</span>;</span><br><span class="line">    houses ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><h3 id="对象（Object）"><a href="#对象（Object）" class="headerlink" title="对象（Object）"></a>对象（Object）</h3><p>什么是对象</p><ul><li>在认知心理学中，对象是指可触摸、可见或思维可理解的东西</li><li>软件工程中的定义：对象是一个具有状态、行为和标识的实体。相似对象的结构和行为在它们的共有的类中定义</li></ul><p>对象的属性：对象所具有的一些特征成为属性。这些属性会有其对应的值</p><p>对象的状态：一个对象的状态包括该对象的所有属性及每个属性的值</p><p>对象的行为：对象不是孤立存在的，一个对象可以作用于其他对象，也可被其他对象所作用，从而导致状态的变化</p><p>对象的操作：一个对象（类）对外提供的服务</p><h3 id="类（class）"><a href="#类（class）" class="headerlink" title="类（class）"></a>类（class）</h3><p>一组具有类似属性和行为的对象</p><h4 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h4><p>类：抽象地定义了该类对象地本质特征（属性和操作），类型定义、模板</p><p>对象：类的实例，具有各自的属性值，占用存储空间</p><h2 id="类的定义与使用"><a href="#类的定义与使用" class="headerlink" title="类的定义与使用"></a>类的定义与使用</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Baby</span>&#123;</span><br><span class="line">    <span class="comment">//成员变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//成员函数  </span></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类实例</span></span><br><span class="line">Baby dawa, erwa;</span><br></pre></td></tr></table></figure><h3 id="成员变量的初始化"><a href="#成员变量的初始化" class="headerlink" title="成员变量的初始化"></a>成员变量的初始化</h3><ul><li>在<strong>定义类时</strong>即可确定，用构造函数，且无需参数</li><li>在<strong>创建对象时</strong>确定，用带参数的构造函数</li><li>在<strong>创建对象后</strong>才能确定，用成员函数</li></ul><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CLASSNAME</span>&#123;</span><br><span class="line">    <span class="built_in">CLASSNAME</span>()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CLASSNAME</span>([ARGUMENTS])&#123;<span class="comment">//带参数的构造函数</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>构造函数的名字 &#x3D; 类的名字</p></li><li><p>没有返回值类型：不返回任何数据</p></li><li><p>创建对象时自动调用，初始化成员变量</p></li><li><p>每个类需要至少一个构造函数，若不写，则默认为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CLASSNAME</span>()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>类初始化时构造函数的调用顺序：</p><ul><li>初始化对象的储存空间或为零或为null</li><li>按顺序分别调用类成员变量和对象成员的初始化</li><li>调用构造函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dollar</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">Dollar</span>()&#123;</span><br><span class="line">            n = <span class="number">100</span>;</span><br><span class="line">            cout &lt;&lt; n &lt;&lt; <span class="string">&quot; dollars come to my home&quot;</span> &lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Money</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Dollar d;</span><br><span class="line">    <span class="built_in">Money</span>()&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;All money come to my home&quot;</span> &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Money m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ .\test.exe</span><br><span class="line">100 dollars come to my home</span><br><span class="line">All money come to my home</span><br></pre></td></tr></table></figure><h4 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h4><p>调用时可以不需要实参的构造函数</p><ul><li>参数列表为空</li><li>全部参数都有默认值（略）</li></ul><p>每个类只能有一个默认的构造函数，否则将编译错误</p><p>一个构造函数的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Baby</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> gender;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">double</span> weight;</span><br><span class="line">    <span class="type">int</span> numPoops;</span><br><span class="line">    <span class="built_in">Baby</span>(<span class="type">char</span> myname[], <span class="type">char</span> g, <span class="type">double</span> w) <span class="comment">//创建对象时确定</span></span><br><span class="line">                                       : <span class="built_in">age</span>(<span class="number">0</span>), <span class="built_in">numPoops</span>(<span class="number">0</span>) &#123;<span class="comment">//初始化成员列表，在定义类的时候确定</span></span><br><span class="line">        <span class="built_in">strcpy</span>(name, myname);</span><br><span class="line">        gender = g; </span><br><span class="line">        weight = w;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="调用带参数的构造函数"><a href="#调用带参数的构造函数" class="headerlink" title="调用带参数的构造函数"></a>调用带参数的构造函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建对象</span></span><br><span class="line">Baby dawa = <span class="built_in">Baby</span>(<span class="string">&quot;大力士&quot;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="function">Baby <span class="title">dawa</span><span class="params">(<span class="string">&quot;大力士&quot;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="number">20</span>)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><p>形如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Baby</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">poop</span><span class="params">()</span></span>&#123;</span><br><span class="line">            numPoops ++;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Dear mother,&quot;</span> &lt;&lt; <span class="string">&quot;I have pooped.&quot;</span> &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">sayHi</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hi, my name is &quot;</span> &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">(<span class="type">double</span> foodWeight)</span></span>&#123;</span><br><span class="line">    weight +=foodWeight;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上，完整的Baby类为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Baby</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> gender;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">double</span> weight;</span><br><span class="line">    <span class="type">int</span> numPoops;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Baby</span>(<span class="type">char</span> myname[], <span class="type">char</span> g, <span class="type">double</span> w) <span class="comment">//创建对象时确定</span></span><br><span class="line">                                       : <span class="built_in">age</span>(<span class="number">0</span>), <span class="built_in">numPoops</span>(<span class="number">0</span>) &#123;<span class="comment">//初始化成员列表，在定义类的时候确定</span></span><br><span class="line">        <span class="built_in">strcpy</span>(name, myname);</span><br><span class="line">        gender = g; </span><br><span class="line">        weight = w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">poop</span><span class="params">()</span></span>&#123;</span><br><span class="line">            numPoops ++;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Dear mother,&quot;</span> &lt;&lt; <span class="string">&quot;I have pooped.&quot;</span> &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">sayHi</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hi, my name is &quot;</span> &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">(<span class="type">double</span> foodWeight)</span></span>&#123;</span><br><span class="line">    weight +=foodWeight;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数声明与实现分离"><a href="#函数声明与实现分离" class="headerlink" title="函数声明与实现分离"></a>函数声明与实现分离</h3><p>对于普通函数，函数原型与函数的实现可以分离，即把函数原型放在文件开头，而把函数的实现放在后面</p><p>类似的，类的成员函数也可以这样做，函数的实现需要用<code>::</code>来表示它是哪一个类的成员函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//baby.h 头文件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Baby</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> gender;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">double</span> weight;</span><br><span class="line">    <span class="type">int</span> numPoops;</span><br><span class="line">    <span class="built_in">Baby</span>(<span class="type">char</span>*, <span class="type">char</span>, <span class="type">double</span>);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">poop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sayHi</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">(<span class="type">double</span> foodweight)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//baby.cpp 源文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;baby.h&quot;</span></span></span><br><span class="line">Baby::<span class="built_in">Baby</span>(<span class="type">char</span> myname[], <span class="type">char</span> g, <span class="type">double</span> w)&#123;</span><br><span class="line">...    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Baby::poop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Baby::eat</span><span class="params">(<span class="type">double</span> foodweight)</span></span>&#123;</span><br><span class="line">    weight +=foodweight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类的使用"><a href="#类的使用" class="headerlink" title="类的使用"></a>类的使用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Baby</span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类实例</span></span><br><span class="line">Baby dawa = <span class="built_in">Baby</span>(<span class="string">&quot;大力士&quot;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="number">20</span>);</span><br><span class="line">Baby erwa = <span class="built_in">Baby</span>(<span class="string">&quot;千里眼&quot;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="number">16</span>);</span><br><span class="line">Baby sanwa = <span class="built_in">Baby</span>(<span class="string">&quot;钢筋铁骨&quot;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="number">18</span>);</span><br><span class="line">Baby siwa = <span class="built_in">Baby</span>(<span class="string">&quot;火神&quot;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="number">16</span>);</span><br></pre></td></tr></table></figure><h4 id="访问成员变量"><a href="#访问成员变量" class="headerlink" title="访问成员变量"></a>访问成员变量</h4><p><code>Object.FIELD_NAME</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; dawa.name &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; erwa.weight &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; sanwa.numPoops &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h4 id="调用成员参数"><a href="#调用成员参数" class="headerlink" title="调用成员参数"></a>调用成员参数</h4><p><code>Object.METHOD_NAME([参数])</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dawa.<span class="built_in">sayHi</span>();<span class="comment">//把sayHi作用于dawa</span></span><br><span class="line">erwa.<span class="built_in">eat</span>(<span class="number">1</span>);<span class="comment">//把eat(1)作用于erwa</span></span><br><span class="line">sanwa.<span class="built_in">poop</span>();<span class="comment">//把poop作用于sanwa</span></span><br></pre></td></tr></table></figure><h2 id="进一步内容"><a href="#进一步内容" class="headerlink" title="进一步内容"></a>进一步内容</h2><h3 id="对象的赋值"><a href="#对象的赋值" class="headerlink" title="对象的赋值"></a>对象的赋值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="built_in">Point</span>()&#123; x = <span class="number">0</span>; y = <span class="number">0</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Point start, end;</span><br><span class="line">    start.x = <span class="number">3</span>;</span><br><span class="line">    start.y = <span class="number">4</span>;</span><br><span class="line">    end = start;  <span class="comment">//对象的赋值</span></span><br><span class="line">    cout &lt;&lt; end.x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; end.y &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象作为函数参数"><a href="#对象作为函数参数" class="headerlink" title="对象作为函数参数"></a>对象作为函数参数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DaGongRen</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> salary, nCars, nHouses;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetRich</span><span class="params">(DaGongRen p, <span class="type">int</span> s, <span class="type">int</span> c, <span class="type">int</span> h)</span></span>&#123;</span><br><span class="line">    p.salary += s;</span><br><span class="line">    p.nCars += c;</span><br><span class="line">    p.nHouses += h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DaGongRen poor;</span><br><span class="line">    poor.salary = <span class="number">6000</span>;</span><br><span class="line">    poor.nCars = <span class="number">0</span>;</span><br><span class="line">    poor.nHouses = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">GetRich</span>(poor, <span class="number">12000</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; poor.salary &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; poor.nCars &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; poor.nHouses &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">然而GetRich并没有改变初始化的DaGongRen p对象里的值，还是需要引用或指针</span><br></pre></td></tr></table></figure><p>使用另一对象来初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singer</span> &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> birth;</span><br><span class="line">    <span class="built_in">Singer</span>() &#123;&#125;  <span class="comment">//默认构造函数</span></span><br><span class="line">    <span class="built_in">Singer</span>(Singer &amp;o)&#123; <span class="comment">//复制构造函数，形参为引用</span></span><br><span class="line">        name = o.name; birth = o.birth;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#123;</span><br><span class="line">    Singer MJ; <span class="comment">//使用默认构造函数</span></span><br><span class="line">    MJ.name = <span class="string">&quot;Michael Jackson&quot;</span>; </span><br><span class="line">    MJ.birth = <span class="number">1958</span>;</span><br><span class="line">    <span class="function">Singer <span class="title">wang</span><span class="params">(MJ)</span></span>; <span class="comment">//使用复制构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="指向对象的指针"><a href="#指向对象的指针" class="headerlink" title="指向对象的指针"></a>指向对象的指针</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Baby <span class="title">dawa</span><span class="params">(<span class="string">&quot;大力士&quot;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">Baby *p = <span class="keyword">new</span> <span class="built_in">Baby</span>(<span class="string">&quot;大力士&quot;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="number">20</span>);<span class="comment">//new 相当于 malloc</span></span><br><span class="line">cout &lt;&lt; p-&gt;name &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p-&gt;gender<span class="comment">//-&gt;用法类似于结构体</span></span><br></pre></td></tr></table></figure><p>        <span class="lazyload-img-span">        <img              data-src="/..%5Cimg%5Cc&c++_3.png" >        </sapn>      </p><p>对象dawa和指针p都是在栈空间中，new出来的新对象在堆空间中</p><h3 id="静态类型-不作要求"><a href="#静态类型-不作要求" class="headerlink" title="静态类型(不作要求)"></a>静态类型(不作要求)</h3><p>static类型表示“静态”或“全局”的意思，适用于成员变量和方法</p><h4 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h4><ul><li>是类一级的定义，独立于该类的任何对象（实例），为所有对象所共享</li><li>必须在类外初始化，用<code>::</code>指明类</li><li>可以在任何类对象创建之前访问（静态成员函数也是如此）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Baby</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> numBabiesMade; </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> Baby::numBabiesMade = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Baby::numBabiesMade = <span class="number">100</span>; </span><br><span class="line">        Baby b1, b2;</span><br><span class="line">        b1.numBabiesMade = <span class="number">1</span>;</span><br><span class="line">        b2.numBabiesMade = <span class="number">2</span>;</span><br><span class="line">        cout &lt;&lt; Baby::numBabiesMade&lt;&lt;<span class="string">&#x27; &#x27;</span></span><br><span class="line">           &lt;&lt; b1.numBabiesMade &lt;&lt; <span class="string">&#x27; &#x27;</span></span><br><span class="line">           &lt;&lt; b2.numBabiesMade &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常类型（不作要求）"><a href="#常类型（不作要求）" class="headerlink" title="常类型（不作要求）"></a>常类型（不作要求）</h3><h2 id="常用的C-类"><a href="#常用的C-类" class="headerlink" title="常用的C++类"></a>常用的C++类</h2><h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><p>字符串：</p><ul><li>用双引号括起来的若干个字符</li><li>如”你好”、”no zuo no dai”</li><li>C语言：存储在字符数组，以0结尾</li><li>C++：string类<ul><li>表示字符串</li><li>实际上是对字符数组操作的封装</li></ul></li></ul><h3 id="string类的构造函数"><a href="#string类的构造函数" class="headerlink" title="string类的构造函数"></a>string类的构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>();<span class="comment">//默认构造函数，建立长度为0的串</span></span><br><span class="line">string s1;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span>(<span class="type">const</span> <span class="type">char</span> *s);<span class="comment">//用s字符串来初始化</span></span><br><span class="line">string s2 = <span class="string">&quot;abc&quot;</span>;<span class="comment">//或</span></span><br><span class="line"><span class="function">string <span class="title">s2</span><span class="params">(<span class="string">&quot;abc&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span>(<span class="type">const</span> string&amp; s) <span class="comment">//复制构造函数</span></span><br><span class="line">string s3 = s2;</span><br></pre></td></tr></table></figure><h3 id="字符串存储"><a href="#字符串存储" class="headerlink" title="字符串存储"></a>字符串存储</h3><p>字符串中的字符下标从0开始：</p><p><code>String name = &#39;Ultimate&#39;;</code></p><p>        <span class="lazyload-img-span">        <img              data-src="/..%5Cimg%5Cc&c++_1.png" >        </sapn>      </p><ul><li>首字符下标为0，尾字符下标为N-1</li><li>每个元素的类型为char</li></ul><h3 id="string类的一些成员函数"><a href="#string类的一些成员函数" class="headerlink" title="string类的一些成员函数"></a>string类的一些成员函数</h3><table><thead><tr><th>函数名称</th><th>功能描述</th></tr></thead><tbody><tr><td>+、&#x3D;</td><td>字符串的拼接和赋值</td></tr><tr><td>&#x3D;&#x3D;、!&#x3D;、&lt;、&lt;&#x3D;、&gt;、&gt;&#x3D;</td><td>各种关系运算</td></tr><tr><td>int length()</td><td>返回字符串的长度</td></tr><tr><td>s[i]</td><td>访问字符串s中下标为i的字符</td></tr><tr><td>string substr(int pos, int n)</td><td>返回pos开始的n个字符组成的子串</td></tr><tr><td>int find(const char *s, int pos)<br />int find(char c, int pos)</td><td>从pos开始查找字符串s或字符c在当前字符串中的位置</td></tr><tr><td>string&amp;insert(int p0,char *s)</td><td>在当前字符串的p0位置插入字符串s</td></tr><tr><td>string&amp;erase(int pos, int n)</td><td>删除pos开始的n个字符，返回新串</td></tr></tbody></table><h3 id="string类举例"><a href="#string类举例" class="headerlink" title="string类举例"></a>string类举例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">string s1 = <span class="string">&quot;too &quot;</span>;</span><br><span class="line">string s2 = s1 + <span class="string">&quot;how&quot;</span>;</span><br><span class="line">cout &lt;&lt; s2 &lt;&lt; endl;<span class="comment">//“too how”</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//index012345678901</span></span><br><span class="line">string s3 = <span class="string">&quot;Stuart Reges&quot;</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; s3.<span class="built_in">length</span>() &lt;&lt; endl;<span class="comment">//12</span></span><br><span class="line">cout &lt;&lt; s3.<span class="built_in">find</span>(<span class="string">&quot;e&quot;</span>, <span class="number">0</span>) &lt;&lt; endl;<span class="comment">//8</span></span><br><span class="line">cout &lt;&lt; s3.<span class="built_in">substr</span>(<span class="number">7</span>, <span class="number">3</span>) &lt;&lt; endl;<span class="comment">//&quot;Reg&quot;</span></span><br></pre></td></tr></table></figure><h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><h3 id="抽象与封装"><a href="#抽象与封装" class="headerlink" title="抽象与封装"></a>抽象与封装</h3><ul><li>将类的本质行为和它的具体实现分开</li><li>外部观点：类的对外接口</li><li>内部观点：类的具体实现</li></ul><table><thead><tr><th>关键字</th><th>含义</th></tr></thead><tbody><tr><td>public</td><td>任何地方都可以访问（的成员变量和方法）</td></tr><tr><td>protected</td><td>类及其子类的函数可访问，但对象.成员不行</td></tr><tr><td>private</td><td>只能在类内部访问</td></tr><tr><td>未指定（默认）</td><td>等价于private</td></tr></tbody></table><h3 id="直接访问成员变量"><a href="#直接访问成员变量" class="headerlink" title="直接访问成员变量"></a>直接访问成员变量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BankAccount</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    string number;</span><br><span class="line">    <span class="type">double</span> balance;</span><br><span class="line">    string password;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    BankAccount account;</span><br><span class="line">    account.balance = <span class="number">1000000</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;password is:&quot;</span> &lt;&lt; account.password &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不能直接访问成员变量"><a href="#不能直接访问成员变量" class="headerlink" title="不能直接访问成员变量"></a>不能直接访问成员变量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BankAccount</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    string number;</span><br><span class="line">    <span class="type">double</span> balance;</span><br><span class="line">    string password;  </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deposit</span><span class="params">(<span class="type">double</span> money)</span></span>&#123;</span><br><span class="line">            balance += money;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">withdraw</span><span class="params">(<span class="type">double</span> money)</span></span>&#123;</span><br><span class="line">            balance -= money;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resetPassword</span><span class="params">(string pwd)</span></span>&#123;</span><br><span class="line">            password = pwd;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    BankAccount account;</span><br><span class="line">account.<span class="built_in">deposit</span>(<span class="number">1000000</span>);</span><br><span class="line">    string pwd =<span class="string">&quot;abc123&quot;</span>;</span><br><span class="line">    account.<span class="built_in">resetPassword</span>(pwd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口函数命名：<code>getXXX()</code> 查询类；<code>setXXX()</code> 修改类</p><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>其他类型转字符串</p><p>C语言的实现办法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">itoa</span><span class="params">(<span class="type">int</span> value,<span class="type">char</span> *<span class="built_in">string</span>,<span class="type">int</span> radix)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">fcvt</span><span class="params">(<span class="type">double</span> value, <span class="type">int</span> ndigit,<span class="type">int</span> *decpt, <span class="type">int</span> *sign)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">ultoa</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> value, <span class="type">char</span> *<span class="built_in">string</span>, <span class="type">int</span> radix)</span>;</span><br></pre></td></tr></table></figure><p>C++11的实现方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">to_string</span>(<span class="type">int</span> i)</span><br><span class="line">std::<span class="built_in">to_string</span>(<span class="type">unsigned</span> u)</span><br><span class="line">std::<span class="built_in">to_string</span>(<span class="type">long</span> l)</span><br><span class="line">std::<span class="built_in">to_string</span>(<span class="type">unsigned</span> <span class="type">long</span> l)</span><br><span class="line">std::<span class="built_in">to_string</span>(<span class="type">float</span> f)</span><br><span class="line">std::<span class="built_in">to_string</span>(<span class="type">double</span> d)</span><br></pre></td></tr></table></figure><p>例子：小狗阿黄</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bark</span><span class="params">()</span></span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;汪汪汪！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bark</span><span class="params">(<span class="type">bool</span> injured)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(injured)&#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;呜咽...&quot;</span> &lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bark</span><span class="params">(<span class="type">int</span> mood)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(mood == <span class="number">0</span>)&#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;汪汪汪！&quot;</span> &lt;&lt; endl;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(mood == <span class="number">1</span>)&#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;汪！汪汪！&quot;</span> &lt;&lt; endl;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(mood == <span class="number">2</span>)&#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;呜-呜&quot;</span> &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Dog ahuang;</span><br><span class="line">    ahuang.<span class="built_in">bark</span>();</span><br><span class="line">    ahuang.<span class="built_in">bark</span>(<span class="literal">true</span>);</span><br><span class="line">    ahuang.<span class="built_in">bark</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重载的条件</p><p>成员方法重名，但是</p><ul><li>参数个数不同</li><li>参数的类型不同</li><li>顺序不同</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Calculation</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">            cout &lt;&lt; (a+b);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">            cout &lt;&lt; (a+b+c);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculation2</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">            cout &lt;&lt; (a+b);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sum</span><span class="params">(<span class="type">double</span> a,<span class="type">double</span> b)</span></span>&#123;</span><br><span class="line">cout &lt;&lt; (a+b);           </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculation3</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a,<span class="type">double</span> b)</span></span>&#123;</span><br><span class="line">            cout &lt;&lt; (a+b);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sum</span><span class="params">(<span class="type">double</span> b,<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">            cout &lt;&lt; (a+b);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">    Calculation obj;</span><br><span class="line">    obj.<span class="built_in">sum</span>(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line">    obj.<span class="built_in">sum</span>(<span class="number">20</span>,<span class="number">20</span>);</span><br><span class="line">    </span><br><span class="line">    Calculation2 obj2;</span><br><span class="line">    obj2.<span class="built_in">sum</span>(<span class="number">10.5</span>,<span class="number">10.5</span>);</span><br><span class="line">    obj2.<span class="built_in">sum</span>(<span class="number">20</span>,<span class="number">20</span>);</span><br><span class="line">    </span><br><span class="line">    Calculation3 obj3;</span><br><span class="line">    obj3.<span class="built_in">sum</span>(<span class="number">10</span>,<span class="number">10.5</span>);</span><br><span class="line">    obj3.<span class="built_in">sum</span>(<span class="number">20.5</span>,<span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数个数相同，各个参数的数据类型和顺序也相同，但变量名不同。不能够构成函数重载。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">move</span><span class="params">(string snake)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">move</span><span class="params">(string turtle)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="存储管理（不作要求）"><a href="#存储管理（不作要求）" class="headerlink" title="存储管理（不作要求）"></a>存储管理（不作要求）</h2><p>寄存器、栈（stack）、堆（heap）、静态数据区</p><h3 id="内存分布"><a href="#内存分布" class="headerlink" title="内存分布"></a>内存分布</h3><p>        <span class="lazyload-img-span">        <img              data-src="/..%5Cimg%5Cc&c++_2.png" >        </sapn>      </p><h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><p>类与类之间的关系</p><ul><li>泛化（Generalization）：“is a”关系，继承关系，一般类&#x2F;特殊类，父类&#x2F;子类，基类&#x2F;派生类</li><li>聚合（Aggregation）：“part of”关系，整体&#x2F;部分</li><li>关联（Association）：类与类之间存在某种语义关联</li></ul><p>继承是类与类之间的关系，而非对象之间的关系</p><ul><li>便于软件重用</li><li>不同子类之间有许多共同的属性</li><li>但是子类之间又有区别</li></ul><p>        <span class="lazyload-img-span">        <img              data-src="/..%5Cimg%5Cc&c++_4.png" >        </sapn>      </p><ul><li>Y继承了X的属性和操作</li><li>Y只需要定义新增的属性和操作</li><li>Y的对象同时也是X的对象</li></ul><p>类的层次结构</p><ul><li>不同程度的抽象可得到不同层次的类</li></ul><p>        <span class="lazyload-img-span">        <img              data-src="/..%5Cimg%5Cc&c++_5.png" >        </sapn>      </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dude</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        string name;</span><br><span class="line">        <span class="type">int</span> hp;<span class="comment">// 血量</span></span><br><span class="line">        <span class="type">int</span> mp;<span class="comment">// 魔力值</span></span><br><span class="line">        <span class="built_in">Dude</span>() &#123; hp = <span class="number">100</span>; mp = <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">sayName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            cout &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">punchFace</span><span class="params">(Dude &amp;target)</span> </span>&#123;</span><br><span class="line">            target.hp -= <span class="number">10</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wizard</span>  :  <span class="keyword">public</span> Dude&#123; <span class="comment">// Wizard 是 Dude 的一个子类</span></span><br><span class="line">    string spells[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">cast</span><span class="params">(string spell)</span></span>&#123;</span><br><span class="line">            <span class="comment">// cool stuff here</span></span><br><span class="line">            ...</span><br><span class="line">            mp -= <span class="number">10</span>;</span><br><span class="line">        &#125;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrandWizard</span> : <span class="keyword">public</span> Wizard &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">sayName</span><span class="params">()</span></span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Grand wizard &quot;</span> &lt;&lt; name;</span><br><span class="line">        &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">grandWizard1.name = <span class="string">&quot;Flash&quot;</span>;</span><br><span class="line">grandWizard1.<span class="built_in">sayName</span>();</span><br></pre></td></tr></table></figure><p>C++看到如下语句时会如何做？<code>grandWizard1.punchFace(dude1);</code></p><ul><li>在GrandWizard类中寻找punchFace()；</li><li>没有找到！grandWizard有父类吗？</li><li>在Wizard类中查找punchFace()；</li><li>没有找到！Wizard有父类吗？</li><li>在Dude类中查找punchFace()；</li><li>找到了！调用punchFace()；</li><li>减少dude1的hp值</li></ul><h3 id="不同的继承方式"><a href="#不同的继承方式" class="headerlink" title="不同的继承方式"></a>不同的继承方式</h3><p> 三类继承方式：公有继承（public）、私有继承（private）、保护继承（protected）</p><table><thead><tr><th></th><th>访问属性的继承</th><th>子类成员函数</th><th>子类对象</th></tr></thead><tbody><tr><td>公有继承</td><td>父类的public和protected成员的访问属性在子类中不变，private不能访问</td><td>可以访问父类中的public和protected成员，不能访问private成员</td><td>只能访问从父类继承的public成员</td></tr><tr><td>私有继承</td><td>父类的public和protected成员以private出现在子类，private不能访问</td><td>同上</td><td>不能访问从父类继承的任何成员</td></tr><tr><td>保护继承</td><td>父类的public和protected成员以protected出现在子类，private不能访问</td><td>同上</td><td>不能访问从父类继承的任何成员</td></tr></tbody></table><h3 id="子类对象的存储"><a href="#子类对象的存储" class="headerlink" title="子类对象的存储"></a>子类对象的存储</h3><p>在创建一个子类对象后</p><ul><li>一方面，该子类对象本身是一个独立、完整的对象</li><li>另一方面，在该对象内部，又包含了一个父类子对象(subobject)</li><li>该子对象与正常创建的父类对象相同</li></ul><p>具体实现</p><p>        <span class="lazyload-img-span">        <img              data-src="/..%5Cimg%5Cc&c++_6.png" >        </sapn>      </p><h3 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h3><p>父类和子类的构造函数</p><ul><li><p>父类和子类的构造函数各自负责初始化自身的成员变量</p></li><li><p>若构造函数无参数，在创建子类对象时系统会自动先调用父类的构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CPU8086</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">cpu8086</span>()&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;8086 constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPU286</span> : <span class="keyword">public</span> CPU8086 &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">CPU286</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;286 constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPU386</span> : <span class="keyword">public</span> CPU286 &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">CPU386</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;386 constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    CPU386 cpu;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line"><span class="number">8086</span> constructor</span><br><span class="line"><span class="number">286</span> constructor</span><br><span class="line"><span class="number">386</span> constructor</span><br></pre></td></tr></table></figure></li><li><p>若构造函数有参数，在子类的构造函数中需要给父类的构造函数传递参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">子类名::子类名(父类所需的形参，子类成员所需的形参): 父类名(参数表), 子类成员初始化列表</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//其他初始化；</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPU8086</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">CPU8086</span>(<span class="type">int</span> i) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;8086 constructor: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPU286</span> : <span class="keyword">public</span> CPU8086 &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">CPU286</span>(<span class="type">int</span> i, <span class="type">int</span> j) : <span class="built_in">CPU8086</span>(i) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;286 constructor: &quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPU386</span> : <span class="keyword">public</span> CPU286 &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">CPU386</span>(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> k) : <span class="built_in">CPU286</span>(i,j)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;386 constructor: &quot;</span> &lt;&lt; k &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="function">CPU386 <span class="title">cpu</span><span class="params">(<span class="number">8086</span>, <span class="number">286</span>, <span class="number">386</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="多态-不作要求"><a href="#多态-不作要求" class="headerlink" title="多态(不作要求)"></a>多态(不作要求)</h2>]]></content>
      
      
      
        <tags>
            
            <tag> C , C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>the C programing Language NOTES</title>
      <link href="/2023/04/noteK&amp;RC/"/>
      <url>/2023/04/noteK&amp;RC/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>现在学习进度，准备开始读一遍传世经典K&amp;R</p><h2 id="A-tutorial-introduction"><a href="#A-tutorial-introduction" class="headerlink" title="A tutorial introduction"></a>A tutorial introduction</h2><h2 id="Types-Operators-and-Expressions"><a href="#Types-Operators-and-Expressions" class="headerlink" title="Types, Operators and Expressions"></a>Types, Operators and Expressions</h2><h2 id="Control-Flow"><a href="#Control-Flow" class="headerlink" title="Control Flow"></a>Control Flow</h2><h2 id="Functions-and-program-structure"><a href="#Functions-and-program-structure" class="headerlink" title="Functions and program structure"></a>Functions and program structure</h2><h2 id="Pointers-and-Arrays"><a href="#Pointers-and-Arrays" class="headerlink" title="Pointers and Arrays"></a>Pointers and Arrays</h2><h2 id="Structures"><a href="#Structures" class="headerlink" title="Structures"></a>Structures</h2><h2 id="Input-and-Output"><a href="#Input-and-Output" class="headerlink" title="Input and Output"></a>Input and Output</h2><h2 id="The-UNIX-System-Interface"><a href="#The-UNIX-System-Interface" class="headerlink" title="The UNIX System Interface"></a>The UNIX System Interface</h2><h2 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h2><ul><li>Reference Manual </li><li>Standard Library</li><li>Summary of Changes</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo主题开发</title>
      <link href="/2023/02/HexoTheme/"/>
      <url>/2023/02/HexoTheme/</url>
      
        <content type="html"><![CDATA[<h2 id="主题开发"><a href="#主题开发" class="headerlink" title="主题开发"></a>主题开发</h2><p>由于之前采用的white主题的开发者已将开源主题归档跑路不再维护，并且相较于本人在其他地方所看到的个人博客还有很多可以修改的可能，故决定在此基础之上进行修改，最后做出另一款自用的主题</p><p>在正式修改开发前需要先学习hexo主题的制作知识，以下综述总结于网络</p><h3 id="预备"><a href="#预备" class="headerlink" title="预备"></a>预备</h3><p>针对Hexo主题的开发需要了解</p><ul><li><p>HTML&#x2F;CSS&#x2F;JavaScript</p></li><li><p>模板引擎语法，如EJS&#x2F;Jade&#x2F;Swig</p></li><li><p>CSS预处理器，如SASS&#x2F;LESS&#x2F;Stylus</p></li><li><p>YML语法</p></li><li><p>Hexo文档</p><ul><li>Hexo | 变量</li><li>Hexo | 辅助函数</li></ul></li></ul><h4 id="主题基本结构"><a href="#主题基本结构" class="headerlink" title="主题基本结构"></a>主题基本结构</h4><p>一般来说hexo的主题需要有以下页面：</p><ul><li>首页 <code>index</code></li><li>存档页 <code>archive</code></li><li>标签文章列表页 <code>tag</code></li><li>分类文章列表页 <code>category</code></li><li>文章详情页 <code>post</code></li><li>页面详情页 <code>page</code></li></ul><p>这些文件是Hexo在生成HTML文件时要用到的，全部放在<code>layout</code>文件夹中。这些页面内重复的组件代码，如页头页脚的部分，可以单独提取出来进行复用</p><p>此外，还有JS&#x2F;CSS&#x2F;图片&#x2F;favicon.ico等文件直接放入source文件夹里，不需要页面引用</p><h4 id="主题文件夹结构"><a href="#主题文件夹结构" class="headerlink" title="主题文件夹结构"></a>主题文件夹结构</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">├─languages//多语言文件夹</span><br><span class="line">│  └─en.yml</span><br><span class="line">├─layout//主题布局模板</span><br><span class="line">│  ├─layout.ejs</span><br><span class="line">│  └─_partial//各页面共享的模板部分</span><br><span class="line">├─scripts//hexo脚本插件目录，可以编写一些辅助函数脚本</span><br><span class="line">├─source//资源文件目录，包括页面样式，js脚本等</span><br><span class="line">│  ├─css</span><br><span class="line">│  │ └─index.styl</span><br><span class="line">│  └─js</span><br><span class="line">└─_config.yml//主题配置文件</span><br></pre></td></tr></table></figure><h4 id="应用主题"><a href="#应用主题" class="headerlink" title="应用主题"></a>应用主题</h4><p>修改<strong>站点配置文件</strong>中的主题配置，使用主题：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">theme-example</span></span><br></pre></td></tr></table></figure><h3 id="详细"><a href="#详细" class="headerlink" title="详细"></a>详细</h3><h4 id="主题配置文件"><a href="#主题配置文件" class="headerlink" title="主题配置文件"></a>主题配置文件</h4><p><code>_config.yml</code>:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="comment"># 或者多个配置文件</span></span><br><span class="line"><span class="attr">language:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">zh-CN</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">en</span></span><br></pre></td></tr></table></figure><h4 id="多语言支持"><a href="#多语言支持" class="headerlink" title="多语言支持"></a>多语言支持</h4><p>Hexo 支持多语言显示，在主题的 <code>languages</code> 文件夹中，存放具体的多语言文件，可以是 YML 或者 JSON 文件。再在主配置文件 <code>_config.yml</code> 中使用下面的方法来指定具体的使用的配置文件名：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="comment"># 或者多个配置文件</span></span><br><span class="line"><span class="attr">language:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">zh-CN</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">en</span></span><br></pre></td></tr></table></figure><p>像下面这样组织语言文件，<code>languages/en.yml</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">archive_title:</span> <span class="string">Archives</span></span><br><span class="line"><span class="attr">category_title:</span> <span class="string">Category</span></span><br><span class="line"><span class="attr">tag_title:</span> <span class="string">Tag</span></span><br></pre></td></tr></table></figure><p>在模板里，当需要在页面中显示文字时，可以使用 Hexo 提供的帮助函数 <code>__()</code> &#x2F; <code>_p()</code> 来读取具体的值，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if is_archive() %&#125;</span><br><span class="line">  &#123;% set pageTitle = _p(&#x27;archive_title&#x27;) %&#125;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">   page_title </span><br></pre></td></tr></table></figure><h4 id="HTML框架"><a href="#HTML框架" class="headerlink" title="HTML框架"></a>HTML框架</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">├─layout</span><br><span class="line">   ├─layout.ejs//通用的布局文件模板</span><br><span class="line">   ├─index.ejs//继承layout.ejs布局模板，首页</span><br><span class="line">   ├─post.ejs//文章详情页</span><br><span class="line">   ├─archive.ejs//归档页  </span><br><span class="line">   ├─page.ejs//自定义页面模板</span><br><span class="line">   └─_partial</span><br><span class="line">     ├─head.ejs</span><br><span class="line">     ├─header.ejs</span><br><span class="line">     ├─footer.ejs</span><br><span class="line">     ├─category.ejs</span><br><span class="line">     ├─tag.ejs</span><br><span class="line">     ├─custom.ejs</span><br><span class="line">     └─paginator.ejs</span><br></pre></td></tr></table></figure><p><code>layout/layout.ejs</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;%- partial(&#x27;_partial/head&#x27;) %&gt;//引入head.ejs</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;%- partial(&#x27;_partial/header&#x27;) %&gt;//引入header.ejs</span><br><span class="line">    &lt;%- body %&gt;   //新增的ejs文件将内容填充在这里</span><br><span class="line">    &lt;%- partial(&#x27;_partial/footer&#x27;) %&gt;  //引入footer.ejs</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt; </span><br></pre></td></tr></table></figure><blockquote><p>partial()函数的作用是可以引入其他模板文件，详情参考hexo文档</p></blockquote><p><code>layout/_partial/head.ejs</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;</span><br><span class="line">    &lt;meta content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot; name=&quot;viewport&quot;&gt;</span><br><span class="line">    &lt;title&gt;&lt;%= config.title %&gt;&lt;/title&gt;//config全局变量，包含站点配置</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure><p><code>layout/_partial/header.ejs</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;header class=&quot;header&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;title&quot;&gt;</span><br><span class="line">        &lt;a href=&quot;&lt;%= url_for() %&gt;&quot; class=&quot;logo&quot;&gt;&lt;%= config.title %&gt;&lt;/a&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;nav class=&quot;navbar&quot;&gt;</span><br><span class="line">        &lt;ul class=&quot;menu&quot;&gt;</span><br><span class="line">            &lt;% for (name in theme.menu) &#123; %&gt;</span><br><span class="line">            //theme.menu获取theme_config中导航菜单的设置</span><br><span class="line">            &lt;li class=&quot;menu-item&quot;&gt;</span><br><span class="line">                &lt;a href=&quot;&lt;%- url_for(theme.menu[name]) %&gt;&quot; class=&quot;menu-item-link&quot;&gt;&lt;%= name %&gt;&lt;/a&gt;</span><br><span class="line">            &lt;/li&gt;</span><br><span class="line">            &lt;% &#125; %&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/nav&gt;</span><br><span class="line">&lt;/header&gt;</span><br></pre></td></tr></table></figure><p><code>layout/_partial/footer.ejs</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;footer&gt;</span><br><span class="line">    &lt;p&gt;Theme is &lt;a href=&quot;/&quot; target=&quot;_blank&quot;&gt;Theme-example&lt;/a&gt; by &lt;a href=&quot;&lt;%= config.url %&gt;&quot; target=&quot;_blank&quot;&gt;&lt;%= config.author %&gt;&lt;/a&gt;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;Powered by &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;hexo&lt;/a&gt; &amp;copy; &lt;%- date(Date.now(), &#x27;YYYY&#x27;) %&gt;&lt;/p&gt;</span><br><span class="line">&lt;/footer&gt;</span><br></pre></td></tr></table></figure><p><code>index.ejs</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//变量page会根据不同的页面拥有不同的属性，page变量的posts属性可以拿到文章数据的集合</span><br><span class="line">//这个posts属性需要在layout的文件夹里新建post.ejs的文件才能获得对象的属性</span><br><span class="line">&lt;section class=&quot;posts&quot;&gt;</span><br><span class="line">    &lt;% page.posts.each(function (post) &#123; %&gt;//显示文章列表</span><br><span class="line">    &lt;article class=&quot;post&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;post-title&quot;&gt;</span><br><span class="line">            &lt;a class=&quot;post-title-link&quot; href=&quot;&lt;%- url_for(post.path) %&gt;&quot;&gt;&lt;%= post.title %&gt;&lt;/a&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;post-content&quot;&gt;</span><br><span class="line">            &lt;%- post.content %&gt;  //显示文章的全部内容</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        或者：</span><br><span class="line">        &lt;div class=&quot;post-content&quot;&gt;</span><br><span class="line">       &lt;%- post.excerpt %&gt;</span><br><span class="line">    //excerpt属性可获取文章的摘录部分，即文章中&lt;!--more--&gt;标记前的内容</span><br><span class="line">    //如果未标记，那么post.excerpt会是空的</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;post-meta&quot;&gt;</span><br><span class="line">            &lt;span class=&quot;post-time&quot;&gt;&lt;%- date(post.date, &quot;YYYY-MM-DD&quot;) %&gt;&lt;/span&gt;</span><br><span class="line">        //</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/article&gt;</span><br><span class="line">    &lt;% &#125;) %&gt;</span><br><span class="line">&lt;/section&gt;</span><br></pre></td></tr></table></figure><p> <code>post.ejs</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;article class=&quot;post&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;post-title&quot;&gt;</span><br><span class="line">        &lt;h2 class=&quot;title&quot;&gt;&lt;%= page.title %&gt;&lt;/h2&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;post-meta&quot;&gt;</span><br><span class="line">        &lt;span class=&quot;post-time&quot;&gt;&lt;%- date(page.date, &quot;YYYY-MM-DD&quot;) %&gt;&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;post-content&quot;&gt;</span><br><span class="line">        &lt;%- page.content %&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/article&gt;</span><br></pre></td></tr></table></figure><p><code>archive.ejs</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;section class=&quot;archive&quot;&gt;</span><br><span class="line">    &lt;ul class=&quot;post-archive&quot;&gt;</span><br><span class="line">    &lt;% page.posts.each(function (post) &#123; %&gt;</span><br><span class="line">        &lt;li class=&quot;post-item&quot;&gt;</span><br><span class="line">            &lt;span class=&quot;post-date&quot;&gt;&lt;%= date(post.date, &quot;YYYY-MM-DD&quot;) %&gt;&lt;/span&gt;</span><br><span class="line">            &lt;a class=&quot;post-title&quot; href=&quot;&lt;%- url_for(post.path) %&gt;&quot;&gt;&lt;%= post.title %&gt;&lt;/a&gt;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">    &lt;% &#125;) %&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">&lt;/section&gt;</span><br><span class="line">&lt;%- partial(&#x27;_partial/paginator&#x27;) %&gt;</span><br></pre></td></tr></table></figure><h4 id="CSS样式"><a href="#CSS样式" class="headerlink" title="CSS样式"></a>CSS样式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">├─source//资源文件目录，包括页面样式，js脚本等</span><br><span class="line">   ├─css</span><br><span class="line">   │ ├─style.styl</span><br><span class="line">   │ ├─index.styl</span><br><span class="line">   │ └─_partial</span><br><span class="line">   │   ├─header.styl</span><br><span class="line">   │   ├─footer.styl   </span><br><span class="line">   │   ├─post.styl</span><br><span class="line">   │   └─archive.styl</span><br><span class="line">   └─js</span><br></pre></td></tr></table></figure><p>Hexo提供 <code>hexo-renderer-stylus</code> 插件，只需要将样式文件放到 <code>source/css</code> 文件夹中。Hexo 在生成页面的时候会将 <code>source</code> 中的所有文件复制到生成的 <code>public</code> 文件中，并且在此之前会编译 <code>styl</code> 为 <code>css</code> 文件，把所有样式 <code>import</code> 到<code>style.styl</code>，编译之后只会有 <code>style.css</code> 一个文件</p><p><code>style.styl</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">    background-color: #F2F2F2;</span><br><span class="line">    font-size: 1.25rem;</span><br><span class="line">    line-height: 1.5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.container &#123;</span><br><span class="line">    max-width: 960px;</span><br><span class="line">    margin: 0 auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">@import &quot;_partial/header&quot;;</span><br><span class="line">@import &quot;index&quot;;</span><br></pre></td></tr></table></figure><h4 id="进一步细节"><a href="#进一步细节" class="headerlink" title="进一步细节"></a>进一步细节</h4><h5 id="添加分页"><a href="#添加分页" class="headerlink" title="添加分页"></a>添加分页</h5><p>首页显示的文章数量可以通过站点配置文件中的 <code>per_page</code> 字段来修改，但是不可能把所有文章都放在一页，所以需要添加文章列表的分页</p><p><code>_partial/paginator.ejs</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if (page.total &gt; 1)&#123; %&gt;</span><br><span class="line">    &lt;nav class=&quot;page-nav&quot;&gt;</span><br><span class="line">    &lt;%- paginator(&#123;</span><br><span class="line">        prev_text: &quot;&amp;laquo; Prev&quot;,</span><br><span class="line">        next_text: &quot;Next &amp;raquo;&quot;</span><br><span class="line">    &#125;) %&gt;</span><br><span class="line">    &lt;/nav&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p>在 <code>index.ejs</code> 中添加这个文件的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&lt;/section&gt;</span><br><span class="line">&lt;%- partial(&#x27;_partial/paginator&#x27;) %&gt;</span><br></pre></td></tr></table></figure><p>辅助函数 <code>paginator</code>能够插入分页链接，这是最基本的分页，具体的样式可以自行添加，或者根据文档使用其他配置自定义分页</p><h5 id="添加分类页-x2F-分类页"><a href="#添加分类页-x2F-分类页" class="headerlink" title="添加分类页&#x2F;分类页"></a>添加分类页&#x2F;分类页</h5><p>分类页和标签页的模板编写比较特殊，本质上，分类页和标签页属于自定义页面，需要新建自定义页面模板<code>page.ejs</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if (is_current(theme.menu.categories)) &#123; %&gt;</span><br><span class="line">&lt;%- partial(&#x27;_partial/category&#x27;) %&gt;</span><br><span class="line">&lt;% &#125; else if (is_current(theme.menu.tags)) &#123; %&gt;</span><br><span class="line">&lt;%- partial(&#x27;_partial/tag&#x27;) %&gt;</span><br><span class="line">&lt;% &#125; else &#123; %&gt;</span><br><span class="line">&lt;%- partial(&#x27;_partial/custom&#x27;) %&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p>需要根据当前自定义页面的类型来决定渲染何种自定义页面模板。</p><p><code>_partial/category.ejs</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;section class=&quot;archive&quot;&gt;</span><br><span class="line">    &lt;ul class=&quot;post-archive&quot;&gt;</span><br><span class="line">    &lt;% site.categories.each(function (category) &#123; %&gt;</span><br><span class="line">        &lt;span&gt;&lt;%= category.name %&gt;&lt;/span&gt;</span><br><span class="line">        &lt;% category.posts.forEach(function(post) &#123; %&gt;</span><br><span class="line">        &lt;li class=&quot;post-item&quot;&gt;</span><br><span class="line">            &lt;span class=&quot;post-date&quot;&gt;&lt;%= date(post.date, &quot;YYYY-MM-DD&quot;) %&gt;&lt;/span&gt;</span><br><span class="line">            &lt;a class=&quot;post-title&quot; href=&quot;&lt;%- url_for(post.path) %&gt;&quot;&gt;&lt;%= post.title %&gt;&lt;/a&gt;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">        &lt;% &#125;) %&gt;</span><br><span class="line">    &lt;% &#125;) %&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">&lt;/section&gt;</span><br></pre></td></tr></table></figure><p><code>_partial/tag.ejs</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;section class=&quot;archive&quot;&gt;</span><br><span class="line">    &lt;ul class=&quot;post-archive&quot;&gt;</span><br><span class="line">    &lt;% site.tags.each(function (tag) &#123; %&gt;</span><br><span class="line">        &lt;span&gt;&lt;%= tag.name %&gt;&lt;/span&gt;</span><br><span class="line">        &lt;% tag.posts.forEach(function(post) &#123; %&gt;</span><br><span class="line">        &lt;li class=&quot;post-item&quot;&gt;</span><br><span class="line">            &lt;span class=&quot;post-date&quot;&gt;&lt;%= date(post.date, &quot;YYYY-MM-DD&quot;) %&gt;&lt;/span&gt;</span><br><span class="line">            &lt;a class=&quot;post-title&quot; href=&quot;&lt;%- url_for(post.path) %&gt;&quot;&gt;&lt;%= post.title %&gt;&lt;/a&gt;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">        &lt;% &#125;) %&gt;</span><br><span class="line">    &lt;% &#125;) %&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">&lt;/section&gt;</span><br></pre></td></tr></table></figure><p><code>site.categories</code>包括了站点所有的分类信息，可以遍历获取分类信息，其中<code>category.posts</code>又包含了该分类的所有文章信息。</p><p>需要注意的是，要想在页面中展示分类页，需要先执行<code>hexo new page categories</code>(<code>tag</code>)生成分类页面，并修改<code>type</code>为<code>categories</code>(<code>tag</code>)</p><p><code>post/category(tag)/categories(tag).md</code>:</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2019-02-25 18:19:55</span><br><span class="line"><span class="section">type: &quot;categories/tag&quot;</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure><h5 id="添加自定义页面"><a href="#添加自定义页面" class="headerlink" title="添加自定义页面"></a>添加自定义页面</h5><p>自定义页面与文章详情页类似</p><p><code>_partial/custom.ejs</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;article class=&quot;post&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;post-title&quot;&gt;</span><br><span class="line">        &lt;h2 class=&quot;title&quot;&gt;&lt;%= page.title %&gt;&lt;/h2&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;post-meta&quot;&gt;</span><br><span class="line">        &lt;span class=&quot;post-time&quot;&gt;&lt;%- date(page.date, &quot;YYYY-MM-DD&quot;) %&gt;&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;post-content&quot;&gt;</span><br><span class="line">        &lt;%- page.content %&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/article&gt;</span><br></pre></td></tr></table></figure><p>并需要在主题配置文件中添加自定义页面的菜单（见前文）</p><p>关于页面执行<code>hexo new page about</code>进行手动生成页面，编辑文件内容即可</p><h3 id="Hexo插件"><a href="#Hexo插件" class="headerlink" title="Hexo插件"></a>Hexo插件</h3><p>Hexo 有强大的插件系统，让我们能够轻松扩展功能而不用修改核心模块的源码。在 Hexo 中有两种形式的插件：</p><ul><li>脚本（Scripts）</li><li>插件（Packages）</li></ul><p>如果代码很简单，可以编写脚本，只需要把 JavaScript 文件放到 <code>scripts</code> 文件夹，在启动时就会自动载入</p><p>想给首页文章列表中的文章块添加一个背景颜色，背景颜色可以在文章md文件中定义，如果未定义，则随机选用一种颜色</p><p>首先，文章md文件中顶部Front-matter添加一个<code>color</code>字段：</p><p><code>_posts/hello-world-1.md</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title</span>: <span class="title class_">Hello</span> <span class="title class_">World</span> <span class="number">1</span></span><br><span class="line"><span class="attr">date</span>: <span class="number">2019</span>-<span class="number">02</span>-<span class="number">12</span> <span class="number">17</span>:<span class="number">49</span>:<span class="number">32</span></span><br><span class="line"><span class="attr">categories</span>: 分类<span class="number">1</span></span><br><span class="line"><span class="attr">tags</span>: </span><br><span class="line">    - 标签<span class="number">1</span></span><br><span class="line"><span class="attr">color</span>: blue</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>定义完成后，就可以在文章信息字段<code>post</code>或者<code>page</code>中获取到<code>color</code></p><p>然后，需要添加一个脚本函数来根据<code>color</code>字段来获取文章块的背景颜色，新增<code>scripts/getPostBgColor.js</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [ <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;purple&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;orange&#x27;</span> ];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getPostBgColor = <span class="keyword">function</span>(<span class="params">color</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.<span class="title function_">indexOf</span>(color) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`bg-<span class="subst">$&#123;color&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;bg-&#x27;</span> + <span class="title function_">randBgColor</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">randBgColor</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> arr[<span class="title function_">randomInt</span>(<span class="number">0</span>, <span class="number">5</span>)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">randomInt</span>(<span class="params">min, max</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">round</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * (max - min)) + min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">helper</span>.<span class="title function_">register</span>(<span class="string">&#x27;getPostBgColor&#x27;</span>, getPostBgColor);</span><br><span class="line"><span class="comment">// 全局注册一个脚本函数</span></span><br></pre></td></tr></table></figure><p><code>layout/index.ejs</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&lt;article class=&quot;post &lt;%= getPostBgColor(post.color) %&gt;&quot;&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>添加背景颜色样式，编辑<code>css/index.styl</code>:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="selector-class">.bg-blue</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#6fa3ef</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.bg-purple</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#bc99c4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.bg-green</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#46c47c</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.bg-yellow</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f9bb3c</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.bg-red</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#e8583d</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.bg-orange</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f68e5f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有其他复杂的需求，可以通过编写更加复杂的脚本来实现</p><h3 id="Hexo的数据DB扩展查询"><a href="#Hexo的数据DB扩展查询" class="headerlink" title="Hexo的数据DB扩展查询"></a>Hexo的数据DB扩展查询</h3><p>我们已经知道，Hexo已经为我们预先义了很多常用的变量供我们使用，具体可以在 Hexo | 变量 查询。但是如果系统提供的变量数据不能满足我们的要求，那我们该怎么办呢？其实我们可以通过扩展查询来获取到我们期望的数据。</p><p>其实Hexo所有的文章分类标签等等变量信息，在编译成本地静态文件之前，都是本地存储在一个<code>db.json</code>中的，相当于小型的本地数据库，Hexo在运行阶段，所有的数据相关操作其实都是在这个小型数据库上进行操作，其底层使用的查询引擎就是Warehouse。因此我们可以通过Warehouse的语法进行自定义扩展查询。</p><p>比如我们需要在页面的底部展示全站的最近6篇文章列表，由于Hexo首页只提供了第一页的数据，因此我们可以基于<code>site</code>变量进行扩展查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site.posts.sort(&#123;date: -1&#125;).limit(6)</span><br></pre></td></tr></table></figure><p><code>site.posts</code>表示所有的文章，<code>sort（&#123;date: -1&#125;)</code>表示按创建时间倒序排列，<code>limit(6)</code>表示只取前6条数据，这样我们就可以拿到了全站的最近6文章信息，后续进行相应展示操作即可。</p><p>其他更多复杂的扩展查询都可以根据Warehouse语法文档进行按需扩展。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实说白了，Hexo就是把那些 Markdown 文件，按照我们编写的对应布局模板，填上对应的数据生成 HTML 页面，然后在编译的过程中将JS&#x2F;CSS等文件引入HTML，然后生成每个页面的对应HMTL静态文件。</p><p>而Hexo主题的作用就是决定每个布局模板长什么样</p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo建站</title>
      <link href="/2023/02/recordHexo/"/>
      <url>/2023/02/recordHexo/</url>
      
        <content type="html"><![CDATA[<p>采用Hexo建立个人博客，本文记录建站经历</p><h2 id="建站思路"><a href="#建站思路" class="headerlink" title="建站思路"></a>建站思路</h2><p>hexo+github+vercel+godaddy+dnspod</p><p>框架+GitHub存储 +网站托管服务 +域名注册+域名服务器DNS</p><p>先用着</p><p>上面已经备份之后，再继续进行操作就只需在hexo_src分支下进行</p><p>hexo的操作，以及git操作</p><p>批处理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean;hexo g;hexo d;git status ;git add . ;git commit -m <span class="string">&#x27;new push&#x27;</span>;git push origin hexo_src</span><br></pre></td></tr></table></figure><p>挺方便</p><h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><p>使用 <code>hexo init</code> 来生成基本文件，做一些基本的配置，像安装模块、配置主题等</p><p>使用 <code>hexo new page / post</code>来生成文章或页面的 md 文件，编辑</p><p>使用 <code>hexo g</code> 生成文件，Hexo 会根据主题中的模板，来生成对应的 html 文件，转译 CSS 文件，复制其它的静态文件（如图片图标字体等），组织为一个静态网站</p><p>使用 <code>hexo d</code> 来部署，一般是借助一些部署模块完成</p><h2 id="备份博客源文件"><a href="#备份博客源文件" class="headerlink" title="备份博客源文件"></a>备份博客源文件</h2><p>有时候我们想换一台电脑继续写博客，这时候就可以将博客目录下的所有源文件都上传到github上面。</p><h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><p>首先在github博客仓库下新建一个分支<code>hexo_src</code>，然后<code>git clone</code>到本地，把<code>.git</code>文件夹拿出来，放在博客根目录下。</p><p>然后<code>git checkout -b hexo_src</code>切换到<code>hexo_src</code>分支，然后<code>git add .</code>，然后<code>git commit -m &quot;xxx&quot;</code>，最后<code>git push origin hexo_src</code>提交就行了。</p><h3 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h3><p>首先在指定文件夹clone下来hexo_src分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> -b hexo_src [仓库地址]</span><br></pre></td></tr></table></figure><p>在该clone下来的文件夹里去安装hexo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cnpm install hexo</span><br><span class="line">$ cnpm install//这一句不知道和上面这一句有何区别</span><br></pre></td></tr></table></figure><blockquote><p>特别注意，hexo_src中的theme文件夹在上传分支后为空，需要再次从原主题仓库clone下来处理</p></blockquote><h2 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h2><p>采用</p><p> jsdelivr (cdn) + github 存储 + PicGo </p><p>方案</p><p>&#x2F;&#x2F; load any GitHub release, commit, or branch</p><p>&#x2F;&#x2F; note: we recommend using npm for projects that support it</p><p><a href="https://cdn.jsdelivr.net/gh/user/repo@version/filecdn+">https://cdn.jsdelivr.net/gh/user/repo@version/filecdn+</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>white主题配置</title>
      <link href="/2023/02/whiteDoc/"/>
      <url>/2023/02/whiteDoc/</url>
      
        <content type="html"><![CDATA[<p>这里是复制了官方的文档，由于官方不再维护，故在此基础上个人增删修改</p><h2 id="👋Hi-there"><a href="#👋Hi-there" class="headerlink" title="👋Hi there"></a>👋Hi there</h2><p>欢迎使用本主题 ，<strong>White</strong> 是一个在个性和极简之间徘徊的主题，（因为作者本身性格就是这样的人，而且搞不好心态爆炸会删库跑路（现已跑路。。。），还请喜欢的各位及时fork🤣</p><p>如果你喜欢这款主题的话，不妨给我一个star 感激不尽！</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote><p>方便备份和更新</p></blockquote><ol><li>fork 本项目</li><li><code>git clone https://github.com/&lt;你的用户名&gt;/hexo-theme-white.git themes/white</code></li><li>修改根目录下的<code>_config.yml</code> 为<code>theme: white</code></li></ol><h2 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h2><blockquote><p>其实config文件里写的很明白了，现在就重新列一下，添加一些不必要的说明</p></blockquote><h3 id="可自定义style"><a href="#可自定义style" class="headerlink" title="可自定义style"></a>可自定义style</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">############## style ##############</span><br><span class="line">style:</span><br><span class="line">  layout:</span><br><span class="line">    max-width: 1130px #总体宽度</span><br><span class="line">    post-max-width: 800px #文章内容宽度</span><br><span class="line">  color:</span><br><span class="line">    theme-main: &quot;#1A98FF&quot; # 主色调</span><br><span class="line">    theme-secondary: &quot;#DDF0FF&quot; # 次色调</span><br><span class="line">    text-main: &quot;#333333&quot; # 文字主色调</span><br><span class="line">    text-secondary: &quot;#898FA0&quot; # 文字次色调</span><br><span class="line">  animation:</span><br><span class="line">    open: true # 如果开启动画的话会引入animation.css</span><br></pre></td></tr></table></figure><h3 id="主页配置"><a href="#主页配置" class="headerlink" title="主页配置"></a>主页配置</h3><h4 id="home页和archive可选配置"><a href="#home页和archive可选配置" class="headerlink" title="home页和archive可选配置"></a>home页和archive可选配置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># home页可选类型</span><br><span class="line">home:</span><br><span class="line">  type: &quot;img&quot; # 主页的类型，可选 home | img | simple</span><br><span class="line"></span><br><span class="line"># archive页可选类型</span><br><span class="line">archive:</span><br><span class="line">  type: &quot;simple&quot; # archive的类型，可选 img | simple</span><br></pre></td></tr></table></figure><p>type为home就是一个封面，为img就是图片加标题的形式，simple就是极简模式</p><h3 id="随机cover"><a href="#随机cover" class="headerlink" title="随机cover"></a>随机cover</h3><p>当你懒的找封面而又想用img模式的时候，我为你准备了些随机封面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">archive_img_mode:</span><br><span class="line">  default_cover: #默认的cover</span><br><span class="line">    - https://cdn.jsdelivr.net/gh/fushaolei/cdn-white@1.0/cover/01.jpg</span><br><span class="line">    - https://cdn.jsdelivr.net/gh/fushaolei/cdn-white@1.0/cover/02.jpg</span><br><span class="line">    - https://cdn.jsdelivr.net/gh/fushaolei/cdn-white@1.0/cover/03.jpg</span><br><span class="line">    - https://cdn.jsdelivr.net/gh/fushaolei/cdn-white@1.0/cover/04.jpg</span><br><span class="line">    - https://cdn.jsdelivr.net/gh/fushaolei/cdn-white@1.0/cover/05.jpg</span><br><span class="line">    - https://cdn.jsdelivr.net/gh/fushaolei/cdn-white@1.0/cover/06.jpg</span><br></pre></td></tr></table></figure><blockquote><p>图片均来自于bing的每日图片，版权归图片原作者所有，我只是搬到了自己的仓库方便使用，如果有侵犯到你的权益，请和我联系 ( •̀ ω •́ )y</p></blockquote><h3 id="浏览器标签页配置"><a href="#浏览器标签页配置" class="headerlink" title="浏览器标签页配置"></a>浏览器标签页配置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># icon</span><br><span class="line">icon:  #标签页图标，这里可填链接</span><br><span class="line">#  header</span><br><span class="line">site_name: white.</span><br></pre></td></tr></table></figure><h3 id="menu"><a href="#menu" class="headerlink" title="menu"></a>menu</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  HOME: /</span><br><span class="line">  BLOG: /archives</span><br></pre></td></tr></table></figure><h3 id="全局搜索"><a href="#全局搜索" class="headerlink" title="全局搜索"></a>全局搜索</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## 本地搜索</span><br><span class="line">search:</span><br><span class="line">  open: false # 是否开启</span><br><span class="line">  page: /search # 页面路径（通常命名为search）</span><br></pre></td></tr></table></figure><p>如果你想使用的话，请先到根目录执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure><p>然后新建一个名为search的page</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page &quot;search&quot;</span><br></pre></td></tr></table></figure><p>进入这个文件夹，更改它的<code>index.md</code>文件，示例如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">layout: search</span><br><span class="line">cover: #你还可以自定义cover</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>然后将open设置为true即可开启</p><h3 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h3><blockquote><p>当你的home页有用到type home模式的话 请配置此项</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 自我介绍</span><br><span class="line">intro:</span><br><span class="line">  title: Hi.I&#x27;m White.</span><br><span class="line">  sub: &#x27;A [White](https://github.com/FuShaoLei/hexo-theme-white) theme for [Hexo](http://hexo.io/)&#x27; # markdown语法</span><br><span class="line">  avator: https://cdn.jsdelivr.net/gh/fushaolei/img/20200524104925.jpg #头像 暂时还没用到</span><br><span class="line">  author: white #所有文章的默认作者</span><br></pre></td></tr></table></figure><h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#联系方式  </span><br><span class="line">#更多图标：https://remixicon.com/</span><br><span class="line">contact:</span><br><span class="line">  Github:</span><br><span class="line">    - https://github.com/FuShaoLei/hexo-theme-white</span><br><span class="line">    - ri-github-line</span><br><span class="line">  Email: </span><br><span class="line">    - mailto:1563250958@qq.com</span><br><span class="line">    - ri-mail-line</span><br></pre></td></tr></table></figure><p>格式就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">名字:</span><br><span class="line">  - 链接</span><br><span class="line">  - 图标 </span><br></pre></td></tr></table></figure><p>更多图标请到 <a href="https://remixicon.com/">https://remixicon.com/</a> 搜寻，感谢此图标项目的开源作者<a href="https://github.com/xiaochunjimmy">xiaochunjimmy</a></p><h3 id="文章toc设置"><a href="#文章toc设置" class="headerlink" title="文章toc设置"></a>文章toc设置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 文章toc索引栏设置</span><br><span class="line">toc:</span><br><span class="line">  open: true # 是否开启</span><br><span class="line">  side: true  # 选择toc的位置，填true的话toc将会显示在文章的侧边，填false的话 toc将出现在文章的开头</span><br><span class="line">  max: 2 #最大深度</span><br><span class="line">  min: 2 #最小深度</span><br></pre></td></tr></table></figure><p>其中side如果设置为false的话，将会出现在文章的top部分，如果设置为true的话，将会出现在侧边<br>min设置的是最小深度，max设置的是最大深度，<del>如上面配置所示，min为2，说明h2索引是至少要出现的，不会出现h1索引 （ 突然不知道怎么表达，</del> 如果不理解的话建议你试试 😂</p><h3 id="highlight"><a href="#highlight" class="headerlink" title="highlight"></a>highlight</h3><p>代码高亮，想要使用代码高亮，得先把根目录的**<code>_config.yml</code>里的highlight的enable置成false**</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 插件</span><br><span class="line">plugins:</span><br><span class="line">  highlightjs:</span><br><span class="line">    js: https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.1/build/highlight.min.js</span><br><span class="line">    css: https://cdn.jsdelivr.net/npm/highlight.js@10.1.1/styles/github.css</span><br><span class="line">    # more: https://www.jsdelivr.com/package/npm/highlight.js?path=styles</span><br></pre></td></tr></table></figure><p><strong>注：</strong> hexo 5.0版本此处有bug（2020年8月10日写），就是渲染不出来大括号（<code>&#123;</code>和<code>&#125;</code>）</p><p>这里博主有点懒了，最近事多心烦，就等着hexo官方更新吧 QAQ</p><h3 id="评论系统"><a href="#评论系统" class="headerlink" title="评论系统"></a>评论系统</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 评论系统设置</span><br><span class="line">comments:</span><br><span class="line">  open: false #是否开启评论系统</span><br><span class="line">  system: gitalk #选择评论系统 可选 valine gitalk livere</span><br><span class="line">  # Valine</span><br><span class="line">  valine:</span><br><span class="line">    appid: #Leancloud应用的AppID  这里和下面的要换成你自己的啊QAQ</span><br><span class="line">    appkey: #Leancloud应用的AppKey</span><br><span class="line">    verify: false #验证码</span><br><span class="line">    notify: true #评论回复提醒</span><br><span class="line">    avatar: robohash #评论列表头像样式：&#x27;&#x27;/mm/identicon/monsterid/wavatar/retro/hide</span><br><span class="line">    #头像类型可见： https://valine.js.org/avatar.html</span><br><span class="line">    placeholder: 留下你来过的痕迹~ #评论框占位符</span><br><span class="line">  # Gitalk</span><br><span class="line">  gitalk:</span><br><span class="line">    owner:  #Github 用户名,</span><br><span class="line">    repo:  #储存评论issue的github仓库名</span><br><span class="line">    admin:  #Github 用户名</span><br><span class="line">    clientID:  #`Github Application clientID`</span><br><span class="line">    clientSecret: #`Github Application clientSecret`</span><br><span class="line">  #livere</span><br><span class="line">  livere: # 前往 http://livere.com/ 申请账号</span><br><span class="line">    dataId: city #免费版本city</span><br><span class="line">    dataUid: #安装代码中 data-uid 后面数据</span><br></pre></td></tr></table></figure><p>这里的话相关教程大家网上搜就好了。这里就不赘诉了</p><blockquote><p>还是写一些gitalk的坑吧，一个是repo这里 写的应该是<strong>仓库名</strong>，而不是仓库链接或者其他的东西，然后gitalk要上线部署一次才可以，md文件名字最好用英文来命名，如果用中文的话，超出50个字符将会初始化失败</p></blockquote><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 页脚</span><br><span class="line">footer: Power by [Hexo](http://hexo.io/) Theme by [White](https://github.com/FuShaoLei/hexo-theme-white) # markdown语法</span><br><span class="line"></span><br><span class="line">#有分类时是否开启menu分类页和自定义名字</span><br><span class="line">menu_categories:</span><br><span class="line">  open: true</span><br><span class="line">  name: 分类</span><br><span class="line"></span><br><span class="line">#可自定义归档标签页名字 </span><br><span class="line">archive_tab_name: Blog</span><br><span class="line"></span><br><span class="line">#图片懒加载</span><br><span class="line">lazyload:</span><br><span class="line">  open: true #是否开启</span><br></pre></td></tr></table></figure><p>这里就不bb了 大家应该看的懂</p><h2 id="进阶使用"><a href="#进阶使用" class="headerlink" title="进阶使用"></a>进阶使用</h2><h3 id="平滑升级"><a href="#平滑升级" class="headerlink" title="平滑升级"></a>平滑升级</h3><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>因为主题的更新比较频繁，所以如果你想舒服用到最新的版本的话，就请使用平滑升级</p><ol><li>在你<strong>根目录</strong>下的<code>source</code>文件夹下新建一个名为<code>_data</code>的<strong>文件夹</strong></li><li>复制<strong>主题文件夹</strong>下的<code>_config.yml</code>到<code>_data</code>文件夹下，重命名为<code>white.yml</code></li></ol><p>好了，到这里差不多完成了，以后你需要改动什么，只需要在这个<code>white.yml</code>中进行修改(在编译时，会自动将此替换<code>_config.yml</code>)</p><h4 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h4><p>当你看到我的主题有<a href="https://github.com/FuShaoLei/hexo-theme-white/issues/3">变更</a>时，在主题文件中执行<code>git pull</code>拉取最新代码<br>然后，对比最新主题文件夹下的<code>_config.yml</code> 看看有无新增什么东西，添加到你的<code>white.yml</code>中即可</p>]]></content>
      
      
      
        <tags>
            
            <tag> document </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mermaid</title>
      <link href="/2023/02/recordMermaid/"/>
      <url>/2023/02/recordMermaid/</url>
      
        <content type="html"><![CDATA[<p>mermaid是一款支持在Markdown文档中使用的图表工具，可以用来画时序图，类图，流程图等。在Markdown中使用十分方便，编辑器Typora支持mermaid。mermaid是基于javascript实现的，将Markdown文档中的元素渲染成HTML元素。基于white搭建的博客起初并不支持mermaid，记录一下实现过程。</p><ol><li><p>安装插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save hexo-filter-mermaid-diagrams</span><br></pre></td></tr></table></figure></li><li><p>修改主题的配置文件<code>_config.yml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Mermaid (markdown to flow chart, seq chart, class chart ...)</span></span><br><span class="line"><span class="attr">mermaid:</span> </span><br><span class="line"><span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># Available themes: default | dark | forest | neutral</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">default</span></span><br></pre></td></tr></table></figure></li><li><p>下载js文件</p><p>&#96;&#96;</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> mermaid </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RoadMaps</title>
      <link href="/2023/02/RoadMaps/"/>
      <url>/2023/02/RoadMaps/</url>
      
        <content type="html"><![CDATA[<h1 id="路线"><a href="#路线" class="headerlink" title="路线"></a>路线</h1><h2 id="Web-dev"><a href="#Web-dev" class="headerlink" title="Web dev"></a>Web dev</h2><p>基础–&gt;交互语言 –&gt; 框架 –&gt; 元框架 –&gt; 后端 –&gt; 无服务平台</p><pre class="mermaid">graph LRA(HTML) --> B(CSS) -->C(Javascript)C --> D(React) --> G(Nexj.js)C --> E(Vue) --> H(Nuxt.js)C--> F(Svelte) --> I(Svelte Kit)G --> J(Firebase\Pocket base\Super base)H --> JI --> JJ --> Node.js</pre><p>Angular Vite tailwindcss</p><p>java，Spring Boot，Ruby on Rails或Laravel </p><p>PHP</p>]]></content>
      
      
      
        <tags>
            
            <tag> learn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GNU和一些</title>
      <link href="/2023/01/recordGNU/"/>
      <url>/2023/01/recordGNU/</url>
      
        <content type="html"><![CDATA[<p>最近更新MinGW，并且由于学习原因需要Cygwin，下载过程中发现很多疑惑。故摘录了部分关于GNU以及相关开发的信息和后面补充的Unix、Linux的内容。信息源有Wikipedia、官网等。</p><h2 id="GNU计划"><a href="#GNU计划" class="headerlink" title="GNU计划"></a>GNU计划</h2><p><strong>GNU计划</strong>（英语：<strong>GNU Project</strong>），又译为<strong>革奴计划</strong>，是一个自由软件计划，1983年9月27日由理查德·斯托曼在麻省理工学院公开发起。它的目标是创建一套完全自由的操作系统，称为GNU。</p><p>理查德·斯托曼最早在net.unix-wizards新闻组上公布该消息，并附带一份《GNU宣言》等解释为何发起该计划的文章，其中一个理由就是要“重现当年软件界合作互助的团结精神”。</p><p>由于GNU将要实现UNIX系统的接口标准，因此GNU计划可以分别开发不同的操作系统。GNU计划采用了部分当时已经可自由使用的软件，例如TeX排版系统和X Window视窗系统等。不过GNU计划也开发了大批其他的自由软件，这些软件也被移植到其他操作系统平台上，例如Microsoft Windows、BSD家族、Solaris及Mac OS。</p><p>为保证GNU软件可以自由地“使用、复制、修改和发布”，所有GNU软件都包含一份在禁止其他人添加任何限制的情况下，授权所有权利给任何人的协议条款，GNU通用公共许可证（GNU General Public License，GPL）。这个就是被称为“公共著作权”的概念。GNU也针对不同场合，提供GNU宽通用公共许可证与GNU自由文档许可证这两种协议条款。</p><h2 id="GNU"><a href="#GNU" class="headerlink" title="GNU"></a>GNU</h2><p>GNU是一个自由的操作系统，其内容软件完全以GPL方式发布。</p><p>作为操作系统，GNU的发展仍未完成，其中最大的问题是具有完备功能的内核尚未被开发成功。GNU的内核，称为Hurd，是自由软件基金会发展的重点，但是其发展尚未成熟。在实际使用上，多半使用Linux内核、FreeBSD等替代方案，作为系统核心，其中主要的操作系统是Linux的发行版。Linux操作系统包涵了Linux内核与其他自由软件项目中的GNU组件和软件，可以被称为GNU&#x2F;Linux。</p><h2 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h2><p>GNU编译器套装（英语：GNU Compiler Collection，缩写为GCC）是GNU计划制作的一种优化编译器，支持各种编程语言、操作系统、计算机系统结构。该编译器是以GPL及LGPL许可证所发行的自由软件，也是GNU计划的关键部分，还是GNU工具链的主要组成部分之一。GCC（特别是其中的C语言编译器）也常被认为是跨平台编译器的事实标准。1985年由理查德·马修·斯托曼开始发展，现在由自由软件基金会负责维护工作。截至2019年，GCC大约有1500万行代码，是现存最大的自由程序之一。它在自由软件的发展中发挥了重要作用，不仅是一个工具，还是一个典例。</p><p>原名为GNU C语言编译器（GNU C Compiler），因为它原本只能处理C语言。同年12月，新的GCC编译器可以编译C++语言。后来又为Fortran、Pascal、Objective-C、Java、Ada，Go等其他语言开发了前端。C和C++编译器也支持OpenMP和OpenACC规范。</p><p>GCC编译器已经被移植到比其他编译器更多的平台和指令集架构上，并被广泛部署在开发自由和专有软件的工具中。GCC还可用于许多嵌入式系统，包括基于ARM和Power ISA的芯片。</p><p>GCC不仅是GNU操作系统的官方编译器，还是许多类UNIX系统和Linux发行版的标准编译器。BSD家族中的大部分操作系统也在GCC发布之后转用GCC；不过FreeBSD、OpenBSD和Apple macOS已经转向了Clang编译器，主要是因为许可问题。GCC也可以编译Windows、Android、iOS、Solaris、HP-UX、IBM AIX和DOS系统的代码。GCC原本用C开发，后来因为LLVM、Clang的崛起，它更快地将开发语言转换为C++。许多C的爱好者在对C++一知半解的情况下主观认定C++的性能一定会输给C，但是Ian Lance Taylor给出了不同的意见，并表明C++不但性能不输给C，而且能设计出更好，更容易维护的程序。</p><h2 id="Cygwin"><a href="#Cygwin" class="headerlink" title="Cygwin"></a>Cygwin</h2><p>Cygwin是许多自由软件的集合，最初由Cygnus Solutions开发，用于各种版本的Microsoft Windows上，运行类UNIX系统。Cygwin的主要目的是通过重新编译，将POSIX系统（例如Linux、BSD，以及其他Unix系统）上的软件移植到Windows上。Cygwin移植工作在Windows NT上比较好，在Windows 95和Windows 98上，相对差劲一些。目前Cygwin由Red Hat等负责维护。</p><h2 id="MinGW"><a href="#MinGW" class="headerlink" title="MinGW"></a>MinGW</h2><p>MinGW（Minimalist GNU for Windows），又称mingw32，是将GCC编译器和GNU Binutils移植到Win32平台下的产物，包括一系列头文件（Win32API）、库和可执行文件。</p><p>另有可用于产生32位及64位Windows可执行文件的MinGW-w64项目，是从原本MinGW产生的分支。如今已经独立发展。</p><h2 id="MinGW-w64"><a href="#MinGW-w64" class="headerlink" title="MinGW-w64"></a>MinGW-w64</h2><p>Mingw-w64是自由及开放源代码软件开发环境，用于创建Microsoft Windows应用程序。从2005–2008从MinGW(Minimalist GNU for Windows)分支出来。</p><p>Mingw-w64包括对GCC、GNU Binutils的Windows版本的移植（汇编器、链接器、库文件管理器），一套自由可分发的Windows特定的头文件与静态导入库以使用Windows API，一个 Windows本地版本的GNU的调试器，以及其它多种工具。</p><p>Mingw-w64可运行于本地Microsoft Windows平台，”cross-native”在MSYS2或Cygwin。Mingw-w64能生成32-或64-位可执行程序，运行于i686-w64-mingw32或x86_64-w64-mingw32目标平台</p><h2 id="MSYS2"><a href="#MSYS2" class="headerlink" title="MSYS2"></a>MSYS2</h2><p>MSYS2 (“minimal system 2”)是用于Microsoft Windows的软件发布与开发平台，基于Mingw-w64与Cygwin，把Unix环境中的代码移植到Windows。</p><h2 id="lint"><a href="#lint" class="headerlink" title="lint"></a>lint</h2><p>UNIX（非复用信息和计算机服务，英语：Uniplexed Information and Computing Service，UnICS），一种多用户、多进程的计算机操作系统，源自于从20世纪70年代开始在美国AT&amp;T公司的贝尔实验室开发的AT&amp;T Unix。</p><h2 id="BSD"><a href="#BSD" class="headerlink" title="BSD"></a>BSD</h2><p>伯克利软件包（英语：Berkeley Software Distribution，缩写：BSD；也被称为伯克利Unix或Berkeley Unix）是一个派生自Unix（类Unix）的操作系统，1970年代由伯克利加州大学的学生比尔·乔伊开创，也被用来代表其派生出的各种包。</p><p>BSD许可证非常地宽松，因此BSD常被当作工作站级别的Unix系统，许多1980年代成立的计算机公司都从BSD中获益，比较著名的例子如DEC的Ultrix，以及Sun公司的SunOS。 1990年代，BSD大幅度被System V 4.x版以及OSF&#x2F;1系统所取代，但其开源版本被用在互联网的开发。</p><h2 id="Unix"><a href="#Unix" class="headerlink" title="Unix"></a>Unix</h2><p>        <span class="lazyload-img-span">        <img              data-src="https://fastly.jsdelivr.net/gh/louisiy/ImageStorage/img/Unix_history-simple.svg" >        </sapn>      </p><p>UNIX（非复用信息和计算机服务，英语：Uniplexed Information and Computing Service，UnICS），一种多用户、多进程的计算机操作系统，源自于从20世纪70年代开始在美国AT&amp;T公司的贝尔实验室开发的AT&amp;T Unix。</p><p>UNIX操作系统，是一个强大的多用户、多任务操作系统，支持多种处理器架构，按照操作系统的分类，属于分时操作系统，最早由肯·汤普逊、丹尼斯·里奇和道格拉斯·麦克罗伊于1969年在AT&amp;T的贝尔实验室开发。目前它的商标权由国际开放标准组织所拥有，只有符合单一UNIX规范的UNIX系统才能使用UNIX这个名称，否则只能称为类UNIX（UNIX-like）。</p><p>Unix的前身为1964年开始的Multics，1965年时，贝尔实验室加入一项由通用电气和麻省理工学院合作的计划；该计划要创建一套多用户、多任务、多层次（multi－user、multi－processor、multi－level）的MULTICS操作系统。贝尔实验室参与了这个操作系统的研发，但因为开发速度太慢，1969年贝尔实验室决定退出这个计划。贝尔实验室的工程师，肯·汤普逊和丹尼斯·里奇，在此时自行开发了Unix。</p><p>此后的10年，Unix在学术机构和大型企业中得到了广泛的应用，当时的UNIX拥有者AT&amp;T公司以低廉甚至免费的许可将Unix源码授权给学术机构做研究或教学之用，许多机构在此源码基础上加以扩展和改进，形成了所谓的“Unix变种”，这些变种反过来也促进了Unix的发展，其中最著名的变种之一是由加州大学柏克莱分校开发的伯克利软件套件(BSD)产品。</p><p>后来AT&amp;T意识到了Unix的商业价值，不再将Unix源码授权给学术机构，并对之前的Unix及其变种声明了著作权权利。BSD在Unix的历史发展中具有相当大的影响力，被很多商业厂家采用，成为很多商用Unix的基础。其不断增大的影响力终于引起了AT&amp;T的关注，于是开始了一场持久的著作权官司，这场官司一直打到AT&amp;T将自己的Unix系统实验室卖掉，新接手的Novell采取了一种比较开明的做法，允许柏克莱分校自由发布自己的Unix变种，但是前提是必须将来自于AT&amp;T的代码完全删除，于是诞生了4.4 BSD Lite版，由于这个版本不存在法律问题，4.4 BSD Lite成为了现代柏克莱软件包的基础版本。尽管后来，非商业版的Unix系统又经过了很多演变，但其中有不少最终都是创建在BSD版本上（Linux、Minix等系统除外）。所以从这个角度上，4.4 BSD又是所有自由版本Unix的基础，它们和System V及Linux等共同构成Unix操作系统。</p><p>BSD使用主版本加次版本的方法标识，如4.2、4.3BSD，在原始版本的基础上还有派生版本，这些版本通常有自己的名字，如4.3BSD-Net&#x2F;1，4.3BSD-Net&#x2F;2等。BSD在发展中也逐渐派生出3个主要的分支：FreeBSD、OpenBSD和NetBSD。</p><p>此后的几十年中，Unix仍在不断变化，其著作权所有者不断变更，授权者的数量也在增加。Unix的著作权曾经为AT&amp;T所有，之后Novell拥有获取了Unix，再之后Novell又将著作权出售给了圣克鲁兹作业，但不包括知识产权和专利权（这一事实双方尚存在争议）。有很多大公司在获取了Unix的授权之后，开发了自己的Unix产品，比如IBM的AIX、惠普的HP-UX、SCO的Openserver、SUN的Solaris（被Oracle收购）和SGI的IRIX。</p><p>Unix因为其安全可靠，高效强大的特点在服务器领域得到了广泛的应用。直到GNU&#x2F;Linux流行开始前，Unix也是科学计算、大型机、超级计算机等所用操作系统的主流。现在其仍然被应用于一些对稳定性要求极高的数据中心之上。</p><h2 id="POSIX"><a href="#POSIX" class="headerlink" title="POSIX"></a>POSIX</h2><p>可移植操作系统接口（英语：Portable Operating System Interface，缩写为POSIX）是IEEE为要在各种UNIX操作系统上运行软件，而定义API的一系列互相关联的标准的总称，其正式称呼为IEEE Std 1003，而国际标准名称为ISO&#x2F;IEC 9945。此标准源于一个大约开始于1985年的项目。POSIX这个名称是由理查德·斯托曼（RMS）应IEEE的要求而提议的一个易于记忆的名称。它基本上是Portable Operating System Interface（可移植操作系统接口）的缩写，而X则表明其对Unix API的传承。</p><p>当前的POSIX主要分为四个部分：Base Definitions、System Interfaces、Shell and Utilities和Rationale。</p>]]></content>
      
      
      
        <tags>
            
            <tag> GNU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>When I learn C</title>
      <link href="/2023/01/noteHighC/"/>
      <url>/2023/01/noteHighC/</url>
      
        <content type="html"><![CDATA[<h1 id="HERE-IS-NOTE-FOR-Head-First-C-😃"><a href="#HERE-IS-NOTE-FOR-Head-First-C-😃" class="headerlink" title="HERE IS NOTE FOR Head First C 😃"></a>HERE IS NOTE FOR <em>Head First C</em> 😃</h1><h2 id="0-关于"><a href="#0-关于" class="headerlink" title="0 关于"></a>0 关于</h2><p>这里是符号说明，形如</p><ul><li>这是一条个人笔记</li></ul><blockquote><p>这是小拓展</p></blockquote><h2 id="1-入门"><a href="#1-入门" class="headerlink" title="1 入门"></a>1 入门</h2><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p><code>gcc -o</code> 设置文件名</p><p><code>./name</code> 类Unix操作系统中运行程序必须指定程序所在的目录，除非该程序目录已在PATH环境变量中</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>C不支持现成的字符串</p><p>定义字符串数组需额外加一个字符的空间来容纳<code>/0</code>（NULL字符），字符的索引值为偏移量</p><p>单引号通常用来表示单个字符，而双引号通常用来表示字符串。通常应该用双引号来定义字符串。用双引号定义的字符串叫字符串字面值（string literal），比起字符数组，它输入起来也更方便</p><p>总线错误（bus error）意味着程序无法更新那一块存储器空间</p><h3 id="等号"><a href="#等号" class="headerlink" title="等号"></a>等号</h3><p><code>num = 1</code> 等号用来赋值（assignment）</p><p><code>num == 1</code> 检查值是否相等</p><p><code>nunm += 2 or num -= 2</code> 加减2</p><p><code>num++ or num--</code> 加减1</p><h3 id="布尔运算"><a href="#布尔运算" class="headerlink" title="布尔运算"></a>布尔运算</h3><p><code>&amp;&amp; || !</code> 与或非</p><p><code>&amp;</code>和<code>|</code>操作符总是计算两个条件，而<code>&amp;&amp;</code>和<code>||</code>可以跳过第二个条件</p><p>位运算 <code>6 &amp; 4</code> 等于4</p><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>switch语句检查一个单独的值。计算机会在第一个匹配的case语句处开始执行代码。在遇到break或到达switch语句的末尾前，代码会一直运行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(train) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">37</span>:</span><br><span class="line">winnings = winnings + <span class="number">50</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">65</span>:</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;头等奖!&quot;</span>);</span><br><span class="line">winnings = winnings + <span class="number">80</span>;<span class="comment">//执行完这条接着再+20这条，直到break</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">winnings = winnings + <span class="number">20</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">winnings = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> counter;</span><br><span class="line"><span class="keyword">for</span> (counter = <span class="number">1</span>; counter &lt; <span class="number">11</span>; counter++) &#123;<span class="comment">//(初始化循环变量；循环运行前检查；循环后执行)</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%i个枣\n&quot;</span>, counter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以用<code>break</code>在任意时刻退出循环</p><p>可以用<code>continue</code>随时跳到循环条件处</p><h3 id="链式赋值"><a href="#链式赋值" class="headerlink" title="链式赋值"></a>链式赋值</h3><p><code>x = y = 4;</code>给多个变量赋相同值</p><h2 id="2-指针"><a href="#2-指针" class="headerlink" title="2 指针"></a>2 指针</h2><p>使用指针的主要目的之一就是让函数共享存储器，指针只是一个保存存储器地址的变量，它们是进程存储器中真实编号的地址</p><h3 id="储存器"><a href="#储存器" class="headerlink" title="储存器"></a>储存器</h3><p>局部变量保存在栈（Stack），全局变量保存在全局量区（Globals）</p><p><code>&amp;x</code>指x的地址 <code>%p</code>来格式化输出</p><blockquote><p>栈<br>这是存储器用来保存局部变量的部分。每当调用函数，函数的所有局部变量都在栈上创建。它之所以叫栈是因为它看起来就像堆积而成的栈板：当进入函数时，变量会放到栈顶；离开函数时，把变量从栈顶拿走。奇怪的是，栈做起事来颠三倒四，它从存储器的顶部开始，向下增长。</p><p>堆<br>堆用于动态存储：程序在运行时创建一些数据，然后使用很长一段时间。</p><p>全局量<br>全局量位于所有函数之外，并对所有函数可见。程序一开始运行时就会创建全局量，可以修改它们，不像常量。</p><p>常量<br>常量也在程序一开始运行时创建，但它们保存在只读存储器中。常量是一些在程序中要用到的不变量，你不会想修改它们的值，例如字符串字面值。</p><p>代码<br>最后是代码段，很多操作系统都把代码放在存储器地址的低位。代码段也是只读的，它是存储器中用来加载机器代码的部分。</p></blockquote><h3 id="int"><a href="#int" class="headerlink" title="int *"></a>int *</h3><p><code>int *address_of_x = &amp;x;</code></p><p><code>*</code>来解引用，如<code>int value_stored = *address_of_x;</code> 、<code>*address_of_x = 99;</code></p><h3 id="sizeof（）"><a href="#sizeof（）" class="headerlink" title="sizeof（）"></a>sizeof（）</h3><p>这是个运算符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"><span class="keyword">sizeof</span>(<span class="string">&quot;Turtles!&quot;</span>);<span class="comment">//返回9</span></span><br></pre></td></tr></table></figure><h3 id="数组变量"><a href="#数组变量" class="headerlink" title="数组变量"></a>数组变量</h3><p>数组变量可以被用作指针，指向数组中的第一个元素。函数参数声明如为数组，则其会被当作指针处理</p><p>计算机不会为数组变量分配任何空间，编译器仅在出现它的地方把它替换成数组的起始地址，所以不能把它指向任何其他地方</p><blockquote><p>指针退化</p><p>假如把数组赋给指针变量，指针变量只会包含数组的地址信息，而对数组的长度一无所知，相当于指针丢失了一些信息，也就是指针退化。</p><p>只要把数组传递给函数，数组免不了退化为指针，但需要记清楚代码中有哪些地方发生过数组退化，因为它们会引发一些不易察觉的错误。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> drinks[] = &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;<span class="comment">//drinks[i] == *(drinks + i)</span></span><br><span class="line">doses[<span class="number">3</span>] == *(doses + <span class="number">3</span>) == *(<span class="number">3</span> + doses) == <span class="number">3</span>[doses]</span><br></pre></td></tr></table></figure><h3 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h3><p>指针之所以有类型，是因为编译器在指针算术运算时需要知道加几</p><p>如<code>int nums[] = &#123;1, 2, 3&#125;;</code>中<code>nums</code>与<code>nums+1</code>的地址间隔4个字节（如果int通常占4个字节）</p><ul><li>这里的数组内的每一个值都是int类型，都占4字节</li></ul><h3 id="scanf-vs-fgets"><a href="#scanf-vs-fgets" class="headerlink" title="scanf() vs fgets()"></a>scanf() vs fgets()</h3><p><code>scanf()</code>会导致缓冲区溢出,引发段错误（abort trap）,应限制<code>scanf()</code>读取字符串的长度</p><p><code>scanf()</code>不但允许输入多个字段，而且允许输入结构化数据，可以指定两个字段之间以什么字符分割</p><p>当<code>scanf()</code>用<code>%s</code>读取字符串时，遇到空格就会停止。如果想要输入多个单词，需要多次调用<code>scanf()</code>，或使用一些复杂的正则表达式技巧</p><p><code>fgets(char指针，sizeof(char指针),stdin)</code> stdin表示数据来自键盘</p><p><code>fgets()</code>缓冲区大小把<code>\0</code>字符也算了进去，所以不必像<code>scanf()</code>那样把长度减1</p><p>如果要向<code>fgets()</code>函数传递数组变量，就用<code>sizeof</code>，如果只是传指针，就应该输入想要的长度。</p><p><code>fgets()</code>只允许向缓冲区中输入一个字符串，而且只能是字符串，不能是其他数据类型，只能有一个缓冲区</p><p><code>fgets()</code>总能读取整个字符串</p><p><strong>Conclusion</strong>:如果需要输入由多个字段构成的结构化数据，可以使用<code>scanf()</code>；而如果想要输入一个非结构化的字符串，<code>fgets()</code>将是不二之选</p><h3 id="cards-还是-cards"><a href="#cards-还是-cards" class="headerlink" title="cards[ ]还是*cards"></a>cards[ ]还是*cards</h3><p>字符串字面值保存在只读存储器中。如果想要修改字符串，需要在新的数组中创建副本。可以将char指针声明成为<code>const char *</code>，以防代码用它修改字符串</p><h2 id="2-5-字符串原理"><a href="#2-5-字符串原理" class="headerlink" title="2.5 字符串原理"></a>2.5 字符串原理</h2><h3 id="创建数组的数组"><a href="#创建数组的数组" class="headerlink" title="创建数组的数组"></a>创建数组的数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> tracks[][<span class="number">80</span>] = &#123;<span class="comment">//第一对方括号用来访问由所有字符串组成的数组</span></span><br><span class="line">      <span class="comment">//第二对方括号用来访问每个单独的字符串</span></span><br><span class="line"><span class="string">&quot;I left my heart in Harvard Med School&quot;</span>,</span><br><span class="line"><span class="string">&quot;Newark, Newark - a wonderful town&quot;</span>,</span><br><span class="line"><span class="string">&quot;Dancing with a Dork&quot;</span>,</span><br><span class="line"><span class="string">&quot;From here to maternity&quot;</span>,</span><br><span class="line"><span class="string">&quot;The girl from Iwo Jima&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以用<code>char strings[...][...]</code>来创建数组的数组。<br>第一组方括号用来访问外层数组<br>第二组方括号用来访问每个内层数组中的元素</p><h3 id="使用string-h"><a href="#使用string-h" class="headerlink" title="使用string.h"></a>使用string.h</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="built_in">strcmp</span>()</span><br><span class="line">可以比较字符串</span><br><span class="line"><span class="built_in">strchr</span>()</span><br><span class="line">用来在字符串中找到某个字符的位置</span><br><span class="line"><span class="built_in">strlen</span>()</span><br><span class="line">可以得到字符串的长度</span><br><span class="line"><span class="built_in">strcpy</span>()</span><br><span class="line">可以复制字符串</span><br></pre></td></tr></table></figure><p>使用以上代码引用头文件</p><h3 id="使用strstr（）"><a href="#使用strstr（）" class="headerlink" title="使用strstr（）"></a>使用strstr（）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s0[] = <span class="string">&quot;dysfunctional&quot;</span>;</span><br><span class="line"><span class="type">char</span> s1[] = <span class="string">&quot;fun&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strstr</span>(s0, s1))</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;我在dysfunctional中找到fun了!&quot;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>全局变量位于任何函数之外，所有函数都可以调用它们。</p></blockquote><h3 id="指针的数组"><a href="#指针的数组" class="headerlink" title="指针的数组"></a>指针的数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *names_for_dog[] = &#123;<span class="string">&quot;Bowser&quot;</span>, <span class="string">&quot;Bonza&quot;</span>, <span class="string">&quot;Snodgrass&quot;</span>&#125;;</span><br><span class="line"><span class="comment">//可以像访问数组的数组那样访问指针的数组,一个字符串字面值配一个指针</span></span><br></pre></td></tr></table></figure><h2 id="3-小工具"><a href="#3-小工具" class="headerlink" title="3 小工具"></a>3 小工具</h2><p>小工具设计遵循以下原则：</p><ul><li>从标准输入读取数据</li><li>在标准输出显示数据</li><li>处理文本数据，而不是难以阅读的二进制格式</li><li>只做一件简单的事</li><li>如果想完成一个不同的任务，应该另外写一个小工具</li><li>小工具通常读写文本数据</li></ul><h3 id="过滤器（filter）"><a href="#过滤器（filter）" class="headerlink" title="过滤器（filter）"></a>过滤器（filter）</h3><p>这是一种小工具，它逐行读取数据，对数据进行处理，再把数据写到某个地方。如果你的计算机是Unix，或你在Windows上安装了Cygwin，就已经拥有很多过滤器工具了。</p><blockquote><p>head：显示文件前几行的内容<br>tail：显示文件最后几行的内容<br>sed：流编辑器（stream editor），用来搜索和替换文本</p></blockquote><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>可以重定向标准输入、标准输出，让程序从键盘以外的地方读数据、往显示器以外的地方写数据，如文件。可用命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./geo2json &lt; gpsdata.csv &gt; output.json</span><br></pre></td></tr></table></figure><h3 id="错误状态码"><a href="#错误状态码" class="headerlink" title="错误状态码"></a>错误状态码</h3><p>程序在数据中发现错误就会退出，并把退出状态置为2。怎么在程序结束后检查错误状态呢？</p><p>要看操作系统</p><p>如果你的计算机是Mac、Linux、其他UNIX，或你在Windows上使用Cygwin，可以用以下命令显示错误状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> $?</span><br></pre></td></tr></table></figure><p>如果用的是Windows的命令提示符，则可以输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt; <span class="built_in">echo</span> %ERRORLEVEL%</span><br></pre></td></tr></table></figure><p>这两条命令做了相同的事：显示程序结束时返回的那个数字。</p><h3 id="标准错误"><a href="#标准错误" class="headerlink" title="标准错误"></a>标准错误</h3><p>标准错误——一个用来发送错误消息的二号输出</p><p>人有两只耳朵和一张嘴，但进程有一只耳朵（标准输入）和两张嘴（标准输出和标准错误）</p><h3 id="fprintf-打印到数据流"><a href="#fprintf-打印到数据流" class="headerlink" title="fprintf()打印到数据流"></a>fprintf()打印到数据流</h3><p>printf()函数可以将数据发送到标准输出，但printf()只是fprintf()一个的特例</p><p>scanf()  fscanf(stdin, …)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;我喜欢乌龟！&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;我喜欢乌龟！&quot;</span>);</span><br><span class="line"><span class="comment">//以上命令等价</span></span><br></pre></td></tr></table></figure><p>stdout 标准输出</p><p>stderr  标准错误</p><p>stdin 标准输入</p><p><code>&gt;</code>重定向标准输出<code>&lt;</code>重定向标准输入<code>2&gt;</code>重定向标准错误</p><h3 id="用管道连接输入与输出"><a href="#用管道连接输入与输出" class="headerlink" title="用管道连接输入与输出"></a>用管道连接输入与输出</h3><p>符号 | 表示管道（pipe），它能连接一个进程的标准输出与另一个进程的标准输入</p><p><code>bermuda | geo2json</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; (./bermuda | ./geo2json) &lt; spooky.csv &gt; output.json</span><br></pre></td></tr></table></figure><p>只要在每个程序前加上一个<code>|</code>就可以连接多个程序，一连串相连的进程就叫流水线（pipeline），这时<code>&lt;</code>会把文件内容发送到流水线中第一个进程的标准输入，<code>&gt;</code>会捕获流水线中最后一个进程的标准输出</p><p>外面的括号是必需的,这对括号保证了数据文件由bermuda程序的标准输入来读取</p><h3 id="创建自己的数据流"><a href="#创建自己的数据流" class="headerlink" title="创建自己的数据流"></a>创建自己的数据流</h3><p>每条数据流用一个指向文件的指针来表示，可以用<code>fopen()</code>函数创建新数据流</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FILE *in_file = fopen(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);<span class="comment">//将创建一条数据流，从文件中读取数据</span></span><br><span class="line">FILE *out_file = fopen(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);<span class="comment">//将创建一条数据流，向文件写数据</span></span><br></pre></td></tr></table></figure><p>fopen()函数接收两个参数：文件名和模式。共有三种模式</p><p>“w”&#x3D; 写（write）写文件<br>“r”&#x3D; 读（read）读文件<br>“a”&#x3D; 追加（append）在文件末尾追加数据</p><p>创建数据流后，可以用fprintf()往数据流中打印数据<br>可以用fscanf()函数从文件中读取数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(out_file, <span class="string">&quot;%s 和 %s &quot;</span>, <span class="string">&quot;红 &quot;</span>, <span class="string">&quot;绿&quot;</span>);</span><br><span class="line"><span class="built_in">fscanf</span>(in_file, <span class="string">&quot;%79[^\n]\n&quot;</span>, sentence);</span><br></pre></td></tr></table></figure><p>最当用完数据流，别忘了关闭它。虽然所有的数据流在程序结束后都会自动关闭，但你仍应该自己关闭它们</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fclose(in_file);</span><br><span class="line">fclose(out_file);</span><br></pre></td></tr></table></figure><p>通常情况下，一个进程最多可以有256条数据流。但数据流的数量是有限的，用完后应该关闭它们。</p><p>最早FILE是用宏定义的，而宏的名字通常都要大写。</p><h3 id="首选项"><a href="#首选项" class="headerlink" title="首选项"></a>首选项</h3><p>对GUI程序来说，可以修改程序的首选项；而对于categorize这样的命令行程序，可以传给它命令行参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">.... 做事情....</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>main()函数有两个版本，一个有命令行参数，一个没有。命令行参数通过两个变量传递给main()函数，一个是参数的计数（argc），另一个是指针（指向参数字符串）数组</p><p>用户运行程序时，命令行中第一个参数是程序名。也就是说，第一个命令行参数其实是argv[1]</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;./categorize mermaid mermaid.csv Elvis elvises.csv the_rest.csv</span><br><span class="line">   argv[0] argv[1]...argv[5]</span><br></pre></td></tr></table></figure><p>在程序中打开文件准备读写时，最好检查一下有没有错误发生。好在如果数据流打开失败，fopen()函数会返回0，也就是说如果想检查错误，可以将下面这段代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE *in = fopen(<span class="string">&quot;我不存在.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br></pre></td></tr></table></figure><p>改成这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FILE *in;</span><br><span class="line"><span class="keyword">if</span> (!(in = fopen(<span class="string">&quot;我不存在.txt&quot;</span>, <span class="string">&quot;r&quot;</span>))) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;无法打开文件.\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用库-getopt"><a href="#使用库-getopt" class="headerlink" title="使用库 getopt()"></a>使用库 getopt()</h3><p>unistd.h头文件不属于C标准库，而是POSIX库中的一员。POSIX的目标是创建一套能够在所有主流操作系统上使用的函数。</p><p>getop()使用范例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; rocket_to -e 4 -a Brasilia Tokyo London</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">while</span> ((ch = getopt(argc, argv, <span class="string">&quot;ae:&quot;</span>)) != EOF)</span><br><span class="line"><span class="comment">//ae:告诉getopt()函数“a和e是有效选项”，e后面的冒号表示“-e后面需要再跟一个参数”，getopt()会用optarg变量指向这个参数</span></span><br><span class="line"><span class="keyword">switch</span>(ch) &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">engine_count = optarg;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">argc -= optind;<span class="comment">//最后这两行用来跳过已读取的选项</span></span><br><span class="line">argv += optind;<span class="comment">//optind保存了“getopt()函数从命令行读取了几个选项”</span></span><br></pre></td></tr></table></figure><p>经过一番处理，0号参数不再是程序名了。argv[0]会指向选项后的第一个命令行参数。循环结束以后，为了让程序读取命令行参数，需要调整一下argv和argc变量，跳过所有选项。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; rocket_to -e 4 -a Brasilia  Tokyo   London</span><br><span class="line">argv[0]  argv[1]  argv[2]</span><br></pre></td></tr></table></figure><p>Tips：</p><ul><li>可以多个选项<code>abc:d</code></li><li>可以合并命令行里的选项，如：<code>-td now</code> 与 <code>-d now -t</code></li><li>可以改变选项之间顺序，因为我们用循环读取选项，所以 <code>-d now -t</code>、<code>-t -d now</code>、<code>-td now</code>都一样(</li><li>只要程序在命令行看到一个前缀为－值，就会把它当成选项处理，前提是它必须在命令行参数之前出现</li><li>为了避免歧义，可以用<code>--</code>隔开参数和选项，比如<code>set_temper-ature -c -- -4</code>。getopt()看到<code>--</code>就会停止读取选项，程序会把后面的内容当成普通的命令行参数读取</li></ul><h2 id="4-使用多个源文件"><a href="#4-使用多个源文件" class="headerlink" title="4 使用多个源文件"></a>4 使用多个源文件</h2><h3 id="简明数据类型指南"><a href="#简明数据类型指南" class="headerlink" title="简明数据类型指南"></a>简明数据类型指南</h3><ul><li>char<br>字符在计算机的存储器中以字符编码的形式保存，字符编码是一个数字，因此在计算机看来，A与数字65完全一样（ASCII码）</li><li>int<br>如果你要保存一个整数，通常可以使用int。不同计算机中int的大小不同，但至少应该有16位。一般而言，int可以保存几万以内的数字</li><li>long<br>但如果想保存一个很大的计数呢？long数据类型就是为此而生的。在某些计算机中，long的大小是int的两倍，所以可以保存几十亿以内的数字；但大部分计算机的long和int一样大，因为在这些计算机中int本身就很大。long至少应该有32位</li><li>float<br>float是保存浮点数的基本数据类型。平时你会碰到很多浮点数，比如一杯香橙摩卡冰乐有多少毫升，就可以用float保存</li><li>double<br>但如果想表示很精确的浮点数呢？如果想让计算结果精确到小数点以后很多位，可以使用double。double比float多占一倍空间，可以保存更大、更精确的数字</li></ul><blockquote><p>为什么把一个很大的数保存到short中会变成负数？</p><p>数字以二进制保存，二进制的100 000看起来像这样：<br>x &lt;- 0001 1000 0110 1010 0000<br>当计算机想把这个值保存到short时，发现只能保存2个字节，所以只保存了数字右半边：<br>y &lt;- 1000 0110 1010 0000<br>最高位是1的二进制有符号数会被当成负数处理，它等价于下面的十进制数：<br>-31072</p></blockquote><h3 id="使用类型转换临时转换数值的类型"><a href="#使用类型转换临时转换数值的类型" class="headerlink" title="使用类型转换临时转换数值的类型"></a>使用类型转换临时转换数值的类型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//float z = (float)x / (float)y;</span></span><br><span class="line"><span class="type">float</span> z = (<span class="type">float</span>)x / y</span><br><span class="line"><span class="comment">//如果编译器发现有整数在加、减、乘、除浮点数，会自动完成转换，因此可以减少代码中显式类型转换的次数：</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;z = %f\n&quot;</span>, z);</span><br></pre></td></tr></table></figure><h3 id="两个关键字"><a href="#两个关键字" class="headerlink" title="两个关键字"></a>两个关键字</h3><p>unsigned<br>用unsigned修饰的数值只能是非负数。由于无需记录负数，无符号数有更多的位可以使用，因此它可以保存更大的数。unsigned int可以保存0到最大值的数。这个最大值是int可以保存最大值的两倍左右。还有signed关键字，但你几乎从没见过，因为所有数据类型默认都是有符号的。<br><code>unsigned char c;</code></p><p>long<br>没错，你可以在数据类型前加long，让它变长。longint是加长版的int；long int可以保存范围更广的数字；long long比long更长；还可以对浮点数用long。(c99和c11支持long long)<br><code>long double d;</code></p><blockquote><p>%.2f把浮点数格式化为小数点后两位</p><p>%hi用来格式化short</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span> <span class="comment">//含有表示整型（比如int和char）大小的值</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;float.h&gt;</span> <span class="comment">//含有表示float和double类型大小的值</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The value of INT_MAX is %i\n&quot;</span>, INT_MAX);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The value of INT_MIN is %i\n&quot;</span>, INT_MIN);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;An int takes %z bytes\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The value of FLT_MAX is %f\n&quot;</span>, FLT_MAX);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The value of FLT_MIN is %.50f\n&quot;</span>, FLT_MIN);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;A float takes %z bytes\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">float</span>));</span><br><span class="line">    <span class="comment">//可把INT和FLT替换成CHAR（char）、DBL（double）、SHRT（short）或LNG（long）</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>位数是计算机能够处理的数值长度</p></blockquote><h3 id="声明与定义分离"><a href="#声明与定义分离" class="headerlink" title="声明与定义分离"></a>声明与定义分离</h3><p><code>float add_with_tax()(float f);</code></p><p>声明只是一个函数签名：一条包含函数名、形参类型与返回类型的记录</p><h3 id="创建头文件"><a href="#创建头文件" class="headerlink" title="创建头文件"></a>创建头文件</h3><p>两步</p><ol><li>创建一个扩展名为.h的文件，把你的声明写在里面，不用在头文件中包含main()函数，反正也没有函数会调用它</li><li>在主代码中包含头文件，应该在代码的顶部加一句include</li></ol><p><code>#include &#39;asdf.h&#39;</code> <code>#include &lt;stdio.h&gt;</code></p><p>通常情况下，引号表示以相对路径查找头文件，如果不加目录名，只包含一个文件名，编译器就会在当前目录下查找头文件；如果用了尖括号，编译器就会以绝对路径查找头文件</p><p>当编译器看到尖括号，就会到标准库代码所在目录查找头文件，但现在你的头文件和.c文件在同一目录下，用引号把文件名括起来，编译器就会在本地查找文件。本地头文件也可以带目录名，但通常会把它和C文件放在相同目录中。</p><p>当编译器在代码中读到#include，就会读取头文件中的内容，仿佛它们本来就在代码中。</p><blockquote><p>如果编译器发现你调用了一个它没见过的函数，就会假设这个函数返回int</p></blockquote><h3 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h3><table><thead><tr><th align="center">1</th><th align="center">2</th><th align="center">3</th></tr></thead><tbody><tr><td align="center">auto</td><td align="center">if</td><td align="center">break</td></tr><tr><td align="center">int</td><td align="center">case</td><td align="center">long</td></tr><tr><td align="center">char</td><td align="center">register</td><td align="center">continue</td></tr><tr><td align="center">return</td><td align="center">default</td><td align="center">short</td></tr><tr><td align="center">do</td><td align="center">sizeof</td><td align="center">double</td></tr><tr><td align="center">static</td><td align="center">else</td><td align="center">struct</td></tr><tr><td align="center">entry</td><td align="center">switch</td><td align="center">extern</td></tr><tr><td align="center">typeof</td><td align="center">float</td><td align="center">union</td></tr><tr><td align="center">for</td><td align="center">unsigned</td><td align="center">goto</td></tr><tr><td align="center">while</td><td align="center">enum</td><td align="center">void</td></tr><tr><td align="center">const</td><td align="center">signed</td><td align="center">volatile</td></tr></tbody></table><h3 id="共享代码"><a href="#共享代码" class="headerlink" title="共享代码"></a>共享代码</h3><p>为了共享代码，可以把代码放到一个单独的C文件中。<br>需要把函数声明放到一个单独的.h头文件中。<br>在所有需要使用共享代码的C文件中包含这个头文件。<br>在编译的命令中列出所有C文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//encrypt.h</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">encrypt</span><span class="params">(<span class="type">char</span> *message)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//encrypt.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;encrypt.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">encrypt</span><span class="params">(<span class="type">char</span> *message)</span>&#123;</span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="keyword">while</span> (*message) &#123;</span><br><span class="line">*message = *message ^ <span class="number">31</span>;</span><br><span class="line">message++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mainprog.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;encrypt.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">char</span> msg[<span class="number">80</span>];</span><br><span class="line"><span class="keyword">while</span> (fgets(msg, <span class="number">80</span>, <span class="built_in">stdin</span>)) &#123;</span><br><span class="line">encrypt(msg);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, msg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ gcc message_hider.c encrypt.c -o message_hider</span><br></pre></td></tr></table></figure><blockquote><p>共享变量<br>为了防止两个源文件中的同名变量相互干扰，变量的作用域仅限于某个文件内。如果你想共享变量，就应该在头文件中声明，并在变量名前加上extern关键字：<br><code>extern int passcode;</code></p></blockquote><h3 id="gccの编译"><a href="#gccの编译" class="headerlink" title="gccの编译"></a>gccの编译</h3><p>gcc -c会编译代码，但不会链接目标文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ gcc -c *.c</span><br></pre></td></tr></table></figure><p>gcc -o 链接，在例子中把目标文件链接为一个叫launch的可执行程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ gcc *.o -o launch</span><br></pre></td></tr></table></figure><h3 id="Make"><a href="#Make" class="headerlink" title="Make"></a>Make</h3><p>如果你掌握了某样东西的简单规则，别多想，自动化它</p><p>make编译的文件叫目标（target）。目标可以是任何用其他文件生成的文件，也就是说目标可以是一批文件压缩而成的压缩文档</p><p>make需要知道：依赖项、生成方法。依赖项和生成方法合在一起构成了一条规则。有了规则，make就知道如何生成目标</p><blockquote><p>versions :</p><p>UNIX make</p><p>MinGW mingw32-make</p><p>Microsoft  NMAKE</p></blockquote><p>makefile文件书写</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">launch.o: launch.c launch.h thruster.h//目标：依赖项</span></span><br><span class="line">gcc -c launch.c//生成方法（必须以tab开头）</span><br><span class="line">//这是规则</span><br><span class="line"><span class="section">thruster.o: thruster.h thruster.c</span></span><br><span class="line">gcc -c thruster.c</span><br><span class="line"><span class="section">launch: launch.o thruster.o</span></span><br><span class="line">gcc launch.o thruster.o -o launch</span><br></pre></td></tr></table></figure><p>之后直接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ make launch</span><br></pre></td></tr></table></figure><blockquote><p>更自动化的工具：autoconf</p></blockquote><p>-&gt; <a href="http://tinyurl.com/yczmjx">GUN Make Manual</a></p><h2 id="5-结构、联合与位字段"><a href="#5-结构、联合与位字段" class="headerlink" title="5 结构、联合与位字段"></a>5 结构、联合与位字段</h2><h3 id="结构-Struct"><a href="#结构-Struct" class="headerlink" title="结构 Struct"></a>结构 Struct</h3><p>结构化数据结构 structured data type</p><p>结构是一种由一系列其他数据类型组成的数据类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fish</span> &#123;</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *species;</span><br><span class="line"><span class="type">int</span> teeth;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>创建一个新自定义的数据类型，由其它一批数据组成。</p><ul><li>结构的大小固定</li><li>结构中的数据都有名字</li></ul><p>创建数据：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fish</span> <span class="title">snappy</span> =</span> &#123;<span class="string">&quot;Snappy&quot;</span>, <span class="string">&quot;Piranha&quot;</span>, <span class="number">69</span>, <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure><p>把参数封装在结构中，代码会更稳定</p><p>结构变量是结构本身的名字</p><p>读取时只能按名访问，使用“.”运算符读取结构字段：&lt;结构&gt;.&lt;字段名&gt;语法（也叫“点表示法”）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fish</span> <span class="title">snappy</span> =</span> &#123;<span class="string">&quot;Snappy&quot;</span>, <span class="string">&quot;piranha&quot;</span>, <span class="number">69</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Name = %s\n&quot;</span>, snappy.name);</span><br></pre></td></tr></table></figure><p>为结构变量赋值相当于叫计算机复制数据</p><h3 id="结构中的结构"><a href="#结构中的结构" class="headerlink" title="结构中的结构"></a>结构中的结构</h3><p>为什么要嵌套定义结构？</p><p>之所以要这么做是为了对抗复杂性 。通过使用结构，我们可以建立更大的数据块。通过把结构组合在一起，我们可以创建更大的数据结构。本来你只能用int、short，但有了结构以后，就可以描述十分复杂的东西，比如网络流和视频图像。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">preferences</span> &#123;</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *food;</span><br><span class="line"><span class="type">float</span> exercise_hours;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fish</span> &#123;</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *species;</span><br><span class="line"><span class="type">int</span> teeth;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">preferences</span> <span class="title">care</span>;</span> <span class="comment">//nesting 嵌套</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">fish</span> <span class="title">snappy</span> =</span> &#123;<span class="string">&quot;Snappy&quot;</span>, <span class="string">&quot;Piranha&quot;</span>, <span class="number">69</span>, <span class="number">4</span>, &#123;<span class="string">&quot;Meat&quot;</span>, <span class="number">7.5</span>&#125;&#125;;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Snappy 喜欢吃 %s&quot;</span>, snappy.care.food);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Snappy 喜欢锻炼 %f hours&quot;</span>, snappy.care.exercise_hours); <span class="comment">//访问</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h3><p>在C语言中可以为结构创建别名，你只要在struct关键字前加上typedef，并在右花括号后写上类型名，就可以在任何地方使用这种新类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cell_phone</span> &#123;</span></span><br><span class="line"><span class="type">int</span> cell_no;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *wallpaper;</span><br><span class="line"><span class="type">float</span> minutes_of_charge;</span><br><span class="line">&#125; phone;</span><br></pre></td></tr></table></figure><p>当你用typedef为结构创建别名，需要决定别名叫什么。别名其实就是类型名，也就是说结构有两个名字：一个是结构名（struct cell_phone），另一个是类型名（phone）。为什么要有两个名字？一般一个就够了。如果只写类型名而不写结构名，编译器也没意见：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="type">int</span> cell_no;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *wallpaper;</span><br><span class="line"><span class="type">float</span> minutes_of_charge;</span><br><span class="line">&#125; phone;</span><br><span class="line">phone p = &#123;<span class="number">5557879</span>, <span class="string">&quot;s.png&quot;</span>, <span class="number">1.35</span>&#125;;</span><br></pre></td></tr></table></figure><p>这样的结构称为匿名结构。</p><h3 id="更新结构"><a href="#更新结构" class="headerlink" title="更新结构"></a>更新结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fish snappy = &#123;<span class="string">&quot;Snappy&quot;</span>, <span class="string">&quot;piranha&quot;</span>, <span class="number">69</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello %s\n&quot;</span>, snappy.name);</span><br><span class="line">snappy.teeth = <span class="number">68</span>;</span><br></pre></td></tr></table></figure><p>计算机通过把值赋给函数形参的方式向函数传值，所有赋值都会复制</p><p>如果想让函数更新结构变量，就不能把结构作为参数传递，因为这样做仅仅是将数据的副本复制给<br>了函数。取而代之，可以传递结构的地址</p><p>还有一种表示结构指针的方法，它更易于阅读。</p><p><code>(*t).age</code> 和 <code>t-&gt;age</code> 等价</p><p>“指针-&gt;字段”等于“(*指针).字段”“-&gt;”表示法省掉了括号，代码更易阅读。</p><h3 id="联合？"><a href="#联合？" class="headerlink" title="联合？"></a>联合？</h3><p>每次创建结构实例，计算机都会在存储器中相继摆放字段</p><p>联合则不同。当定义联合时，计算机只为其中一个字段分配空间，并且计算机会为其中最大的字段分配空间，然后由你决定里面保存什么值</p><blockquote><p>计算机需要保证联合的大小固定。唯一的办法就是让它足够大，任何一个字段都能装得下</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> &#123;</span><span class="comment">//这里的关键字是union</span></span><br><span class="line"><span class="type">short</span> count;</span><br><span class="line"><span class="type">float</span> weight;</span><br><span class="line"><span class="type">float</span> volume;</span><br><span class="line">&#125; quantity;</span><br></pre></td></tr></table></figure><h3 id="使用联合"><a href="#使用联合" class="headerlink" title="使用联合"></a>使用联合</h3><ul><li><p>C89 方式</p><p>把值赋给联合中第一个字段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quantity q = &#123;<span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure></li><li><p>指定初始化器（designated initializer）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quantity q = &#123; .weight = <span class="number">1.5</span> &#125;;</span><br></pre></td></tr></table></figure></li><li><p>点 表示法</p><p>在第一行创建变量，然后在第二行设置字段的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">quantity q;</span><br><span class="line">q.volume = <span class="number">3.7</span>;</span><br></pre></td></tr></table></figure></li></ul><p>无论用哪种方法设置联合的值，都只会保存一条数据。联合只是提供了一种创建支持不同数据类型的变量的方法</p><p>“指定初始化器”也可以用来设置结构字段的初值，并提高代码的可读性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *color;</span><br><span class="line"><span class="type">int</span> gears;</span><br><span class="line"><span class="type">int</span> height;</span><br><span class="line">&#125; bike;</span><br><span class="line"></span><br><span class="line">bike b = &#123;.height=<span class="number">17</span>, .gears=<span class="number">21</span>&#125;;</span><br></pre></td></tr></table></figure><h3 id="联合与结构"><a href="#联合与结构" class="headerlink" title="联合与结构"></a>联合与结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name ;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *country;</span><br><span class="line">    quantity amount;</span><br><span class="line">&#125; fruit_order;</span><br><span class="line"></span><br><span class="line">fruit_order apples = &#123;<span class="string">&quot;apples&quot;</span>,<span class="string">&quot;English&quot;</span>,.amount.weight = <span class="number">4.2</span>&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;This order contains %2.2f lbs of %s\n&quot;</span>,apples.amount.weight, apples.name);</span><br></pre></td></tr></table></figure><h3 id="枚举变量保存符号"><a href="#枚举变量保存符号" class="headerlink" title="枚举变量保存符号"></a>枚举变量保存符号</h3><p>你需要某种方法记录我们在联合中保存了什么值。</p><p>结构与联合用分号（;）来分割数据项，而枚举用逗号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">colors</span> &#123;</span>RED, GREEN, PUCE&#125;;<span class="comment">//可以用typedef为类型起个名字</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">colors</span> <span class="title">favorite</span> =</span> PUCE;</span><br></pre></td></tr></table></figure><p><em><strong>so？枚举好处？？？</strong></em> 限制我能给的值？ 实例感受下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    COUNT,</span><br><span class="line">    POUNDS,</span><br><span class="line">    PINTS</span><br><span class="line">&#125;unit_of_measure;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *country;</span><br><span class="line">    quantity amount;</span><br><span class="line">    unit_of_measure units;</span><br><span class="line">&#125;fruit_order;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">display</span><span class="params">(fruit_order order)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This order contains &quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (order.units==PINTS) <span class="built_in">printf</span>(<span class="string">&quot;%2.2f pints of %s\n&quot;</span>, order.amount.volume, order.name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (order.units==POUNDS) <span class="built_in">printf</span>(<span class="string">&quot;%2.2f lbs of %s\n&quot;</span>, order.amount.weight, order.name);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%i %s\n&quot;</span>, order.amount.count, order.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    fruit_order strawberries= &#123;</span><br><span class="line">        <span class="string">&quot;strawberries&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Spain&quot;</span>,</span><br><span class="line">        .amount.weight=<span class="number">17.6</span>,</span><br><span class="line">        POUNDS</span><br><span class="line">    &#125;;</span><br><span class="line">    display(strawberries);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="位字段（bitfield）"><a href="#位字段（bitfield）" class="headerlink" title="位字段（bitfield）"></a>位字段（bitfield）</h3><p>C语言不支持二进制字面值，不过它支持十六进制字面值。每当C语言看到0x开头的数字，就认为它是以16为基数的数字（0x54）</p><p>可以用位字段指定一个字段有多少位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> low_pass_vcf:<span class="number">1</span>;<span class="comment">//位字段应当声明为unsigned int</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> filter_coupler:<span class="number">1</span>;<span class="comment">//表示该字段只使用1位存储空间</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> reverb:<span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> sequential:<span class="number">4</span>;</span><br><span class="line">...</span><br><span class="line">&#125; synth;</span><br></pre></td></tr></table></figure><p>如果你有一连串的位字段，计算机会放在一起，以节省空间，也就是说如果有8个1位的位字段，计算机就会把它们保存在一个字节中</p><p>如果编译器发现结构中只有一个位字段，还是会把它填充成一个字，这就是为什么位字段总是组合在一起</p><h2 id="6-数据结构与动态存储"><a href="#6-数据结构与动态存储" class="headerlink" title="6 数据结构与动态存储"></a>6 数据结构与动态存储</h2><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>保存可变数量的数据，插入数据非常快</p><p>链表是一种抽象数据结构。链表是通用的，可以用来保存很多不同类型的数据</p><p>链表保存了一条数据和一个链向另一条数据的链接</p><p>如果一个结构包含一个链向同种结构的链接，那么这个结构就被称为递归结构</p><p>只要在结构中保存指针，island数据就含有下一个我们将游览的island的地址。只要我们的代码能访问一个island，就能够跳到下一个island。</p><p>在递归结构中，需要包含一个相同类型的指针， C语言的语法不允许用typedef别名来声明它，因此必须为结构起一个名字</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">island</span> &#123;</span></span><br><span class="line"><span class="type">char</span> *name;</span><br><span class="line"><span class="type">char</span> *opens;</span><br><span class="line"><span class="type">char</span> *closes;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">island</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; island;</span><br><span class="line"></span><br><span class="line">island amity = &#123;<span class="string">&quot;Amity&quot;</span>, <span class="string">&quot;09:00&quot;</span>, <span class="string">&quot;17:00&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">island craggy = &#123;<span class="string">&quot;Craggy&quot;</span>, <span class="string">&quot;09:00&quot;</span>, <span class="string">&quot;17:00&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">island isla_nublar = &#123;<span class="string">&quot;Isla Nublar&quot;</span>, <span class="string">&quot;09:00&quot;</span>, <span class="string">&quot;17:00&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">island shutter = &#123;<span class="string">&quot;Shutter&quot;</span>, <span class="string">&quot;09:00&quot;</span>, <span class="string">&quot;17:00&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line"></span><br><span class="line">amity.next = &amp;craggy;</span><br><span class="line">craggy.next = &amp;isla_nublar;</span><br><span class="line">isla_nublar.next = &amp;shutter;</span><br><span class="line"></span><br><span class="line">\\插入数据</span><br><span class="line">island skull = &#123;<span class="string">&quot;Skull&quot;</span>, <span class="string">&quot;09:00&quot;</span>, <span class="string">&quot;17:00&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">isla_nublar.next = &amp;skull;</span><br><span class="line">skull.next = &amp;shutter;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">display</span><span class="params">(island *start)</span>&#123;</span><br><span class="line">    island *i = start;</span><br><span class="line">    <span class="keyword">for</span>(; i != <span class="literal">NULL</span>; i = i-&gt;next)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Name:%s\n open:%s-%s\n&quot;</span>,i-&gt;name,i-&gt;open,i-&gt;closes);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在C语言中，NULL的值实际上为0，NULL专门用来把某个指针设为0。</p><p>想快速地插入数据，就需要<strong>链表</strong>。想直接访问元素，就应该用<strong>数组</strong></p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>栈是存储器用来保存局部变量的区域。数据保存在局部变量中，一旦离开函数，变量就会消失。堆是程序中用来保存长期使用数据的地方。堆上的数据不会自动清除，因此堆是保存数据结构的绝佳场所</p><h3 id="malloc-与-free"><a href="#malloc-与-free" class="headerlink" title="malloc() 与 free()"></a>malloc() 与 free()</h3><p><code>malloc()</code>，memory allocation 申请储存器。接收一个参数：所需要的字节数。常与<code>sizeof</code>一起使用。<code>sizeof</code>告知某种数据类型在系统中占了多少字节。这种数据类型可以是结构，也可以是int或double这样的基本数据类型。返回一个指针，指针中保存了存储器块的起始地址。<code>free()</code>需要接收<code>malloc()</code>创建的存储器的地址。只要告诉C标准库存储器块从哪里开始，它就能查阅记录，知道要释放多少存储器。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span><span class="comment">//使用malloc()和free()需要包含这个头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(island));</span><br><span class="line">island *p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(island));<span class="comment">//返回的通用指针，即void*类型</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(p);</span><br></pre></td></tr></table></figure><p>虽然程序结束以后，所有堆空间会自动释放，但用free()显式释放创建的所有动态存储器是一种好的做法</p><h3 id="字符串复制"><a href="#字符串复制" class="headerlink" title="字符串复制"></a>字符串复制</h3><p><code>string.h</code>的头文件中有一个函数<code>strdup()</code>。它可以把字符串复制到堆上</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *s = <span class="string">&quot;MONA LISA&quot;</span></span><br><span class="line"><span class="type">char</span> *copy = strdup(s);</span><br></pre></td></tr></table></figure><p>作用机理为： 计算出字符串的长度，然后调用malloc()函数在堆上分配相应的空间。再把所有字符复制到堆上的新空间。</p><p>strdup()总是在堆上创建空间，而不是在栈上，因为栈用来保存局部变量，而局部变量很快就会被清除。</p><p>并且因为strdup()把新字符串放在堆上，所以千万记得要用free()函数释放空间。</p><p>有了动态分配存储器，就能在运行时创建需要的存储器。使用malloc()与free()，可以访问动态堆存储器。</p><h3 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h3><p>一些语言会跟踪程序在堆上分配的数据，当程序不再使用这些数据时，就会释放它们。</p><p>C语言非常古老，发明它的时候，绝大多数语言都没有自动 “垃圾回收”机制。</p><p>操作系统会在程序结束时清除所有存储器。不过，还是应该显式释放你创建的每样东西，这是一种好的习惯。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>一些举例：</p><ul><li>关联数组（也叫映射）<ul><li>连接“键”（key）信息与“值”（value）信息。可以用来连接两种不同类型的数据。</li></ul></li><li>双向链表<ul><li>和普通链表很像，但双向连接，可以双向处理。</li></ul></li><li>链表<ul><li>可以用来保存一串数据项，并使插入新数据项变得简单，但只能沿着一个方向处理。</li></ul></li><li>二叉树<ul><li>每一项都与其他两项相连，可以用来保存层次信息。</li></ul></li></ul><h3 id="valgrind"><a href="#valgrind" class="headerlink" title="valgrind"></a>valgrind</h3><p>valgrind通过伪造malloc()可以监控分配在堆上的数据。当程序想分配堆存储器时，valgrind将会拦截对malloc()和free()的调用，然后运行自己的malloc()和free()。valgrind<br>的malloc()会记录调用它的是哪段代码和分配了哪段存储器。程序结束时，valgrind会汇报堆上有哪些数据，并告诉这些数据是由哪段代码创建的。</p><p>调试信息是编译时打包到可执行文件中的附加数据，比如某段代码在源文件中的行号。只要有调试信息，valgrind就能提供更多有助于发现存储器泄漏的信息。</p><p>为了在可执行文件中加入调试信息，需要加上-g开关，并重新编译源代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -g spies.c -o spies// -g 开关告诉编译器要记录要编译代码的行号</span><br></pre></td></tr></table></figure><p>存储器泄漏是C程序中最难发现的错误。</p><p>valgrind工具可以发现泄漏、定位泄漏、检验泄漏是否修复</p><h2 id="7-高级函数"><a href="#7-高级函数" class="headerlink" title="7 高级函数"></a>7 高级函数</h2><h3 id="向函数传递函数"><a href="#向函数传递函数" class="headerlink" title="向函数传递函数"></a>向函数传递函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sports_no_bieber</span><span class="params">(<span class="type">char</span> *s)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">strstr</span>(s, <span class="string">&quot;sports&quot;</span>) &amp;&amp; !<span class="built_in">strstr</span>(s, <span class="string">&quot;bieber&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>(*match)(<span class="type">char</span>*))</span>&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Search results:&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NUM_ADS; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (match(ADS[i])) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, ADS[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">find(sports_no_bieber);</span><br></pre></td></tr></table></figure><p>函数名是指向函数的指针，创建函数的同时也创建了一个同名函数指针，指针中保存了函数的地址，当调用函数时，你在使用函数指针。</p><blockquote><p>两者并不完全相同，函数名是L-value，而指针变量是R-value，因此函数名不能像指针变量那样自加或自减。</p></blockquote><p>函数有不同的返回类型和形参，所以它有许多不同的类型，没有<code>function*</code>的说法。</p><h3 id="创建函数指针"><a href="#创建函数指针" class="headerlink" title="创建函数指针"></a>创建函数指针</h3><p>需要把函数的返回类型和接收参数类型告诉C编译器。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*warp_fn)(<span class="type">int</span>);</span><br><span class="line">warp_fn = go_to_warp_speed;</span><br><span class="line"><span class="comment">//创建一个叫warp_fn的变量，用来保存go_to_warp_speed()函数的地址。相当于调go_to_warp_speed(4)</span></span><br><span class="line">warp_fn(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>** (*names_fn)(<span class="type">char</span>*,<span class="type">int</span>);</span><br><span class="line">names_fn = album_names;</span><br><span class="line"><span class="comment">//创建一个叫names_fn的变量，用来保存album_names()函数的地址。</span></span><br><span class="line"><span class="type">char</span>** results = names_fn(<span class="string">&quot;Sacha Distel&quot;</span>, <span class="number">1972</span>);</span><br></pre></td></tr></table></figure><p>一旦声明了函数指针变量，就可以像其他变量一样使用它，可以对它赋值，也可以把它加到数组中，还可以把它传给函数</p><blockquote><p>char**是一个指针，通常用来指向字符串数组</p></blockquote><p>函数指针是C语言最强大的特性之一</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>** (*names_fn)(<span class="type">char</span>*,<span class="type">int</span>)</span><br><span class="line">返回类型       指针变量    参数类型</span><br><span class="line">    在这里声明形参的名称</span><br></pre></td></tr></table></figure><blockquote><p><code>match(ADS[i])</code>可以换成<code>(*match)(ADS[i])</code></p><p><code>find(sports_or_workout)</code>可以写成<code>find(&amp;sports_or_workout)</code></p><p>即使省略*和&amp;，C编译器也能识别它们，这样代码更好读</p></blockquote><h3 id="排序qsort"><a href="#排序qsort" class="headerlink" title="排序qsort()"></a>排序qsort()</h3><blockquote><p>void指针(void *)可以保存任何类型数据的地址，但使用前必须把它转换为具体类型</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">qsort(<span class="type">void</span> *<span class="built_in">array</span>, <span class="type">size_t</span> length, <span class="type">size_t</span> item_size, <span class="type">int</span> (*compar)(<span class="type">const</span> <span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *));</span><br><span class="line"><span class="comment">//qsort(数组指针，数组长度，数组中每个元素长度，比较器函数指针（参数）)</span></span><br></pre></td></tr></table></figure><p>比较器会返回给qsort()三种值</p><p>如果第一个值比第二个值大，就返回正数；如果第一个值比第二个值小，就返回负数；如果两个值相等，就返回0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">compare_scores</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* score_a, <span class="type">const</span> <span class="type">void</span>* score_b)</span>&#123;</span><br><span class="line"><span class="type">int</span> a = *(<span class="type">int</span>*)score_a;</span><br><span class="line"><span class="type">int</span> b = *(<span class="type">int</span>*)score_b;<span class="comment">//这样将void指针转换为整型指针</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符串是字符指针，指向字符串的指针是指针的指针（绕口令哈哈哈）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">compare_names</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* a, <span class="type">const</span> <span class="type">void</span>* b)</span>&#123;</span><br><span class="line"><span class="type">char</span>** sa = (<span class="type">char</span>**)a;</span><br><span class="line"><span class="type">char</span>** sb = (<span class="type">char</span>**)b;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">strcmp</span>(*sa, *sb); <span class="comment">//需要用*来取得字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建函数指针数组"><a href="#创建函数指针数组" class="headerlink" title="创建函数指针数组"></a>创建函数指针数组</h3><p>如果想在数组中保存函数，就必须告诉编译器函数的具体特征：函数返回什么类型以及接收什么参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> (*replies[])(response) = &#123;dump, second_chance, marriage&#125;;</span><br><span class="line"><span class="comment">//返回类型（*指针变量）（参数类型）</span></span><br></pre></td></tr></table></figure><blockquote><p>C语言在创建枚举时会给每个符号分配一个从0开始的数字</p></blockquote><p>函数指针数组让代码易于管理，它们让代码变得更短、更易于扩展，从而可以伸缩</p><h3 id="可变参数函数"><a href="#可变参数函数" class="headerlink" title="可变参数函数"></a>可变参数函数</h3><p>参数数量可变的函数被称为可变参数函数。C标准库<code>stdarg.h</code>中有一组宏（macro）可以帮助建立可变参数函数</p><blockquote><p>可以把宏想象成一种特殊类型的函数，它可以修改源代码</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">\\打印一连串<span class="type">int</span>函数</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_ints</span><span class="params">(<span class="type">int</span> args, ...)</span>&#123;\\在C语言中，函数参数后的省略号“…”表示还有更多参数</span><br><span class="line">va_list ap;\\保存传给函数的其他参数</span><br><span class="line">va_start(ap, args);    \\需要把最后一个普通参数写明(至少需要一个普通参数)</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; args; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;argument: %i\n&quot;</span>, va_arg(ap, <span class="type">int</span>));\\用va_arg读取保存在va_list中的参数</span><br><span class="line">&#125;</span><br><span class="line">va_end(ap);   \\当读完了所有参数，要用va_end宏来让C结束</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>va_arg接收两个值：va_list和要读取参数的类型。本例中所有参数都是int</p><p>宏用来在编译前重写代码，这里的几个宏<code>va_start</code>、<code>va_arg</code>和<code>va_end</code>看起来很像函数，但实际上隐藏在它们背后的是一些神秘的指令。在编译前，预处理器会根据这些指令在程序中插入巧妙的代码</p></blockquote><ul><li>va_arg 会返回下一个额外参数，那么一定要搭配循环遍历吗？🤔</li></ul><h2 id="8-静态库与动态库"><a href="#8-静态库与动态库" class="headerlink" title="8 静态库与动态库"></a>8 静态库与动态库</h2><h3 id="库文件引用"><a href="#库文件引用" class="headerlink" title="库文件引用"></a>库文件引用</h3><p>&lt;stdio.h&gt;尖括号代表标准头文件，编译器就会在标准头文件目录中查找文件</p><p>“encrypt.h”引号代表本地头文件，与程序在同一目录中</p><blockquote><p>通常类UNIX操作系统（如Mac或Linux）中，编译器会在以下目录查找头文件：<br>&#x2F;usr&#x2F;local&#x2F;include<br>&#x2F;usr&#x2F;include</p><p>如果是MinGW版的gcc，编译器会在\MinGW\include中查找</p></blockquote><h3 id="共享代码-1"><a href="#共享代码-1" class="headerlink" title="共享代码"></a>共享代码</h3><p>会希望在程序之间共享两类代码：.h头文件和.o目标文件</p><h4 id="h头文件"><a href="#h头文件" class="headerlink" title=".h头文件"></a>.h头文件</h4><ol><li><p>把头文件保存在标准目录中</p><p>可以在源代码中用尖括号包含它们</p></li><li><p>在include语句中使用完整路径名</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&quot;/my_header_files/encrypt.h&quot;</span></span></span><br></pre></td></tr></table></figure></li><li><p>告诉编译器去哪找头文件</p><p>可以使用gcc的<code>-I</code>选项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -I/my_header_files test_code.c  ...   -o test_code</span><br></pre></td></tr></table></figure></li></ol><p>编译器会先检查<code>-I</code>选项中的目录，然后像往常一样检查所有标准目录</p><h4 id="o目标文件"><a href="#o目标文件" class="headerlink" title=".o目标文件"></a>.o目标文件</h4><p>可以把.o目标文件放在一个类似共享目录的地方，用完整路径名共享</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -I/my_header_files test_code.c</span><br><span class="line">   /my_object_files/encrypt.o</span><br><span class="line">   /my_object_files/checksum.o -o test_code</span><br></pre></td></tr></table></figure><h4 id="存档"><a href="#存档" class="headerlink" title="存档"></a>存档</h4><p>把一批目标文件打包在一起就成了存档文件。只要创建目标文件存档，就可以一次告诉编译器一<br>批目标文件</p><p>可以使用<code>nm</code>命令查看存档中的内容，列出存档中保存文件的名字</p><p>可以使用<code>ar</code>命令来存档</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ar -rcs libhfsecurity.a encrypt.o checksum.o</span><br></pre></td></tr></table></figure><p>参数r表示如果.a文件存在就更新它，参数c表示创建存档时不显示反馈信息，参数s表示需要ar在.a文件开头建立索引。接着是.a文件的文件名，以及需要存档的文件</p><p>所有.a文件名都是libXXX.a的形式。这是命名存档的标准方式，存档是静态库（static library），所以要以lib开头，否则编译器找不到它们</p><p>接着可以把存档保存在库目录中，并不同情况下进行编译</p><ol><li><p>把.a文件保存在标准目录中，如&#x2F;usr&#x2F;local&#x2F;lib</p><p>确保代码能正确运行之后会把存档安装在标准目录，这个目录专门用来放本地自定义库</p><p>用-I开关编译代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc test_code.c -lhfsecurity -o test_code</span><br></pre></td></tr></table></figure></li><li><p>把.a文件放在其他目录中</p><p>如果还处于开发阶段，或者在系统目录中安装代码不合适，也可以创建自己的库目录<code>/my_lib</code></p><p>用-L选项告诉编译器去哪找存档</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc test_code.c -L/my_lib -lhfsecurity -o test_code</span><br></pre></td></tr></table></figure></li></ol><p>如果要使用多个存档，可以设置多个-l选项，<code>hfsecurity</code>叫编译器去找一个叫<code>libhfsecurity.a</code>的存档，-l选<br>项后的名字必须与存档名的一部分匹配，如果存档叫libawesome.a，可以用-lawesome开关编译程序</p><blockquote><p>不同机器库目录的内容可以相差很多。因为不同操作系统提供了不同的服务。每个.a文件都是一个独立的库，有的库用来连接网络，有的用来创建GUI程序</p><p>找几个.a文件来试用一下nm命令。每个模块都列出了很多名字，它们是一些已经编译好了的函数，可以在程序中使用它们：0000000000000000 T _yywrap，T代表文本(Text)，说明这是一个函数，函数名为yywrap</p><p>nm命令会告诉你每个.o目标文件的名字，然后列出所有目标文件中的名字，如果某个名字前出现了T，就说明它是目标文件中某个函数的名字</p></blockquote><h3 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h3><p>带有元信息的可重定位目标文件，由一个或多个.o文件创建，核心是一段目标代码</p><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>首先创建目标文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -I/includes -fPIC -c hfcal.c -o hfcal.o</span><br></pre></td></tr></table></figure><p><code>-fPIC</code>表示创建位置无关代码。有的操作系统和处理器要用位置无关代码创建库，这样它们才能在运行时决定把代码加载到存储器的哪个位置，事实上在大多数操作系统中都不需要加这个选择</p><blockquote><p><strong>位置无关代码</strong></p><p>位置无关代码就是无论计算机把它加载到存储器的哪个位置都可以运行的代码。想象你有一个动态库，它要使用加载点500个字节以外的某个全局变量的值，那么如果操作系统把库加载到其他地方就会出错。只要让编译器创建位置无关的代码，就可以避免这种问题。<br>包括Windows在内的一些操作系统在加载动态库时会使用一种叫存储器映射的技术，也就是说所有代码其实都是位置无关的。若你在Windows上用刚刚那条命令编译代码，gcc可能会给出一条警告，告诉你不需要-fPIC选项。你既可以奉命删除它，也可以当作没看见。</p></blockquote><p>然后生成动态库</p><p>绝大部分操作系统都支持动态库，它们的工作方式也大抵相同，但称呼却大相径庭</p><p>Windows 动态链接库；Linux和Unix 共享目标文件；Mac 动态库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -shared hfcal.o -oC:\libs\hfcal.dll//Windows 上的MinGW</span><br><span class="line">   /libs/libhfcal.dll.a   //Windows上的Cygwin</span><br><span class="line">   /libs/libhfcal.so      //Linux或Unix</span><br><span class="line">   /libs/libhfcal.dylib  //Mac</span><br></pre></td></tr></table></figure><p>-shared选项告诉gcc你想把.o目标文件转化为动态库</p><p>编译器创建动态库时会把库的名字保存在文件中，假设你在Linux中创建了一个叫libhfcal.so的库，那么libhfcal.so文件就会记住它的库名叫hfcal。也就是说，一旦你用某个名字编译了库，就不能再修改文件名了。若想重命名库，就必须用新的名字重新编译一次</p><blockquote><p>在一些古老的Mac系统中没有-shared 选项，但是可以用-dynamiclib代替</p></blockquote><p>最后编译程序</p><p>一旦创建了动态库，你就可以像静态库那样使用它</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -I/include -c elliptical.c -o elliptical.o</span><br><span class="line">$ gcc elliptical.o -L/libs -lhfcal -o elliptical</span><br></pre></td></tr></table></figure><blockquote><p>在MinGW和Cygwin上，库名的格式有很多种，hfcal的库名可以是: libhfcal.dll.a、libhfcal.dll、hfcal.dll</p></blockquote><p>尽管使用的命令和静态存档一模一样，但两者编译的方式不同。因为库是动态的，所以编译器不会在可执行文件中包含库代码，而是插入一段用来查找库的“占位符”代码，并在运行时链接库</p><p>可以运行程序了</p><p>Mac可以直接运行当你在Mac中编译程序时，文件的完整路径&#x2F;libs&#x2F;libhfcal.dylib保存在可执行文件中，程序启动时知道去哪里找它</p><p>在Linux和大部分Unix中，编译器只会记录libhfcal.so库的文件名，而不会包含路径名。也就是说如果不把hfcal库保存到标准目录（如&#x2F;usr&#x2F;lib），程序就找不到它。为了解决这个问题，Linux会检查保存在LD_LIBRARY_PATH变量中的附加目录。只要把库目录添加到LD_LIBRARY_PATH中，并export它，elliptical就能找到libhfcal.so</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span>:/libs</span><br></pre></td></tr></table></figure><p>Windows同Linux一样，它的可执行文件也只保存hfcal库的名字，不保存目录名。不过Windows没有用LD_LIBRARY_PATH变量去找hfcal库。Windows程序会先在当前目录下查找，如果没找到就去查找保存在PATH变量中的目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//Cygwin</span><br><span class="line">PATH=<span class="string">&quot;<span class="variable">$PATH</span>:/libs&quot;</span></span><br><span class="line">//MinGW</span><br><span class="line">PATH=<span class="string">&quot;%PATH%:C:\libs&quot;</span></span><br></pre></td></tr></table></figure><p>在Linux和Mac中，动态库通常保存在&#x2F;usr&#x2F;lib或&#x2F;usr&#x2F;local&#x2F;lib中；而在Windows中，程序员通常把.DLL和可执行文件保存在同一个目录下</p><ul><li>动态库在修改库文件后不用再重新编译项目文件</li></ul><p>有了动态库，就能在运行时替换代码。不用重新编译程序，你就能修改它。如果你有很多程序，它们共享一段相同的代码，通过建立动态库，就可以同时更新所有程序</p><h2 id="9-进程与系统调用"><a href="#9-进程与系统调用" class="headerlink" title="9 进程与系统调用"></a>9 进程与系统调用</h2><p>C程序无论做什么事都要靠操作系统。如果它想与硬件打交道，就要进行系统调用。系统调用是操作系统内核中的函数，C标准库中大部分代码都依赖于它们</p><h3 id="system"><a href="#system" class="headerlink" title="system()"></a>system()</h3><p>接收一个字符串参数，并把它当作命令执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">system(<span class="string">&quot;dir D:&quot;</span>);<span class="comment">//打印D盘内容</span></span><br><span class="line">system(<span class="string">&quot;gedit&quot;</span>);       <span class="comment">//在Linux中启动编辑器</span></span><br><span class="line">system(<span class="string">&quot;say &#x27;End of Line&#x27; &quot;</span>);<span class="comment">//在Mac上朗读文本</span></span><br></pre></td></tr></table></figure><p>在一些操作系统中，系统调用的代码位于操作系统内核。而对其他操作系统而言，系统调用可能保存在动态库中</p><blockquote><p><strong>内核</strong>？</p><p>在大部分计算机上，系统调用就是操作系统内核中的函数。什么是内核？虽然你从来没在屏幕上看到过它，但内核其实一直都在那里控制计算机。内核是计算机中最重要的程序，它主管三样东西：<br>    进程<br>只有当内核把程序加载到存储器时程序才能运行。内核创建进程，并确保它们得到了所需资源。内核同时也会留意那些变得贪得无厌或者已经崩溃的进程。<br>    存储器<br>计算机所能提供的存储器资源是有限的，因此内核必须小心翼翼地分配每个进程所能使用的存储器大小。内核还能把部分存储器交换到磁盘从而增加虚拟存储器空间。<br>    硬件<br>内核利用设备驱动与连接到计算机上的设备交互。你的程序在不了解键盘、屏幕和图形处理器的情况下就能使用它们，因为内核会代表你与它们交涉。系统调用是程序用来与内核对话的函数。</p></blockquote><h3 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h3><p>进程是存储器中运行的程序。操作系统用一个数字来标识进程，它叫进程标识符（process identifier，简称PID）</p><p>exec()函数通过运行其他程序来替换当前进程。你可以告诉exec()函数要使用哪些命令行参数和环境变量。新程序启动后PID和老程序一样。</p><p>exec()函数在unistd.h中，它版本众多，但可以分为列表函数和数组函数。</p><h4 id="列表函数"><a href="#列表函数" class="headerlink" title="列表函数"></a>列表函数</h4><p>execl()、execlp()、execle()</p><p>列表函数以参数列表的形式接收命令行参数：</p><ol><li><p>程序</p><p>告诉exec()函数将运行什么程序。对execl()或execle()来说，它是程序的完整路径名；对execlp()来讲就是命令的名字，execlp()会根据它去查找程序</p></li><li><p>命令行参数</p><p>需要依次列出想使用的命令行参数。别忘了，第一个命令行参数必须是程序名，也就是说列表版exec()的前两个参数是相同字符串</p><blockquote><p><strong>命令行参数之间的空格会把MinGW弄糊涂</strong></p><p>如果把“I like”和“turles”这两个参数传给exec()，MinGW程序可能会发送三个参数：“I”、“like”和“turtle”。</p></blockquote></li><li><p>NULL</p><p>需要在最后一个命令行参数后加上NULL，告诉函数没有其他参数了</p></li><li><p>环境变量（如果有的话）</p><p>如果调用了以 …e() 结尾的 exec() 函数，还可以传递环境变量数组，像”POWER&#x3D;4”,”PORT&#x3D;OPEN”……那样的字符数组</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">execl(<span class="string">&quot;/home/flynn/clu&quot;</span>, <span class="string">&quot;/home/flynn/clu&quot;</span>, <span class="string">&quot;paranoids&quot;</span>, <span class="string">&quot;contract&quot;</span>, <span class="literal">NULL</span>)<span class="comment">//execL = 参数列表(List)</span></span><br><span class="line">execlp(<span class="string">&quot;clu&quot;</span>, <span class="string">&quot;clu&quot;</span>, <span class="string">&quot;paranoids&quot;</span>, <span class="string">&quot;contract&quot;</span>, <span class="literal">NULL</span>)<span class="comment">//execLP = 参数列表（List） + 在PATH中查找程序</span></span><br><span class="line">execle(<span class="string">&quot;/home/flynn/clu&quot;</span>, <span class="string">&quot;/home/flynn/clu&quot;</span>, <span class="string">&quot;paranoids&quot;</span>, <span class="string">&quot;contract&quot;</span>, <span class="literal">NULL</span>, env_vars)</span><br><span class="line"><span class="comment">//execLE = 参数列表（List） + 环境变量（Environment）</span></span><br></pre></td></tr></table></figure><h4 id="数组函数"><a href="#数组函数" class="headerlink" title="数组函数"></a>数组函数</h4><p>execv()、execvp()、execve()</p><p>如果已经把命令行参数保存在了数组中，就会发现这两个版本用起来更容易</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">execv(<span class="string">&quot;/home/flynn/clu&quot;</span>, my_args);<span class="comment">//execV=参数数组或参数向量（Vector）</span></span><br><span class="line">execvp(<span class="string">&quot;clu&quot;</span>, my_args);<span class="comment">//execVP = 参数数组/向量（Vector） + 在PATH中查找</span></span><br><span class="line"><span class="comment">//参数需要保存在字符串数组my_args中</span></span><br><span class="line"><span class="comment">//以上两函数唯一区别是execvp会用PATH变量查找程序</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>使用</th><th>字符</th></tr></thead><tbody><tr><td>参数列表</td><td>l</td></tr><tr><td>参数数组&#x2F;向量</td><td>v</td></tr><tr><td>根据PATH查找</td><td>p</td></tr><tr><td>环境变量</td><td>e</td></tr></tbody></table><p>l、v总是在p、e之前出现；p、e是可选的</p><h3 id="环境变量（具体做法见练习文件）"><a href="#环境变量（具体做法见练习文件）" class="headerlink" title="环境变量（具体做法见练习文件）"></a>环境变量（具体做法见练习文件）</h3><p>每个进程都有一组环境变量。你可以在命令行中输入set或env查看它们的值，它们一般会告诉进程一些有用的信息，比如用户主目录的位置，或去哪里找命令。C程序可以用getenv()系统调用读取环境变量</p><p>可以用字符串指针数组的形式创建一组环境变量。环境变量的格式是“变量名&#x3D;值”。数组最后一项必须是NULL</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *my_env[] = &#123;<span class="string">&quot;JUICE=peach and apple&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">execle(<span class="string">&quot;diner_info&quot;</span>, <span class="string">&quot;diner_info&quot;</span>, <span class="string">&quot;4&quot;</span>, <span class="literal">NULL</span>, my_env);</span><br></pre></td></tr></table></figure><blockquote><p><strong>在Cygwin中传递环境变量时一定要包含PATH变量</strong></p><p>在Cygwin中，加载程序时需要用PATH变量，因此在Cygwin上传递环境变量时一定要包含PATH&#x3D;&#x2F;usr&#x2F;bin</p></blockquote><h3 id="系统调用错误"><a href="#系统调用错误" class="headerlink" title="系统调用错误"></a>系统调用错误</h3><p>如果在调用程序时发生错误，当前进程会继续运行，于是可以向用户报告错误信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">execle(<span class="string">&quot;diner_info&quot;</span>, <span class="string">&quot;diner_info&quot;</span>, <span class="string">&quot;4&quot;</span>, <span class="literal">NULL</span>, my_env);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;哥们，diner_info程序肯定发生了什么问题&quot;</span>);</span><br></pre></td></tr></table></figure><p>所有的系统调用都遵循“失败黄金法则”</p><ol><li>尽可能收拾残局</li><li>把errno变量设为错误码</li><li>返回-1</li></ol><p>errno变量是定义在errno.h中的全局变量，还一并定义了许多标准错误码</p><table><thead><tr><th>标准错误码</th><th>错误消息</th></tr></thead><tbody><tr><td>EPERM&#x3D;1</td><td>不允许操作</td></tr><tr><td>ENOENT&#x3D;2</td><td>没有该文件或目录</td></tr><tr><td>ESRCH&#x3D;3</td><td>没有该进程</td></tr></tbody></table><p>可以拿errno和这些值比较，也可以用string.h中的<code>strerror()</code>的函数查询标准错误消息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">puts</span>(strerror(errno));<span class="comment">//strerror()将错误码转换为一条消息</span></span><br></pre></td></tr></table></figure><h3 id="用fork-克隆进程"><a href="#用fork-克隆进程" class="headerlink" title="用fork()克隆进程"></a>用fork()克隆进程</h3><p>exec() 是程序中最后一行代码</p><p>fork()会克隆当前进程。新建副本将从同一行开始运行相同程序，变量和变量中的值完全一样，只有进程标识符（PID）和原进程不同。原进程叫父进程，而新建副本叫子进程</p><blockquote><p>注意！与Unix和Mac不同，**Windows天生不支持fork()**，如果想在Windows中使用fork()，必须先要安装Cygwin</p><p>Windows有一个<code>Create-Process()</code>函数。它是一个加强版的system()</p><p>此处<a href="https://learn.microsoft.com/en-us/windows/win32/procthread/creating-processes">官方文档</a></p></blockquote><p>用fork()+exec()运行子进程，在子进程中调用exec()函数，这样原来的父进程就能继续运行了</p><p>复制进程后，为区分父子进程，fork()函数向子进程返回0，向父进程返回非零值</p><blockquote><p><strong>fork()</strong></p><p>你可以像这样调用fork()：<code>pid_t pid = fork();</code><br>fork()会返回一个整型值：为子进程返回0，为父进程返回一个正数。父进程将接收到子进程的进程标识符<br>什么是pid_t？不同操作系统用不同的整数类型保存进程ID，有的用short，有的用int，操作系统使用哪种类型，pid_t就设为哪个</p></blockquote><ul><li><p>这样的设计中一般现在要考虑可能出现错误了，可以这样写</p></li><li><p>&#96;&#96;&#96;c<br>pid_t pid &#x3D; fork();<br>if (pid &#x3D;&#x3D; -1) {<br>fprintf(stderr, “Can’t fork process: %s\n”, strerror(errno));<br>return 1;<br>}<br>if (!pid) {<br>  …<br>}</p></li></ul><blockquote><p>在用exec()替换子进程前可以不用等fork()复制完整个进程，操作系统会采用写时复制（copy-on-write）技术等技巧。比如操作系统不会真的复制父进程的数据，而是让父子进程共享数据。如果操作系统发现子进程要修改存储器，就会为它复制一份</p></blockquote><h2 id="10-进程间通信"><a href="#10-进程间通信" class="headerlink" title="10 进程间通信"></a>10 进程间通信</h2><p>在命令行中，重定向是非常有用的命令，也可以让进程重定向自己</p><h3 id="进程内部"><a href="#进程内部" class="headerlink" title="进程内部"></a>进程内部</h3><p>进程含有它正在运行的程序，还有栈和堆数据空间。进程还需要记录数据流的连向，它用文件描述符表示数据流，所谓的描述符其实就是一个数字。进程会把文件描述符和对应的数据流保存在描述符表中（下表仅为示意）描述符表的一列是文件描述符号，另一列是它们对应的数据流</p><table><thead><tr><th>#</th><th>数据流</th></tr></thead><tbody><tr><td>0</td><td>键盘</td></tr><tr><td>1</td><td>屏幕</td></tr><tr><td>2</td><td>屏幕</td></tr><tr><td>3</td><td>数据库连接</td></tr></tbody></table><p>描述符表的前三项万年不变：0号标准输入，1号标准输出，2号标准错误。其他项要么为空，要么连接进程打开的数据流。比如程序在打开文件进行读写时，就会占用其中一项</p><p>创建进程以后，标准输入连到键盘，标准输出和标准错误连到屏幕。它们会保持这样的连接，直到有人把它们重定向到了其他地方</p><ul><li>文件描述符描述的不一定是文件</li></ul><p>在 类Unix操作系统中，可以用以下命令把标准错误和标准输出重定向到一个地方：</p><p><code>./myprog 2&gt;&amp;1</code></p><p>“2&gt;”表示“重定向标准错误”;“&amp;1”表示“到标准输出”</p><h3 id="fileno-返回描述符号"><a href="#fileno-返回描述符号" class="headerlink" title="fileno()返回描述符号"></a>fileno()返回描述符号</h3><p>每打开一个文件，操作系统都会在描述符表中新注册一项</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE *my_file = fopen(<span class="string">&quot;guitar.mp3&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br></pre></td></tr></table></figure><p>操作系统会打开<em>guitar.mp3</em>文件，然后返回一个指向它的指针，操作系统还会遍历描述符表寻找空项，把新文件注册在其中</p><p>调用fileno()函数可以根据文件指针知道它是几号描述符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> descriptor = fileno(my_file);</span><br></pre></td></tr></table></figure><blockquote><p>在失败时不返回-1的函数很少，fileno()就是其中之一。只要你把打开文件的指针传给fileno()，它就一定会返回描述符编号😴？？</p></blockquote><h3 id="dup2-复制数据流"><a href="#dup2-复制数据流" class="headerlink" title="dup2()复制数据流"></a>dup2()复制数据流</h3><p>可以用dup2()函数修改某个已经注册过的数据流，dup2()可以复制数据流</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dup2(<span class="number">4</span>, <span class="number">3</span>);<span class="comment">//同时将4号数据流连接到3号描述符</span></span><br></pre></td></tr></table></figure><h3 id="exit"><a href="#exit" class="headerlink" title="exit()"></a>exit()</h3><p>exit()系统调用是结束程序的最快方式，为了使用exit系统调用，必须包含stdlib.h头文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">error</span><span class="params">(<span class="type">char</span> *msg)</span>&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s: %s\n&quot;</span>, msg, strerror(errno));</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);<span class="comment">//exit(1)会立刻终止程序，并把退出状态置1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次程序执行只有一次调用exit()的机会</p><h3 id="等待子进程"><a href="#等待子进程" class="headerlink" title="等待子进程"></a>等待子进程</h3><p>子进程一创建就和父进程没关系了，有时候子进程还未完成任务，父进程就已经结束了，操作系统必须提供一种方式，让你等待子进程完成任务</p><h4 id="waitpid-函数"><a href="#waitpid-函数" class="headerlink" title="waitpid()函数"></a>waitpid()函数</h4><p>waitpid()函数会等子进程结束以后才返回，也就是说可以在父进程中加几行代码，让它等到子进程运行结束以后才退出</p><p>需要包含sys&#x2F;wait.h的头文件(Windows平台似乎并不支持)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>接收三个参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">waitpid(pid,pid_status, options )</span><br></pre></td></tr></table></figure><ol><li><p>pid</p><p>父进程在克隆子进程时会得到子进程的ID</p></li><li><p>pid_status</p><p>pid_status用来保存进程的退出信息。因为waitpid()需要修改pid_status，因此它必须是个指针</p></li><li><p>options</p><p>waitpid()有一些选项，详情可以输入man waitpid查看。如果把选项设为0，函数将等待进程结束</p></li></ol><p><strong>pid_status</strong>?</p><p>waitpid()函数结束等待时会在pid_status中保存一个值，它告诉你进程的完成情况</p><p>为了得到子进程的退出状态，可以把pid_status的值传给WEXITSTATUS()宏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (WEXITSTATUS(pid_status))</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Error status non-zero&quot;</span>);</span><br></pre></td></tr></table></figure><p>pid_status中保存了好几条信息，只有前8位表示进程的退出状态，所以需要用宏来查看</p><p>重定向输入、输出，然后让进程相互等待，这就是进程间通信</p><p>进程之间通过共享数据和互相可以等待实现更多功能</p><h3 id="管道连接进程"><a href="#管道连接进程" class="headerlink" title="管道连接进程"></a>管道连接进程</h3><p>可以在命令行用管道把一个进程的输出连接到另一个进程的输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python rssgossip.py -u <span class="string">&#x27;pajama death&#x27;</span> | grep <span class="string">&#x27;http&#x27;</span></span><br><span class="line">http://www.rock-news.com/exclusive/24.html</span><br><span class="line">http://www.rolling-stone.com/pdalbum.html</span><br></pre></td></tr></table></figure><p>grep找出了包含http的那些行</p><p>管道两侧的命令是父子关系，如上例中grep命令是rssgossip.py脚本的父进程</p><ol><li>命令行创建了父进程</li><li>父进程在子进程中克隆出了rssgossip.py脚本</li><li>父进程用管道把子进程的输出连接到自己的输入</li><li>父进程运行了grep命令</li></ol><h3 id="pipe-打开两条数据流"><a href="#pipe-打开两条数据流" class="headerlink" title="pipe()打开两条数据流"></a>pipe()打开两条数据流</h3><p>用pipe()函数建立管道</p><p>每当打开数据流时，它都会加入描述符表。pipe()函数也是如此，它创建两条相连的数据流，并把它们加到表中，然后只要往其中一条数据流中写数据，就可以从另一条数据流中读取</p><p>pipe()在描述符中创建这两项时，会把它们的文件描述符保存在一个包含两个元素的数组中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">if</span> (pipe(fd) == <span class="number">-1</span>) &#123;</span><br><span class="line">error(<span class="string">&quot;Can&#x27;t create the pipe&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pipe()函数创建了管道，并返回了两个描述符： fd[1]用来向管道写数据，fd[0]用来从管道读数据</p><p>在子进程中，关闭管道的fd[0]端，修改子进程的标准输出，让它指向描述符fd[1]对应的数据流；在父进程中需要关闭管道的fd[1]端，重定向父进程的标准输入，让它从描述符fd[0]对应的数据流中读取数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子进程</span></span><br><span class="line">close(fd[<span class="number">0</span>]);</span><br><span class="line">dup2(fd[<span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//父进程</span></span><br><span class="line">dup2(fd[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">close(fd[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><p>不同操作系统打开网页？较为简单粗暴的system()写法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">open_url</span><span class="params">(<span class="type">char</span> *url)</span>&#123;</span><br><span class="line"><span class="type">char</span> launch[<span class="number">255</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(launch, <span class="string">&quot;cmd /c start %s&quot;</span>, url);<span class="comment">//Windows</span></span><br><span class="line">system(launch);</span><br><span class="line"><span class="built_in">sprintf</span>(launch, <span class="string">&quot;x-www-browser &#x27;%s&#x27; &amp;&quot;</span>, url);<span class="comment">//Linux</span></span><br><span class="line">system(launch);</span><br><span class="line"><span class="built_in">sprintf</span>(launch, <span class="string">&quot;open &#x27;%s&#x27;&quot;</span>, url);     <span class="comment">//Mac</span></span><br><span class="line">system(launch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在类Unix机器或任何使用Cygwin的Windows机器中可以获取以下程序</p><p><strong>curl&#x2F;wget</strong><br>可以用这两个程序与网络服务器通信，也可以在C代码中使用它们与网络通信<br><strong>mail&#x2F;mutt</strong><br>可以在命令行用这两个程序发送邮件。如果在机器上装了它们，C程序就能发送邮件<br><strong>convert</strong><br>convert命令可以转换图片格式。你可以写一个C程序，它输出文本格式的SVG图表，然后用convert命令把SVG转化成PNG图片</p></blockquote><p><strong>关于管道的Q&amp;A</strong></p><p>管道可能是文件。可以创建基于文件的管道，它们通常叫有名管道或FIFO(First In First Out，先进先出)文件。因为基于文件的管道有名字，所以两个进程只要知道管道的名字也能用它来通信，即使它们非父子进程。使用<a href="http://tinyurl.com/cdf6ve5">mkfifo()系统调用</a>有名管道</p><p>如果不用文件来实现管道, 那么通常用存储器。数据写到存储器中的某个位置，然后再从另一<br>个位置读取</p><p>如果试图读取一个空的管道，程序会等管道中出现东西</p><p>子进程结束时，管道会关闭。fgets()将收到EOF（End Of File，文件结束符），于是fgets()函数返回0，循环就结束了</p><p>管道只能单向通信。不过可以创建两个管道，一个从父进程连到子进程，另一个从子进程连到父进程</p><h3 id="杀死进程😎Ctrl-C"><a href="#杀死进程😎Ctrl-C" class="headerlink" title="杀死进程😎Ctrl-C"></a>杀死进程😎Ctrl-C</h3><p>操作系统会从键盘读取数据，但当它看到用户按了Ctrl-C，就会向程序发送中断信号，进程运行默认中断处理器，调用了exit()</p><p>信号是一条短消息，即一个整型值。当信号到来时，进程必须停止手中一切工作去处理信号。进程会查看信号映射表，表中每个信号都对应一个信号处理器函数。中断信号的默认信号处理器会调用exit()函数</p><p>既然有这么一张信号映射表，那么就可以修改进程收到信号时运行的函数</p><h3 id="sigaction是一个函数包装器"><a href="#sigaction是一个函数包装器" class="headerlink" title="sigaction是一个函数包装器"></a>sigaction是一个函数包装器</h3><p><strong>以下均需要包含signal.h文件</strong></p><p>sigaction是一个结构体，它有一个函数指针。sigaction告诉操作系统进程收到某个信号时应该调用哪个函数。</p><p>创建方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">action</span>;</span></span><br><span class="line">action.sa_handler = diediedie;<span class="comment">//指定计算机调用哪个函数，这个被sigaction包装起来的函数就叫处理器</span></span><br><span class="line">sigemptyset(&amp;action.sa_mask);  <span class="comment">//用掩码来过滤sigaction要处理的信号，通常会用一个空的掩码</span></span><br><span class="line">action.sa_flags = <span class="number">0</span>;<span class="comment">//一些附加标志位，将它们置0就行了</span></span><br></pre></td></tr></table></figure><p>处理器必须接收信号参数，为整型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">diediedie</span><span class="params">(<span class="type">int</span> sig)</span>&#123;</span><br><span class="line"><span class="built_in">puts</span> (<span class="string">&quot;Goodbye cruel world....\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理器的代码应该短而快，刚好能处理接收到的信号就好</p><blockquote><p>在处理器函数中使用标准输出和标准错误时要小心</p><p>之所以会有信号就是因为程序中发生了故障，而故障可能就是这些无法使用</p></blockquote><h3 id="用sigaction-来注册sigaction"><a href="#用sigaction-来注册sigaction" class="headerlink" title="用sigaction()来注册sigaction"></a>用sigaction()来注册sigaction</h3><p>创建sigaction以后，需要用sigaction()函数来让操作系统知道它的存在</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sigaction(signal_no, &amp;new_action, &amp;old_action);</span><br></pre></td></tr></table></figure><p>接收三个参数：</p><ol><li><p>信号编号</p><p>这个整型值代表了你希望处理的信号。通常会传递SIGINT或SIGQUIT这样的标准信号</p></li><li><p>新动作</p><p>你想注册的新sigaction的地址</p></li><li><p>旧动作</p><p>如果你想保存被替换的信号处理器，可以再传一个sigaction指针；如果不想保存，可以设置为NULL</p></li></ol><p>如果sigaction()函数失败，会返回－1，并设置errno变量</p><p>以下函数简化了注册过程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">catch_signal</span><span class="params">(<span class="type">int</span> sig, <span class="type">void</span> (*handler)(<span class="type">int</span>))</span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">action</span>;</span></span><br><span class="line">action.sa_handler = handler;</span><br><span class="line">sigemptyset(&amp;action.sa_mask);</span><br><span class="line">action.sa_flags = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> sigaction (sig, &amp;action, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">catch_signal(SIGINT, diediedie);</span><br></pre></td></tr></table></figure><h3 id="操作系统的信号（部分）"><a href="#操作系统的信号（部分）" class="headerlink" title="操作系统的信号（部分）"></a>操作系统的信号（部分）</h3><table><thead><tr><th>信号</th><th align="left">引起原因</th></tr></thead><tbody><tr><td>SIGINT</td><td align="left">进程被中断</td></tr><tr><td>SIGQUIT</td><td align="left">有人要求停止进程，并把存储器中的内容保存到核心转储文件</td></tr><tr><td>SIGFPE</td><td align="left">浮点错误</td></tr><tr><td>SIGTRAP</td><td align="left">调试人员询问进程执行到了哪里</td></tr><tr><td>SIGSEGV</td><td align="left">进程企图访问非法存储器地址</td></tr><tr><td>SIGWINCH</td><td align="left">终端窗口的大小发生改变</td></tr><tr><td>SIGTERM</td><td align="left">有人要求内核终止进程</td></tr><tr><td>SIGPIPE</td><td align="left">进程在向一个没有人读的管道写数据</td></tr></tbody></table><h3 id="使用kill发送信号"><a href="#使用kill发送信号" class="headerlink" title="使用kill发送信号"></a>使用kill发送信号</h3><p>在类Unix操作系统中有一个叫kill的命令（在Windows上用Cygwin）</p><p>叫kill是因为这个命令通常用来“杀死”进程。事实上，kill只是向进程发送了一个信号，kill默认会向进程发送SIGTERM信号</p><p>kill －KILL一定能杀死进程</p><h3 id="raise-给自己发送信号"><a href="#raise-给自己发送信号" class="headerlink" title="raise()给自己发送信号"></a>raise()给自己发送信号</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">raise(SIGTERM);</span><br></pre></td></tr></table></figure><p>通常会在自定义的信号处理函数中使用raise()，这样程序就能在接收到低级别的信号时引发更高级别的信号。这就是信号升级</p><h3 id="SIGALRM"><a href="#SIGALRM" class="headerlink" title="SIGALRM"></a>SIGALRM</h3><p>当计算机中发生了进程需要知道的事情时，操作系统就会向进程发送信号，除了在发生错误时使用，有时进程也需要产生自己的信号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alarm(<span class="number">120</span>);<span class="comment">//把闹钟调到120秒以后闹铃</span></span><br><span class="line">do_important_busy_work();</span><br><span class="line">do_more_busy_work();<span class="comment">//其间代码就会做其他事</span></span><br></pre></td></tr></table></figure><p>进程在收到闹钟信号以后默认会结束进程，但通常情况下使用定时器不是为了让它帮你“杀死”程序，而是为了利用闹钟信号的处理器去做另一件事</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">catch_signal(SIGALRM, pour_coffee);</span><br><span class="line">alarm(<span class="number">120</span>);</span><br></pre></td></tr></table></figure><p>闹钟信号可以实现多任务。如果需要每隔几秒运行一个任务，或者想限制花费在某个任务上的时间，就可以用闹钟信号让程序打断自己</p><p>一个进程只有一个定时器。定时器由操作系统的内核管理，如果一个进程有很多定时器，内核就会变得很慢，因此操作系统需要限制进程能使用的定时器个数</p><p>每次调用alarm()函数都会重置定时器</p><blockquote><p><strong>不要同时使用alarm()和sleep()</strong></p><p>sleep()函数会让程序沉睡一段时间。和alarm()函数一样，它也使用了间隔计时器，因此同时使用这两个函数会发生冲突</p></blockquote><blockquote><p>setitimer()函数可以把进程间隔计时器的单位设为几分之一秒</p></blockquote><h3 id="重置信号和忽略信号"><a href="#重置信号和忽略信号" class="headerlink" title="重置信号和忽略信号"></a>重置信号和忽略信号</h3><p>如果想还原默认的信号处理器，signal.h头文件中有一个特殊的符号SIG_DFL，它代表以默认方式处理信号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">catch_signal(SIGTERM, SIG_DFL);</span><br></pre></td></tr></table></figure><p>同时，还可以用SIG_IGN符号让进程忽略某个信号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">catch_signal(SIGINT, SIG_IGN);</span><br></pre></td></tr></table></figure><p>在决定忽略某个信号前一定要慎重考虑，信号是控制进程和终止进程的重要方式，如果忽略了它们，程序就很难停下来</p><h2 id="11-网络与套接字"><a href="#11-网络与套接字" class="headerlink" title="11 网络与套接字"></a>11 网络与套接字</h2><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><p>互联网中大部分的底层网络代码都是用C语言写的。网络程序通常由两部分程序组成：服务器和客户端</p><p>可以使用一个叫telnet的客户端程序连接服务器。telnet接收两个参数：一个是服务器地址，另一个是服务器运行的端口</p><blockquote><p>需要用telnet程序连接服务器。很多系统自带了telnet，可以用以下命令检查计算<br>机上有没有telnet：<code>telnet</code><br>如果你的计算机上没有telnet，可以用以下方式安装：<br>Cygwin:<br>打开Cygwin的安装程序（setup.exe），搜索telnet。<br>Linux:<br>在包管理器中搜索telnet，很多操作系统的包管理器叫新立得（synaptic）。<br>Mac:<br>如果没有telnet，可以从<a href="http://www.macports.org或www.finkproject.org安装./">www.macports.org或www.finkproject.org安装。</a></p></blockquote><p>服务器将同时与多个客户端通信。客户端与服务器之间将展开一段结构化对话，叫做协议。互联网使用了各种协议，一部分是低层协议，另一部分是高层协议。低层协议有IP（Internet Protocol，网际协议），它用来控制二进制的0和1在互联网中的发送方式；高层协议有HTTP（Hypertext Transfer Protocol，超文本传输协议），它用来控制浏览器和网络服务器的对话</p><p>协议通常有一套严格的规则。客户端和服务器都遵守这些规则就没事，但只要它们中有一方违反了规则，对话就会戛然而止</p><h3 id="BLAB"><a href="#BLAB" class="headerlink" title="BLAB"></a>BLAB</h3><p>如果想要写一个与网络通信的程序，就需要一种新数据流——套接字</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span><span class="comment">//需要包含这个头文件</span></span></span><br><span class="line">...</span><br><span class="line"><span class="type">int</span> listener_d = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);<span class="comment">//listener_d是套接字描述符，0是协议号</span></span><br><span class="line"><span class="keyword">if</span> (listener_d == <span class="number">-1</span>)</span><br><span class="line">error(<span class="string">&quot;无法打开套接字&quot;</span>);</span><br></pre></td></tr></table></figure><p>在使用套接字与客户端程序通信前，服务器需要历经四个阶段：绑定（Bind）、监听（Listen）、接受（Accept）和开始（Begin），首字母缩写为BLAB</p><ol><li><p>绑定端口</p><p>计算机可能同时运行多个服务器程序，每项服务必须使用不同的端口（port）。端口就好比电视频道，我们在不同端口使用不同的网络服务，就像我们通过不同频道收看不同的电视节目</p><p>服务器在启动时，需要告诉操作系统将要使用哪个端口，这个过程叫端口绑定。为了绑定它，你需要两样东西：套接字描述符和套接字名</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line">   ...</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">name</span>;</span></span><br><span class="line">   name.sin_family = PF_INET;</span><br><span class="line">   name.sin_port = (<span class="type">in_port_t</span>)htons(<span class="number">30000</span>);</span><br><span class="line">   name.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">   <span class="type">int</span> c = bind (listener_d, (<span class="keyword">struct</span> sockaddr *) &amp;name, <span class="keyword">sizeof</span>(name));</span><br><span class="line">   <span class="keyword">if</span> (c == <span class="number">-1</span>)</span><br><span class="line">   error(<span class="string">&quot;无法绑定端口&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 监听</span><br><span class="line"></span><br><span class="line">   可以用listen()系统调用告诉操作系统队列有多长</span><br><span class="line"></span><br><span class="line">   调用listen()把队列长度设为<span class="number">10</span>，也就是说最多可以有<span class="number">10</span>个客户端同时尝试连接服务器，它们不会立即得到响应，但可以排队等待，而第<span class="number">11</span>个客户端会被告知服务器太忙</span><br><span class="line"></span><br><span class="line">   ```c</span><br><span class="line">   <span class="title function_">if</span><span class="params">(listen(listener_d, <span class="number">10</span>) == <span class="number">-1</span>)</span></span><br><span class="line">       <span class="title function_">error</span><span class="params">(<span class="string">&quot;无法监听&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 接受连接</span><br><span class="line"></span><br><span class="line">   accept()系统调用会一直等待，直到有客户端连接服务器时，它会返回第二个套接字描述符，然后就可以用它通信了</span><br><span class="line"></span><br><span class="line">   ```c</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">client_addr</span>;</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> address_size = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line">   <span class="type">int</span> connect_d = accept(listener_d, (<span class="keyword">struct</span> sockaddr *)&amp;client_addr, &amp;address_size);</span><br><span class="line">   <span class="keyword">if</span> (connect_d == <span class="number">-1</span>)</span><br><span class="line">   error(<span class="string">&quot;无法打开副套接字&quot;</span>);</span><br></pre></td></tr></table></figure><p>服务器将用新的连接描述符connect_d进行通信</p></li></ol><h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h3><p>套接字是双向的，它既可以用作输入也可以用作输出，也就是说要用其他函数和它通信</p><p>如果想向套接字输出数据，就要用send()函数，而不是fprintf()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *msg = <span class="string">&quot;Internet Knock-Knock Protocol Server\r\nVersion 1.0\r\nKnock! Knock!\r\n&gt; &quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (send(connect_d, msg, <span class="built_in">strlen</span>(msg), <span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">error(<span class="string">&quot;send&quot;</span>);</span><br></pre></td></tr></table></figure><blockquote><p><strong>如何选择端口号</strong></p><p>为服务器程序选择端口号时千万要小心。现如今有各式各样的服务器，所以不要选其他程序用过的端口号。在Cygwin和大多数Unix中有一个&#x2F;etc&#x2F;services文件，它列出了很多常用服务使用的端口号。在选择端口时必须确保没有其他程序用过</p><p>端口号从0开始一直到65535，首先你需要决定用小号码（1024以下）还是大号码。很多计算机中，只有超级用户或管理员才有资格使用1024号以下的端口，因为小号的端口留给了一些知名服务，如网页服务器和邮件服务器。操作系统只允许管理员使用这些端口，防止普通用户启动一些多余的服务</p><p>通常情况下，请使用1024号以上的端口</p></blockquote><h2 id="12-线程"><a href="#12-线程" class="headerlink" title="12 线程"></a>12 线程</h2><h2 id="十大遗漏知识点"><a href="#十大遗漏知识点" class="headerlink" title="十大遗漏知识点"></a>十大遗漏知识点</h2><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul><li><p>递增与递减</p><p>++和–的位置决定了表达式返回i的原始值还是新值，前新后旧</p></li><li><p>三目运算符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (x == <span class="number">1</span>) ? <span class="number">2</span> : <span class="number">3</span>;<span class="comment">//这里上下等价</span></span><br></pre></td></tr></table></figure></li><li><p>位运算</p><p>C语言可以用来编写底层代码，为此它提供了一组位运算符：</p><table><thead><tr><th align="center">运算符</th><th>说明</th></tr></thead><tbody><tr><td align="center">~a</td><td>a中所有位都取反</td></tr><tr><td align="center">a &amp; b</td><td>a中的位“与”b中的位</td></tr><tr><td align="center">a | b</td><td>a中的位“或”b中的位</td></tr><tr><td align="center">a ^ b</td><td>a中的位“异或”b中的位</td></tr><tr><td align="center">&lt;&lt;</td><td>位左移（值增加）</td></tr><tr><td align="center">&gt;&gt;</td><td>位右移（值减小）</td></tr></tbody></table><p>&lt;&lt;运算符可以用来快速地将某个整型值乘以2的幂，但小心千万别溢出</p></li><li><p>用逗号分割表达式<br>for循环在每次循环的末尾都会出现递增操作。<br>但如果你想在循环末尾执行多个运算怎么办？可以使用逗号运算符：<br><code>for (i = 0; i &lt; 10; i++, j++)</code> 递增i和j。<br>之所以要有逗号运算符是因为有时你不想用分号来分割表达式</p></li></ul><h3 id="预处理指令"><a href="#预处理指令" class="headerlink" title="预处理指令"></a>预处理指令</h3>]]></content>
      
      
      
        <tags>
            
            <tag> C notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一封新年的信</title>
      <link href="/2023/01/LetterToYYY/"/>
      <url>/2023/01/LetterToYYY/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Sorry, you aren't her." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="34d310f3dea690e604a6b9079b2dc27dff2567dff8dd41f08c1810ce183acdbf">cb1516b36de741a2b3bbe43b3982941151bd781dfac26e1ae42cb0a497475ef30d0317d3bb0df941088886f08b53b9739d45ce49a4458d97508c1032876a0744d017d3e202ff507c726851df781b127b6dcdc75097a5df6a00936e9b60e2f843d6f6440d2f0b84958da61c485b3a64cf6a309f1a100cdb646d609ae902dd1634a7d0a4ecdd175af4f6f253cb8d3160595a8d3f1e74d3d93ec665bb616353a4d63054fd4b8405c4014afb27c3f01973898dcc1652b2e6fe5e9501ba91ae049737c657ddbb7864e077041bf1dd2e154861eb12abf57f8c34206794bc10ea0ae18c395ed05f89efa74c9788fede833c5923ca7a2c07536d61a6ab7b34da59eb6fea2e34cee4339968a33c1e6ab79a9163f9c7d02e456b3a0d721e4dca2ba8d1fe678c68b66d66b673f0788ab10d15891788f6bc860167153785b527db0fbdf9161b5c54ec06f006fc53fb5b6e8fbae5e384398aca79abd2d6c203f7ce0e2a761cb07fd93c8cd60de42e010cc27aec3a6ad4458af084438a9ff86f3bf887190ff21a63232e494561a72db409e9b20f1e38ffba5a38f5c914cafa20d3a009fcb623eb2d468f1e14318a033acc572aadb003006b0b13b9073c97a1751428b309b0237e5d682d548ba16219ece4cb8a35a79d42a376037769aa2baba78bb5cd607ec9af42cbe32d03963df5682977c9ed70739d59de182dbfd3dc50ae7d5493500e7f8aaa9ebfa629d0e34878e9ddb6a572eb7aebcffda9e1419f2c55fd334f8c66e644e3c431cea4999ebdde4c2f68071f9467e0531fd99104e22cc09f5059c90ca095050f4a679a45dc411b9eb298c3486fe7b9e095c0a5f9d5b202c3718471f40869901d75a69652f88b3dcf244d3cec928df686b7e569c0630224d2f2126d1d29ce3d706fdb4d8a8bd671d496fbc47b1030c3d8aed93a1bcb3ee4aab5b292320e6103c03989876a29194b9fb5e075872aa7b961043d3f0d2505f30ab5e0e515d2b79961340d31cf393ecbc93f315c0448a17b43f82402e6fcdc986307dcdd1b8f463fbca355a8dc0781b5a7db0fe107f8422ea461ada853167697e54824d8b0f7ed502cf1adfba1c86c26f8ffef3bc5f272df19faad434c087126822c85f6be9079e8bc3f983643edf24a60048b7006f0fd69151a8f10398494aed5408fd7f8ace568e76b8c2472d8a79b07e4f3a3bdb1493d303c030695fcd833bdc352fe93ec450f72e90c9268ea47b561ee9a73b54c5e4faa509bb97021128fc3100ebbc711d6f4ae8e6662772739b9edb5dc5f595111f0202fa134bfa26427dc4337b7f2033751094aadc0302e1e1542e0e86abb01213c1ab05b366f6d278ceb88159181193ec139da28defb639f4133632dd3b0413e30d3c04992c70e7f0e99fe4a815b52342cde15f22e857fddc1a77fbb9b436244b198632d759c3308e6c0e181681f9a99600094bed490bfd70412fb17d77664e6eb5343377822d0819ef3e8d364d21e63808e9ec30daad571707b795727eae50f079b238086cf4cdbbdc49a841b41f55592d5e6b22b27b2f36dd770a77d786687a260ac50b3552b9d155d2e7772f46c44a16d38b2ed5418193221a42962acef4302359a966cfda35d001b3a4fb39164cc484776fabefe2899e3108570d7de237c3aa2ba33c0032a3c9ed932fcb12cc22a783b7e25b85d318f5be8134e60a4fb181c89c5c65fa537dd6093d93dcf96ce29004b470b03f01bcb317ade72b599c0a6147175aec970f95e39f7a68bf44c4a14fc719a7e7342d83c147c53ccaf212a86b90f485683b5a3869b45f4678b434914e1cb0475b3f47d63a92f960507c42e52d3966ac15e81e9461f8bf03b262be7848c295ff6929c725465c6928a89018c72f8d4a50945e2850cfe37d252314a185222e62ddc70f5b823012a3d7490950117f37223ffe06ce38ceb7a32d435d49942048fb9dc8616dce7af416d1c6d03f895bd4732f91f19d0bfe1c7d389bd44621a65c6ca9aeabb57547e7d719030ed68b60401fb07e2be257b9292c3b59b4a4187ec0ec495a06426997965eed01e2dc2bf7a16287df48f1f87de7ddb4585c02f12dbd6c332dc345d543a2469e595eaab2fd46b9b58551ec5b3a75a415ad884da46749a8a097bddbe75f5bdc95853b25cb0b407da2fcfc2e3821fad0873c10783e2794bd77f550ecef2010513d940087f49cc284933f003621de13601978ff3a0014a59826ae28a9617adef933bccd571f0ff4f1596e13e533c63640809fce96b67fed464088d37fe092e27809e6f4514dc6507ecb3b5e0e93243af7a1eb76af848f528ee54ccec264aa4b00a0da28cc7c8ec7264143dc97ba5bfe321efd1adb9e8bd9d87d342e3a4cdbf922c2dab3fadf6b0ef2439b18403862a7669e580430d40767651e7a1f3f095e0465ba027f99d9e5aed9f05f5532c770649fedaa42ccbb2fa7e6b3305fc6682d7099bb3f1239bcdc881625b679192e3703477a43d4dd15d5a55741150ffa44f43247dcc2ec2c1d3e5ac05c6941569fe7d7d6fbf1cbb37bd11c287cbb237e239943ba1d63b7fed94a15d07ebb26f373b1218078af2c208d3ee4ac2bdf699b54a3584f1fa9328f66c2ba0d42503f80b01c71b255955ef749ad8a599cbfed7b5495a697df1905ec7c72e2c31c851e5614d921e715b6508fbf5500a62a8a9496ea42c28ea646e9b503201478d889abfda39a956f3eaefd88dcad260d76b3474f43987fd0b333dc072db1492b453e999d77ad38f4c8245f8278b02aea81d853f690c92c5c843240958ca2d9adbf1467673bcd2f85c065b36c6f4927e5200bca291ac3f57621c9cc39c78a445f6df09dbdf11823e97c13f61a1589d66b349d254f73424da278d35b22da5b7bfb7556a6d505f9b360aabb8307b1a6e803f7ead149acec77c42b071ce50a1e57f5c67d6d127cacb0c99716b4c65fcfe99b56ee850f94214d22b108a1bf7c8a8ad01a0a1db731273c11301a973b0a1eb6010236fe289051458bc3669a689235279eda9411940cbe838ed40b1d5aed213f0f4c99d255661a52b5795b9a24d272b4aa9268ef9b6cc41a62ac6498515a8bb68717c7bbc1be17ef73f3b1be1cb4810fc21878410fef8ace37184aceb2c4d9e3212bedd7098fd46451967bbd3005045d09c9dc53240e3a63d6db3c1ad4967eb706beafac5089b654fe6c822718438662a602c91dcbb05f739987bd97c778ee46f53abaab81314e4b3db389cf7fd0bb86f3bd1023f865b12e91a990ee9d2655f730c463256fb1b929e3ff85c52e0c1672442053018df5ef1a552ae997ccd2abe748850069391a6c3683a6aadeb83e336217e6c3d0c4ad819e9eeaead16b2636852a8f5d7aabcef6e9b7dd5c9a037697c901eabfaebcb6b7ccec9293b012b8c6c92a6acfcbe9e69e13c032efa5da6ed130b34fb8405ab1b6a34d2eb99720a4fd15fc7a012c64abe3f70b825368a6ceb89a622d3b653b7bffa4c58d8bbf492d37ebc6516419b112c30f4693a138b7054f5ecaa7680007f0fb55ca5e9cb951210ab240422da5311dc110188123bb0079aabe85726e3e5dba96c0d3955133f83a6e38315584e5cea57df4f7c493c3f887f88f5edb714b620e2e6e7eebe39b3e247ce4bc51fb7015d3593d9815b9c4766e9a98852c126b26ccdc1adf955ad1b1b4a3ca54bfab5aaf17e650f655e83b1cf820c87674e95a632806d99ecc5202b10157411cb18e5a3f6e771b2b2ae176b6ea35311f3f17f0eba2d2e2702d5fb0775cc4d6a0fd28c44c364e6a0eb7a8fbf1ba20127a60f83c9540907ab42cd347517a0ed0249a03d3c9792f747c3db729e4a6405f279fe9d89d848bd15311cef09e6a4d889b265771a7cb0f70f90698a18760b71931f3d18a272f00228cc04ddcae844427fc417a8ae058cac9ab85491b019b286e900c99c031879f311cedb914a7d8b18bee972e246bda51487b919b19a152f9cfed03a904f144aac93847a6e1e10aaea5b3210892431180c0cae7ea362482a78d4d03ba676ee9d3a3bc9ee1bb596808f78b78384df5fa6cfe1b5b9bea2f2e033e0085dbb796a1ca18fcae7108823b73c50b5e4611031fc4cd373f56f1b1ced4efa8070acd053a762b409d19070724367aa4faf3816e677b4af0f818660d9a668bffb0b7314baff12f8d2a408d2d642c4007da4b9ef46b14211050065cbe5a37859c6459e59b659996d3ad2e51c58b6a1b727dc7892dd6b41dc4f32b09fefa2cdabdb2f0c1150d3faedc08fe4e1c447aae15c74c2cda234f32cc21f4243833089d531dd1d36670bc3a8023ba6a7ff9a5a096a1e5033e0061ab49e0c0a3c077960b9ce11f650847989cbdd10af1736ecd1fb080ae77af73201d6d09ed93fbcdb4a6751efd63c830c641650ded40c52f3412e7aefc45a6ea96c2b090aceb535fa3f14f2b2c4e9e11787e47a49480d498acd8494d7ff0dec8c96116b01f8dc59b6111e602f56451bb45def7c39ecc79b13418d4cf09da3123a02d7f8ed366347dfee1876a3f73d0875e8874d2bab31cad79109f58b8b4dda78c7972431da9d511d6e92dcab5a118cd5675d7b2e95fcd842f4c25530131f2200c6749c5ca7ff6c2fc40daff4802a521d112698396cd3ad33a1e117565703cf5b00af83c9957ca68a22bc551676acfa4d7f9f139c1d737efa3bf3908e9648ce2473a9992947bd6879a1046a9932b4dcfabd850e91bd82f707586b99ccf9f0d8f0d28462f4b72471063bea8520b312310ede60461e988268d7317bc1c4d7d90398ffaed91808c2350968b1bc789161eb2956295bffb057fb5f4b89abe161ced5240a20b005dde587212e9d18157860a2742f06bc153c1c393d2efbf1be753ed56a39db4be09281899ef50410e99b158f7bbe03b636fca9dd7713da4635a5a74a41946df00ec450449dd9e0102b696aa871ea67212334d6ef3c033b53005e29ead454873b87eda5de19d7b105cdf4ff2425e8dde28530a4a3cb499dc6805a5ac276ab3c4f7bb6ecff37572f4ac7d62d84a04ebbb97eade6e62a43249b3e664edbe8d77e11102280065bd046bfe2207f52524b231a4d64fc7cbd0c28b7f5a9c1b162d41a35785a1f1635129eec3a0810f7dfafd3d0c8f4e55e728d63ff1f7c4841b4bfc28a2ef8dc44d893aab10602c86138f7ad60f84555455a96cfe729610f63a5f4b00b49afbcd7e98b9b02624955c74c9381604318f16b14b25328510117a52be73a118362d5851d6aad5684ab3a64b1aea469db769cf936fc959099b4f048e72daf9816b5944a380efa248b36e9c5fe4d68f77476c70ca8a52c3584a2302554fc93a1baaacab5a92275249a135c1486b3f5a5a924eacfa8633328e75aaf63c5e7c4e874475e26b64b519962dbfc2fe4adbbe9301fd7e1dc7cd8724f6307b7475cb7c25dfd7e6ec59b395119eee643ff47f0ad14c4381a239f51081ae998f4eb4c0fd255e08ffd7048899bfe512700579c5576a4a5866e58f5f9c7f78883dd0a185297d7969a4de875095cc305e5296e66781473ded683ce9eca315df7c097c4e4ef31ef6a43c0320fcf52fab82cfd6d80426563e484ae546ccb6e677b25aa58f13019b649c8e0130af9669c5b271a0edadf49173d6a90f34fe68de01a0a76e6186d43958f9b1b494b70b7928762453edaa38b8ac8b98d26530a7cce331423018f8dc6b6ed3a82daaa5f8037a1c15f8ac566203979c7171ebfe4a7168f6c4fe0aac11b83b94e61fdd926e6c8a236aa31e079b0c7b6cf9db0768a1377716edf42f0b55b22418e705d38c87b328ce5fb7891f178a642b6b4850fca2c207780803e10ab0dca10af88f72fdc26aa9b1e15591d54c7b74308b7d038ebdc66bac77f1f4919b6dd84c330d577542192bed910bab1ae0d0fbdbad4f47c88436e441c9d163cc3e8541b9a3731f45b00885a6599109653a32cdb73354683a5ed9fd18da60d9cdef335cbaf3d1ebca282159e8412a6ccb066d701adb8e78dd0dca9602e1bc8285c339cd9fa025ad5779d5eae4c95f7738262a142445532d9cb0930ed55f75603bdd79ca13b058e55a69140175b00464db21d5532f770ff5cf2f98b8b7326d25fbfe0240d2e76fda3383f6503ecfd92ec456f29e010ee420c8d8ac4d0525ec66ae240b92538315bafc3722c5f4da4f1b4ec78227d1c953f84783f586877321b13aa97d6017205e857569c6a0ab84a8c79c45539290ca87e1fbdecc22596cc6cb9fa7795acdff296892e86ac8b8ae2db50d34eb8d3535930a89b0bb4853e979d62fdc985c4a07f19e13326772602a3e0b9c02cf7ace224a2b7000ae4bbccfafad028908a3d88e354791308ff5fab47a70946b5896ae37594a3963d0fe1aa7c5b0b71d4062de28f7f74dda51725c289df4038c3becefaf20256971ccf253f7d163cf61b1bd967f35c2822055547a53a10d61546b3e7b0b1288c8bde7da95160fc4810e71d3169895d0e1891473d00c1a409d3b89fb795b6ef668d71e51fd1530b35d16d8232bb9e41afc8066d51668d86d6005550fe0e4583b796bdaecdd52413c24c48bcbdb170467b20e4f938d5ce42643e0332ff004adeae8a48aae3c683050d30605a56a9bf52f04cbff7cffa4248aaf0e9a3031fefb13a81365b10f555fe60ae531694b1bb40ba37f75e33c38c04a960b18580e1ae73d0e23bfabc824e17ceaf642509e862c7eae1ad3e1004bd77fa84bdc72af4965ca72d1ecc9c5fbc2a69a7278da8c0ef57f3d5128deaa628d6fe76fa6c0910526a9b22075d55fa681c4d04bd879088f845c122af0e25fc305e243ef841bddf518bf0bb0e5e33be3a7ce6ba2e60a2fd42b907e177c4d301d91743301fb337db008279a396fd7a37e80a18f0835980e6981bd4982a8ef3c30760deda4c0f533a2245ad5bcf24a8add58a0362f042e875c68056038574029d362bf4fb79221ed48e23cb96231d21e7a90885e52edb7342d62056dc7fb3e91ead0bd233bac919f93291fa4c252a423d34004a034b3b81b64dd45c505df4aae841881d549eb5fdc8015ecd52479375807e9440df75498603d047f1958b6bccb2670cccfb0b3013606aa48bf40caebde7d5bc1f04e0db96cfbb4ea771d5732d77274c305152f246d774522854343077d9996003eba2df0c7149a7fab10e3273f327189bc86c3887813edaf7643be4ffa2be7717e8088d029c3247f6fcd99b230f4303b3bc58f2fb276c9fe193ba2ac8ac2e22c0330f57022f565ac122a04adaf894bf243f4a48c32d2bf183aad77a7eecc7a2e6e39ab42fedea51af20031e78949e414e91e0b0562e23cf9e66e13ae27745084920b9207ed3cb415f76c8a6c35501f78cfc8b9421c1ba3f00f811f1422cdf91cb91ca2dbe4696ba67519d3b7e1aa9ac004a3dd6a9e6ab354716434987b79fa02f85e225e7c27e8b36bd523b7725848e4ff1d7a0921b7525ad7cfa93c0fc7d15a6d7fe2d2f768c44ea16c8df9d6bcd64495cf4a84cd75b800bf3abc1de745efdd53d8abc402225685a99df348087612388bd2f0881c2d11d07c0e8e93ac150d1c87ab88740c1251d66a65e1513f3fe0620aace0346e96b2f9acdc62e9699cd702be08df9c780289e8119bd24c93f78960ad4a17789cd85ebb51206c0b0db5452f92a853e6e9f9f7cc89328eb42f93fd8cf527a1495ba2a0e767d0a7dc7d7a54dce9354dc61e64f19a85e0880a8291c0512a2d658b672071dcaada7fc8b2e23913a406969dc52e4a69ea48b8cd7460fef5e7efc004eb951fa9054f808db2dca00b84ae7fd6b3331ba410e330ad3ef1988ed4f36848e36813660a7144b20dddd6b0ef87fae3d535ab607cefac82992de617210fc1fc08c4db08205395eae6ac0c0572b19da3272404e3318cda8dd2b9d38043e341a5cf59083cca04f16c0ce9f330d473ff539f064f560d80304fd8789dbcd9ee7e7d3020066768d812f1d0eef12341dd2a404be711dc04d4b9f471445cad4444ee7fd09903c554bbe1e41f4d17b0751b8068261d5a061c441644a8018fc2a41efed28a4f45d08c056081b0dae59531800b7407941d4c21713dafec55426c8a8062e44ffa3d4af0925fa1c4d1e0f1d41ec5f62c00566e7d4f91f12550aa01d652cc6eff0acf2612384672f43ad09cf651f5ff14f91f0f130d7b5dc93c2e94a85068b6f8784b7fb9038bf07dfa687aa00bccc331fdf35096e506ae73646a021769888bb9409e3bade61e66811d9f6de42b886e53c1cb9fa98c0693c67dcfc071d81f9b3f10220efb1f34d4378aeb46783d11f3e91d2bf2d91cd8fd45ad3bf646aa21f16adf1504d6548a94cffd25aca29b5a76b598a9c56c02141ba904570004268310bb4e050d81e8418d95b32e8d6e52512aabd6ab4cdea68748b122808b11a061b9a3e6cf2c907201a109870efd5a4500baf1c1b455d7d9585e1c4535fa98b0d2cdd5e055e637203a13b97610c2ef42d26e8b5fed3d2781c5b53baf6e400c63124e53279c8871fd0966556153b29df4c4d5e9db5aa0819ffe38f8670aa19d4554f653497ebdf543d9a319102a7b623f3fe1e65703bf90bfd516636051a0e5cba98eef8f1a2ca5fa8d2607e3db00f32cb00d862be6afbcedf91bfda05b2f06da008dd0929dff59a0771724d671fcd7dc8033ae51865411668cf2634b0d7635261ae554db5731005da309e76b53c0c6c48a6ee0fc8d48509b78db7b13b90f0916f679f3a276737e506a5bc2815367d87232ed761a469b64dc9e503ebf0d189422cf8fa09ba84bc5f3be17390b038930f92fb7e6dac26d86b54060421af6a850cb07258e0219e7b3dd6c2c5e987b9ace70207024cce3a1edb2f38943f1e2e6ae5a1e4f1205775b05650cf6eb80872c2330d3aeed4b7c85d9a73150ff36ea36a55429983103842a9de18cbefef567c8fdc5406cde853853a9d31b7fbc0b7e4dae61a5a10ccb072e717eeec4a15accd5ab92640311753e93a45fb85f700ebd5d2e8155f4344a699cff3d8505427d1ce49927243ef3aae02c333a5dcdf42a82afbee684670216c3754f84fa535e47029ceddbf4b0b3cd6d8e229439756139106c0184c11e7ecd9f70e6873f842196247b52ebc0e7b77b70569505ad33660e05c9373b75186418ef1d79b03a9fc071c2c207d5e4e4486472b400baa01adb0d8afc69633742921cdd3258d5aa4ab1d56d2f6dcecd56ec366dc2a71471ac41cd47d91b19bc75aac9ecff97e7ecf18b0a335767c59bae64dae25fbe9d3e1c075100455644a0f9793083b51e4cbd976fd8aae125f153b64904a33d25567b1168a58e3164343116fc104058408e653d633759745af1a0f489975a7077870ab381be04d36ff8249667069cf64e1a1fd15388ff4928b2a65638cdc37202d9ffc45e72cebe46a32562cd21315078f3dbd5546837375521ef6087610622419265d0eceedfe2c38a12b422cd24c7e95c814e37d53961ba6274699636c3d23c84dbe2b5299192e5b6a06b876d13838a85e0d88f1089b8d29aae915c08fc54e0dd44952f0d480eedc75968967f8bec8a67716c15c131b924fe15f319fcc3fe4754cb2ba3c09090195a3cdb5cfc397d6388787a6ae28c692fcef03162a62845b3a6510f393362b628f614fa56cdfa0fc067c5fc1ebfe7c563494d2b5f7c1d60c78d83dca6092a87fde0d1fc258309cb4affdd602ebba9e39cbb762db6577b233b5735aa505a1e73b71508fec36b611ff53968fb4ef000a1b77f627cc4684fb08f0fd14b96c93517ef31e79ee484119be4a715d56401b069cd1c5d48c25a2cca37b12f1dc2881415db28a7c90adaee7683926fb40e853fdfad16492697f9764de4f535cc8e23dd871833441188ef84b77686caef14d19b8efa0c9d939c899215c1f425c0533c3c32be3c969732726e5d550664203fab5d080e9191488a640f50b417e89b7372ce5fccff07b2c90cbe2c03015eaabc06cbc994f898d1d906cc8a2189806805ce8919d550f40c2b6ca676343ee369ba979701cd76f011b4ddbffe73a39339adf495a3e3b4202a909df4d4ca398c0ad03c8f0efa9611c7485d6a06c8b5efcb2eb7dc9b81796cf20e416f6c5e600273191329252f5c5d1855f404de1492a572e9d23c1489d73b7cd22a71541bd8f2418189ad024895f9fb7afbd0e3559ece172fec515ace0e94d29e50631a5e2e7234f727a945d57b7304585db44cbab4c5ceac6a391e4f7f89fe4af2114e6e654d7396836407ba61cf6dea85cc568655f4832fe11e4581596e00ccf6f8a17c894c53a35b58f3d0a0538e636aa90753e5d6f373a2248dc88ff0d05b2a139acc181c1df63bb81121d0df33de18aefac6ee6a4b62db45e35119ec07698f56ef5e3e9e5046945a49024ee31b67b08e7bbe1e1342365a97c1293a5e4faf6ebaae6187236356dfe51b62d7fdca8ca0e91717ec7103f9b7bd36758f2c7fd09d2fed1efb7a4d78b352f97039f1298a2fa001d787a59d7bd37c426e824e604e947b2cd7ef8ebfb5b708412c2ee6c1cdd3970efd8a9bd73015cd5e8b28e3699ac98d91122f4e286ab871190943961956438e62fa57de504c623be3bfb22789a8595822f13d69351c28b9f60d07b4fa4e33d0265df691eaf214417840bc9bff95ad87f249b51ac624722092e66084f47a3055ab30adb076b7ff82bbcf0beeca816befea133fe5410968652bfe441814b37ee20ab62a1e0282e14a5d3965cf9d996479291d1c936bc012720800ede19ffdc984d9a78f600986ecd76ad7d665707674d1e38c6dc15e1d60753968a1fad1cbb1ec3858e0bf50ed9239c08adc9c24f089abd7f4837cb53cb451e0f421635eac764de34d3b8fee7971f6b0f39d710846a1db30d3cd44a5ace8164f45cb7ab686997efa7436ae50bcf7ec9ebd543756731e35075e9f6144568b57d6441097899fe777de7352d0b132ce23ae8b594426b79c3e7e450e3980fe10bda9ba064f928d17f029f03ba0839cbad56d6e1380c3a04373a62a88ba2e91716dc8d65bd7898b69da00d719d52cb8005ad46c44c34058bb8efb4447edfc65aee610d28c92e6cd29e29</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">You know what this means.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> letter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂记录</title>
      <link href="/2022/11/issues/"/>
      <url>/2022/11/issues/</url>
      
        <content type="html"><![CDATA[<h1 id="常见小问题"><a href="#常见小问题" class="headerlink" title="常见小问题"></a>常见小问题</h1><h2 id="终端无法运行脚本"><a href="#终端无法运行脚本" class="headerlink" title="终端无法运行脚本"></a>终端无法运行脚本</h2><p>参考<a href="https://go.microsoft.com/fwlink/?LinkID=135170">Microsoft文档</a> 中about_Execution_Policies</p><h2 id="遇到的一些问题"><a href="#遇到的一些问题" class="headerlink" title="遇到的一些问题"></a>遇到的一些问题</h2><p>1 Q&amp;E</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">platform unsupported hexo-deployer-git@3.0.0 › hexo-fs@3.1.0 › chokidar@3.5.3 › fsevents@~2.3.2 Package require os(darwin) not compatible with your platform(win32)</span><br><span class="line">[fsevents@~2.3.2] optional install error: Package require os(darwin) not compatible with your platform(win32)</span><br></pre></td></tr></table></figure><p>A 这是一个可以忽略的错误，fsevents是可选的依赖，只能应用于maxOS系统，不适合Windows或者Linux，也就是忽略即可</p>]]></content>
      
      
      
        <tags>
            
            <tag> record&amp;reference </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游玩LaTeX</title>
      <link href="/2022/11/noteLaTeX/"/>
      <url>/2022/11/noteLaTeX/</url>
      
        <content type="html"><![CDATA[<h1 id="LaTeX笔记"><a href="#LaTeX笔记" class="headerlink" title="LaTeX笔记"></a>LaTeX笔记</h1><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//English</span><br><span class="line"><span class="keyword">\documentclass</span>&#123;article&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line">&quot;Hello world!&quot; from <span class="keyword">\LaTeX</span></span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br><span class="line"></span><br><span class="line">//中文</span><br><span class="line"><span class="keyword">\documentclass</span>&#123;ctexart&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line">“你好，世界！” 来自 <span class="keyword">\LaTeX</span>&#123;&#125; 的问候  //怀疑这里新版本不需要&#123;&#125;占空格了</span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure><h2 id="相关概念辨析"><a href="#相关概念辨析" class="headerlink" title="相关概念辨析"></a>相关概念辨析</h2><h3 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h3><p>排版引擎是编译源代码并生成文档的程序，如pdfLaTeX、XeLaTeX等。有时也称为编译器</p><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>是定义了一组命令的代码集。如LaTeX。高纳德本人也编写了一个简单的plain TeX格式，但仍不便于使用</p><h3 id="编译命令"><a href="#编译命令" class="headerlink" title="编译命令"></a>编译命令</h3><p>是实际调用的、结合了引擎和格式的命令。如<code>xelatex</code>命令是结合了XeTeX引擎和LaTeX格式的一个编译命令</p>]]></content>
      
      
      
        <tags>
            
            <tag> LaTeX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chem-E-Car 小车动力控制电路部分记录</title>
      <link href="/2022/10/Car_Doc/"/>
      <url>/2022/10/Car_Doc/</url>
      
        <content type="html"><![CDATA[<h2 id="材料选用"><a href="#材料选用" class="headerlink" title="材料选用"></a>材料选用</h2><p>主板：ARDUINO UNO R3</p><p>拓展板：ARDUINO MOTOR SHIELD REV3</p>]]></content>
      
      
      
        <tags>
            
            <tag> Chem-E-Car </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ToDo</title>
      <link href="/2022/08/Todo/"/>
      <url>/2022/08/Todo/</url>
      
        <content type="html"><![CDATA[<h1 id="接下来的任务"><a href="#接下来的任务" class="headerlink" title="接下来的任务"></a>接下来的任务</h1><ul><li>hexo更深度自定义主题</li><li>favicon自定义</li><li>404页面</li><li>图床建设</li><li>图片模式选用</li><li>用户名重新选择</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> todo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Notes For Git</title>
      <link href="/2022/07/noteGit/"/>
      <url>/2022/07/noteGit/</url>
      
        <content type="html"><![CDATA[<h1 id="Notes-For-Git"><a href="#Notes-For-Git" class="headerlink" title="Notes For Git"></a>Notes For Git</h1><h2 id="Settings"><a href="#Settings" class="headerlink" title="Settings"></a>Settings</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">$ git config --list --show-origin</span><br><span class="line">file:D:/Git/etc/gitconfig       diff.astextplain.textconv=astextplain</span><br><span class="line">file:D:/Git/etc/gitconfig       filter.lfs.clean=git-lfs clean -- %f</span><br><span class="line">file:D:/Git/etc/gitconfig       filter.lfs.smudge=git-lfs smudge -- %f</span><br><span class="line">file:D:/Git/etc/gitconfig       filter.lfs.process=git-lfs filter-process</span><br><span class="line">file:D:/Git/etc/gitconfig       filter.lfs.required=<span class="literal">true</span></span><br><span class="line">file:D:/Git/etc/gitconfig       http.sslbackend=openssl</span><br><span class="line">file:D:/Git/etc/gitconfig       http.sslcainfo=D:/Git/mingw64/ssl/certs/ca-bundle.crt</span><br><span class="line">file:D:/Git/etc/gitconfig       core.autocrlf=<span class="literal">true</span></span><br><span class="line">file:D:/Git/etc/gitconfig       core.fscache=<span class="literal">true</span></span><br><span class="line">file:D:/Git/etc/gitconfig       core.symlinks=<span class="literal">false</span></span><br><span class="line">file:D:/Git/etc/gitconfig       pull.rebase=<span class="literal">false</span></span><br><span class="line">file:D:/Git/etc/gitconfig       credential.helper=manager</span><br><span class="line">file:C:/Users/[]/.gitconfig        user.name=[]</span><br><span class="line">file:C:/Users/[]/.gitconfig        user.email=[]@[]</span><br><span class="line"></span><br><span class="line">$ git config --global user.name <span class="string">&quot;a&quot;</span></span><br><span class="line">$ git config --global user.email <span class="string">&quot;@&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ git config --global core.editor <span class="string">&quot;code --wait&quot;</span></span><br><span class="line">$ git config --global core.editor <span class="string">&quot;code --wait&quot;</span></span><br><span class="line"></span><br><span class="line">$ git config --list</span><br><span class="line">$ git config user.name</span><br><span class="line"></span><br><span class="line">$ git config --global init.defaultBranch main</span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">help</span> &lt;verb&gt;</span><br><span class="line">$ git &lt;verb&gt; --<span class="built_in">help</span></span><br><span class="line">$ man git-&lt;verb&gt;</span><br></pre></td></tr></table></figure><p>There levels: <code>--local</code> &gt; <code>--global</code> &gt; <code>--system</code></p><p>On Windows systems, Git looks for the <code>.gitconfig</code> file in the $HOME directory (C:\Users$USER for most people). It also still looks for <code>[path]/etc/gitconfig</code>, although it’s relative to the MSys root, which is wherever you decide to install Git on your Windows system when you run the installer. </p><h2 id="Basics"><a href="#Basics" class="headerlink" title="Basics"></a>Basics</h2><h3 id="initializing"><a href="#initializing" class="headerlink" title="initializing"></a>initializing</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> D:/my_project</span><br><span class="line">$ git init</span><br></pre></td></tr></table></figure><p>to control a repository with git and this will create a file named <code>.git</code></p><p>we can initialize a repository like this:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add *.c</span><br><span class="line">$ git add LICENSE</span><br><span class="line">$ git commit -m <span class="string">&#x27;Initial project version&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="cloning"><a href="#cloning" class="headerlink" title="cloning"></a>cloning</h3><p>we can clone a repository like this:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/</span><br></pre></td></tr></table></figure><p>if want a new name </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> &lt;url&gt; name</span><br></pre></td></tr></table></figure><p>and there are other protocols that can be chosen(SSH)</p><h3 id="recording-changes"><a href="#recording-changes" class="headerlink" title="recording changes"></a>recording changes</h3><p>two states : tracked or untracked. To CHECK this :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with <span class="string">&#x27;origin/master&#x27;</span>.</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br><span class="line">$ git status -s</span><br><span class="line">M README</span><br><span class="line">MM Rakefile</span><br><span class="line">A lib/git.rb</span><br><span class="line">M lib/simplegit.rb</span><br><span class="line">?? LICENSE.txt</span><br></pre></td></tr></table></figure><p>There are two columns to the output — the left-hand column indicates the status of the staging area and the right-hand column indicates the status of the working tree. </p><h3 id="Ignoring-Files"><a href="#Ignoring-Files" class="headerlink" title="Ignoring Files"></a>Ignoring Files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- .gitignore</span><br><span class="line">$ <span class="built_in">cat</span> .gitignore</span><br><span class="line">*.[oa]</span><br><span class="line">*~</span><br><span class="line"><span class="comment"># ignore all .a files</span></span><br><span class="line">*.a</span><br><span class="line"><span class="comment"># but do track lib.a, even though you&#x27;re ignoring .a files above</span></span><br><span class="line">!lib.a</span><br><span class="line"><span class="comment"># only ignore the TODO file in the current directory, not subdir/TODO</span></span><br><span class="line">/TODO</span><br><span class="line"><span class="comment"># ignore all files in any directory named build</span></span><br><span class="line">build/</span><br><span class="line"><span class="comment"># ignore doc/notes.txt, but not doc/server/arch.txt</span></span><br><span class="line">doc/*.txt</span><br><span class="line"><span class="comment"># ignore all .pdf files in the doc/ directory and any of its subdirectories</span></span><br><span class="line">doc/**/*.pdf</span><br></pre></td></tr></table></figure><h3 id="Viewing-Your-Staged-and-Unstaged-Changes"><a href="#Viewing-Your-Staged-and-Unstaged-Changes" class="headerlink" title="Viewing Your Staged and Unstaged Changes"></a>Viewing Your Staged and Unstaged Changes</h3><p><code>git diff</code> shows you the exact lines added and removed — the patch, as it were</p><h3 id="Commit-Your-Changes"><a href="#Commit-Your-Changes" class="headerlink" title="Commit Your Changes"></a>Commit Your Changes</h3><p><code>git commit</code> 这样需要打开编辑器输入</p><p><code>git commmit -m &quot;There is message&quot;</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">&quot;Story 182: fix benchmarks for speed&quot;</span></span><br><span class="line">[master 463dc4f] Story 182: fix benchmarks <span class="keyword">for</span> speed</span><br><span class="line">2 files changed, 2 insertions(+)</span><br><span class="line">create mode 100644 README</span><br></pre></td></tr></table></figure><p><code>git commit -a</code> 可以跳过stage阶段</p><h3 id="Removing-Files"><a href="#Removing-Files" class="headerlink" title="Removing Files"></a>Removing Files</h3><p>remove it from your tracked files, and also removes the file from your working directory so you don’t see it as an untracked file the next time around</p><p><code>rm</code> 直接删除，但是不stage</p><p><code>git rm</code> 删除，但是已经stage</p><p>If you modified the file or had already added it to the staging area, you must force the removal with the <code>-f</code> option. </p><p>to keep the file in your working tree but remove it from your staging area.</p><p><code>git rm --cached README</code></p><h3 id="Moving-Files"><a href="#Moving-Files" class="headerlink" title="Moving Files"></a>Moving Files</h3><p>重命名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">mv</span> README.md README</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with <span class="string">&#x27;origin/master&#x27;</span>.</span><br><span class="line">Changes to be committed:</span><br><span class="line">(use <span class="string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">renamed: README.md -&gt; README</span><br></pre></td></tr></table></figure><p>相当于</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mv</span> README.md README</span><br><span class="line">$ git <span class="built_in">rm</span> README.md</span><br><span class="line">$ git add README</span><br></pre></td></tr></table></figure><h3 id="Viewing-the-Commit-History"><a href="#Viewing-the-Commit-History" class="headerlink" title="Viewing the Commit History"></a>Viewing the Commit History</h3><p><code>git log</code> 查看commit history</p><p><code>git log -patch</code> 显示每次的commit的不同之处</p><p><code>git log -2</code> 只看最近两条</p>]]></content>
      
      
      
        <tags>
            
            <tag> Git notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Algorithm</title>
      <link href="/2022/06/noteAlgorithm/"/>
      <url>/2022/06/noteAlgorithm/</url>
      
        <content type="html"><![CDATA[<h1 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h1><h3 id="1dim-peak-finder"><a href="#1dim-peak-finder" class="headerlink" title="1dim peak finder"></a>1dim peak finder</h3><p>$$\Theta (n)  $$ </p><p>if we adopt <strong>divide &amp; conquer</strong> </p><p>the complexity will be </p><p>$$T(n) &#x3D; T(\frac n2)+ \Theta(1)$$</p><p>and there is the base case :</p><p>$$T(1)&#x3D;\Theta(1)$$</p><p>thus </p><p>$$<br>T(n)&#x3D; \Theta(1) +\Theta(1)+…+\Theta(1)<br>    &#x3D; \Theta(\log _{2} n)<br>$$</p>]]></content>
      
      
      
        <tags>
            
            <tag> algorithm notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>My Raspberry Pi</title>
      <link href="/2021/02/recordRaspberryPi/"/>
      <url>/2021/02/recordRaspberryPi/</url>
      
        <content type="html"><![CDATA[<h2 id="About-Raspberry-Pi"><a href="#About-Raspberry-Pi" class="headerlink" title="About Raspberry Pi"></a>About Raspberry Pi</h2><p>这里本来打算放张图片</p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><h3 id="最理想情况"><a href="#最理想情况" class="headerlink" title="最理想情况"></a>最理想情况</h3><p>官网下载Pi OS镜像，烧录SD卡，连接好键盘显示屏，启动</p><h3 id="无显示屏"><a href="#无显示屏" class="headerlink" title="无显示屏"></a>无显示屏</h3><ul><li>开启ssh访问，在boot目录新建<code>ssh</code>的不带后缀名的空文件。</li><li>用RJ45网线连接笔记本电脑和树莓派。</li><li>等待树莓派启动完毕，打开笔记本电脑的网络和共享中心，可以看到出现了一个未识别网络，连接方式是以太网。然后再查看分配给这个以太网的接口IP地址（如192.168.137.1）</li><li>手机开热点，通过它可以让树莓派联网。在网络和共享中心中，点击无线网络-&gt;属性-&gt;共享 ，给“允许其它网络用户通过此计算机的internet来连接”打勾，然后确定。</li><li>打开CMD，输入以下命令查看网络接口信息：<code>arp -a</code></li><li>在前面查到的接口：192.168.137.1 下方找到第一个连接的ip地址，即为树莓派的ip地址。</li><li>打开PuTTY<ul><li>host 填入: 开发板 ip 即可。</li><li>用户名、密码同串口登陆一致（默认：pi、raspberry）</li></ul></li></ul><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="更新软件源"><a href="#更新软件源" class="headerlink" title="更新软件源"></a>更新软件源</h3><p>首先查看自己树莓派系统版本，一般有jessie,stretch,buster,wheezy这4个版本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">No LSB modules are available.</span><br><span class="line">Distributor ID:Raspbian</span><br><span class="line">Description:Raspbain GNU/Linux 10 (buster)</span><br><span class="line">Release:10</span><br><span class="line">Codename: buster</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure><p>开始换源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/apt/sources.list</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure><p>将默认的内容删掉或者用<code>#</code>号注释，改为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/   buster main contrib non-free rpi</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main contrib non-free rpi</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure><p>或者用以下地址代替上面的地址栏</p><p>中山大学<br><a href="https://link.zhihu.com/?target=http://mirror.sysu.edu.cn/raspbian/raspbian/">Raspbian http://mirror.sysu.edu.cn/raspbian/raspbian/</a></p><p>中国科学技术大学<br><a href="https://link.zhihu.com/?target=http://mirrors.ustc.edu.cn/raspbian/raspbian/">Raspbian http://mirrors.ustc.edu.cn/raspbian/raspbian/</a></p><p>清华大学<br><a href="https://link.zhihu.com/?target=http://mirrors.tuna.tsinghua.edu.cn/raspbian/">Raspbian </a><a href="https://link.zhihu.com/?target=http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/">http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/</a></p><p>华中科技大学<br><a href="https://link.zhihu.com/?target=http://mirrors.hustunique.com/raspbian/raspbian/">Raspbian http://mirrors.hustunique.com/raspbian/raspbian/</a></p><p><a href="https://link.zhihu.com/?target=http://mirrors.hustunique.com/archlinuxarm/">Arch Linux ARM http://mirrors.hustunique.com/archlinuxarm/</a></p><p>大连东软信息学院源（北方用户）</p><p><a href="https://link.zhihu.com/?target=http://mirrors.neusoft.edu.cn/raspbian/raspbian/">Raspbian http://mirrors.neusoft.edu.cn/raspbian/raspbian/</a></p><p>（可参考Ubuntu配置）</p><p>再更新</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure><p>更新系统软件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt upgrade</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure><h2 id="Web项目"><a href="#Web项目" class="headerlink" title="Web项目"></a>Web项目</h2><h3 id="LNSP"><a href="#LNSP" class="headerlink" title="LNSP"></a>LNSP</h3><p>Linux Nginx SQLite PHP</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install nginx</span><br><span class="line">sudo apt install php7.3</span><br><span class="line">sudo apt install php7.3-fpm</span><br><span class="line">sudo apt install php7.3-sqlite</span><br><span class="line">sudo apt install php7.3-common</span><br><span class="line">sudo apt install sqlite</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure><ul><li>启动 nginx</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/nginx start</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure><ul><li>修改 nginx 的配置文件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/nginx/sites-available/default</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure><ul><li>PHP 脚本支持</li></ul><p>找到 php 的定义段，将这些行的注释去掉 ，修改后内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># Default server configuration</span><br><span class="line">#</span><br><span class="line">server &#123;</span><br><span class="line">        listen 80 default_server;</span><br><span class="line">        listen [::]:80 default_server;</span><br><span class="line"> </span><br><span class="line">        root /var/www/html;</span><br><span class="line"> </span><br><span class="line">        # Add index.php to the list if you are using PHP</span><br><span class="line">        index index.html index.htm index.nginx-debian.html index.php;</span><br><span class="line"> </span><br><span class="line">        server_name _;</span><br><span class="line"> </span><br><span class="line">        location / &#123;</span><br><span class="line">                 # First attempt to serve request as file, then</span><br><span class="line">                 # as directory, then fall back to displaying a 404.</span><br><span class="line">                 try_files $uri $uri/ =404;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        # pass PHP scripts to FastCGI server</span><br><span class="line">        #</span><br><span class="line">        location ~ \.php$ &#123;</span><br><span class="line">                 # include snippets/fastcgi-php.conf;</span><br><span class="line">                 #</span><br><span class="line">                 # # With php-fpm (or other unix sockets):</span><br><span class="line">                 fastcgi_pass unix:/run/php/php7.3-fpm.sock;</span><br><span class="line">                 # # With php-cgi (or other tcp sockets):</span><br><span class="line">                 # fastcgi_pass 127.0.0.1:9000;</span><br><span class="line">                 # 设置脚本文件请求的路径</span><br><span class="line">                 fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;</span><br><span class="line">                 # 引入fastcgi的配置文件 </span><br><span class="line">                 include fastcgi_params;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure><ul><li>重新加载 nginx 的配置</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/nginx reload</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure><ul><li>测试 html</li></ul><p>通过主机的 IE 访问树莓派，可以看到主页 (表示 Web 服务器已正常启动)</p><ul><li>测试 php</li></ul><p>输入下列命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 777 /var/            #下面三行给文件授予权限</span><br><span class="line">sudo chmod 777 /var/www</span><br><span class="line">sudo chmod 777 /var/www/html</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure><p>在树莓派中生成一<code>php</code>文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /var/www/index.php</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure><p>在文件中输入以下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php  </span><br><span class="line">  print &lt;&lt;&lt; EOT  </span><br><span class="line">&lt;!doctype html&gt;  </span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;  </span><br><span class="line">&lt;head&gt;  </span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;  </span><br><span class="line">&lt;title&gt;Test successful&lt;/title&gt;  </span><br><span class="line">&lt;/head&gt;  </span><br><span class="line">&lt;body&gt;  </span><br><span class="line">&lt;h1&gt;Test successful&lt;/h1&gt;  </span><br><span class="line">&lt;p&gt;Congratulations.&lt;/p&gt;  </span><br><span class="line">&lt;p&gt;Your webserver and PHP are working.&lt;/p&gt;  </span><br><span class="line">&lt;/body&gt;  </span><br><span class="line">&lt;/html&gt;  </span><br><span class="line">EOT;  </span><br><span class="line"></span><br><span class="line">?&gt;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure><p>到此为止，lnsp就安装完毕</p><h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><p>官方</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://nodejs.org/dist/v12.16.1/node-v00.00.0-linux-armv7l.tar.xz</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure><p>国内镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://npm.taobao.org/mirrors/node/latest/node-v00.00.0-linux-armv7l.tar.xz</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure><p>解压：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xz -d node-v12.13.1-linux-armv7l.tar.xz</span><br><span class="line">tar -xavf node-v12.13.1-linux-armv7l.tar</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure><p>将系统内原本存在的<code>/usr/bin.node</code>删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -rf /usr/bin/node</span><br><span class="line">#如果不存在，忽略此步骤</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure><p>解压后，将二进制包移动到<code>/usr/local/node</code>下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mv ./node-v10.0.0-linux-armv7l /usr/local/node</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure><p>为<code>node</code>和<code>npm</code>建立软连接，在终端输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /usr/local/node/bin/node /usr/bin/node</span><br><span class="line">sudo ln -s /usr/local/node/bin/npm /usr/bin/npm</span><br><span class="line">#这类似于Windows中的快捷方式</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure><p>通过查看<code>node</code>和<code>npm</code>版本的方式来查看是否成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v &amp;&amp; npm -v</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure><p>可以看到对应的版本号说明安装成功</p><p>由于国内网速问题<code>npm</code>包管理器的速度会较慢，利用<code>npm</code>安装<code>cnpm</code>某宝源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure><p>为<code>cnpm</code>建立软连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /usr/local/node/bin/cnpm /usr/bin/cnpm</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure><blockquote><p>Windows cnpm</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm install cnpm -g</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure><p>If you’re in China, maybe you should install it from our <a href="https://npm.taobao.org/">China mirror</a>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm install cnpm -g --registry=https://r.npm.taobao.org</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></blockquote><h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h3><p>至于软件，暂时选用Hexo，虽然还有Typecho、WordPress备选，但是先尝试这个。</p><p>主题参考</p><ul><li><a href="https://github.com/fluid-dev/hexo-theme-fluid">fluid</a>（主要看上了打字机特效）</li><li><a href="https://linhong.me/2020/01/27/hexo-theme-aomori/">Aomori</a>（看上了右边栏特效）</li><li><a href="https://github.com/lixuetaoleo/hexo-theme-leo">Ieo</a>（封面）</li><li><a href="https://sharvaridesai.github.io/hexo-theme-edinburgh-demo/">Edinburgh</a>（看设计感）</li><li><a href="https://mrwillcom.github.io/">mrwill</a>（设计感）</li></ul><h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><p>在本地完成hexo渲染，部署public文件夹到树莓派，完整文件夹git到github仓库。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="Linux-常用命令"><a href="#Linux-常用命令" class="headerlink" title="Linux 常用命令"></a>Linux 常用命令</h3><p>文件改名 <code>sudo mv test.txt new.txt\</code></p><ul><li><strong>mkdir xxx</strong> 创建文件夹xxx</li><li><strong>mkdir a1 a2 a3</strong> 批量创建文件夹 a1、文件夹 a2、文件夹 a3</li><li><strong>mkdir -p b1&#x2F;b2&#x2F;b3</strong> 连续创建文件夹 b1、文件夹 b2、文件夹 b3</li></ul><h3 id="RPI串口电路"><a href="#RPI串口电路" class="headerlink" title="RPI串口电路"></a>RPI串口电路</h3>]]></content>
      
      
      
        <tags>
            
            <tag> Raspberry Pi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A Guide to rebuid the workplace</title>
      <link href="/2020/07/guide/"/>
      <url>/2020/07/guide/</url>
      
        <content type="html"><![CDATA[<h1 id="重新搭建现有工作环境的指南"><a href="#重新搭建现有工作环境的指南" class="headerlink" title="重新搭建现有工作环境的指南"></a>重新搭建现有工作环境的指南</h1><h2 id="电脑配置清单"><a href="#电脑配置清单" class="headerlink" title="电脑配置清单"></a>电脑配置清单</h2><ul><li>华硕(ASUS)PRIME Z390-A 主板 现价1749元 <a href="https://item.jd.com/100000542145.html">链接</a></li><li>英特尔(Intel)i7-9700KF 约价2799元 <a href="https://item.jd.com/100002106617.html#none">链接</a></li><li>英伟达(NVIDIA)GTX1660 约价1799元 <a href="https://item.jd.com/100003739778.html#none">链接</a>（不确定）</li><li>金士顿(Kingston)DDR4 2400 16GB 现价549元 <a href="https://item.jd.com/2551276.html">链接</a></li><li>三星(SAMSUNG)250GB SSD固态硬盘 M.2接口(NVMe协议) 现价499元 <a href="https://item.jd.com/100002183459.html">链接</a></li><li>西部数据(WD)蓝盘 1TB 现价299元 <a href="https://item.jd.com/675971.html">链接</a></li><li>罗技(Logitech)K310 键盘 现价149元 <a href="https://item.jd.com/712162.html#none">链接</a>（首选）<ul><li>罗技（G）G610机械键盘 现价479元 <a href="https://item.jd.com/3034311.html#none">链接</a>（备选）</li></ul></li><li>罗技（Logitech）M100r 鼠标 现价52.9元 <a href="https://item.jd.com/692919.html">链接</a>（首选）<ul><li>罗技（G）G502 HERO主宰者有线鼠标 现价379元 <a href="https://item.jd.com/100001691967.html#product-detail">链接</a>（备选）</li></ul></li><li>AOC I2490VXH5&#x2F;BS 23.8英寸 现价779元 <a href="https://item.jd.com/100002222528.html?dist=jd#none">链接</a></li><li>乔思伯（JONSBO）U5 银色 ATX机箱 现价499元 <a href="https://item.jd.com/8885801.html#crumb-wrap">链接</a>（不确定）</li><li>酷冷至尊（CoolerMaster） T20 CPU 散热器 现价49元 <a href="https://item.jd.com/19988002706.html#product-detail">链接</a></li><li>长城（GreatWall）额定500W HOPE-6000DS 电源 现价269元 <a href="https://item.jd.com/876229.html">链接</a></li><li>灵蛇（LINGSHE）鼠标垫 现价4.9元 <a href="https://item.jd.com/4062692.html">链接</a></li></ul><p>小计：9565.9元</p><h3 id="机械键盘品牌参考"><a href="#机械键盘品牌参考" class="headerlink" title="机械键盘品牌参考"></a>机械键盘品牌参考</h3><p>宁芝mini84</p><p>阿米洛sword</p><p>Filco</p><p>Leopold</p><p>杜伽</p><h2 id="应用列表"><a href="#应用列表" class="headerlink" title="应用列表"></a>应用列表</h2><h3 id="普通使用"><a href="#普通使用" class="headerlink" title="普通使用"></a>普通使用</h3><ul><li>chrome</li><li>Potplayer</li><li>Bandizip</li><li>Lantern</li><li>TranslucentTB</li><li>Xmind<ul><li>mindmaster</li><li>freemind</li></ul></li><li>坚果云</li><li>Joplin</li><li>Everything</li><li>Wox</li><li>网易云音乐</li><li>小黑盒</li><li>幕布</li><li>有道云笔记</li><li>Steam</li><li>Pokemmo</li><li>QuickLook</li></ul><h3 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h3><h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><ul><li>Git</li><li>Node.js</li><li>Hexo</li><li>Java JDk</li><li>Python</li><li>MinGW-64w</li><li>Tex Live</li><li>VMware Workstation<ul><li>ubuntu</li></ul></li><li>wsl子系统<ul><li>Ubuntu</li><li>VcXsrv</li></ul></li></ul><h4 id="编辑器-x2F-IDE"><a href="#编辑器-x2F-IDE" class="headerlink" title="编辑器&#x2F;IDE"></a>编辑器&#x2F;IDE</h4><ul><li><p>Visual Studio Code</p></li><li><p>Atom</p></li><li><p>Visual Studio</p></li><li><p>Codelite</p></li><li><p>Typora</p></li><li><p>Vim</p></li><li><p>Neovim</p></li><li><p>Eclipse</p></li><li><p>JetBrains系</p><ul><li>CLion(附破解)</li></ul></li></ul><h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><ul><li><p>Mockplus(做原型可选，主用XD)</p></li><li><p>达芬奇</p></li><li><p>Zeplin</p></li><li><p>Gimp</p></li><li><p>Adobe系</p><ul><li>Creative Cloud</li><li>Photoshop</li><li>Premiere Pro</li><li>Media ENcoder</li><li>Lightroom Classic</li><li>XD</li><li>Illustrator</li><li>Audition</li></ul></li></ul><h3 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h3><ul><li><p>FL Studio</p></li><li><p>guitar pro 7</p></li></ul><h3 id="字体资源列表"><a href="#字体资源列表" class="headerlink" title="字体资源列表"></a>字体资源列表</h3><p>文件在字体文件夹里</p><ul><li>Source Code Pro —adobe</li><li>思源黑体</li><li>思源宋体</li><li>禹卫书法行书简体</li></ul><h2 id="文件夹"><a href="#文件夹" class="headerlink" title="文件夹"></a>文件夹</h2><ul><li>Private</li><li>Material</li><li>Project</li></ul><h2 id="附各类应用配置"><a href="#附各类应用配置" class="headerlink" title="附各类应用配置"></a>附各类应用配置</h2><h4 id="Chrome"><a href="#Chrome" class="headerlink" title="Chrome"></a>Chrome</h4><p>&#x2F;&#x2F;不知道用户同步能不能用</p><p>扩展：gooreplacerv3.9（放在工具文件夹）</p><p>书签:</p><ul><li><p><a href="https://www.github.com/">Github</a></p></li><li><p><a href="https://translate.google.cn/?hl=zh-CN&tab=TT">Google 翻译</a></p></li><li><p><a href="https://www.zhihu.com/">知乎</a></p></li><li><p><a href="https://www.bilibili.com/">Bilibli</a></p></li><li><p><a href="https://www.jiumodiary.com/">鸠摩搜索</a></p></li><li><p><a href="https://bitbucket.org/product/">Bitbucket</a></p></li><li><p><a href="https://phys.org/">Phys.org</a></p></li><li><p><a href="https://www.feynmanlectures.caltech.edu/">The Feynman Lectures on Physics</a></p></li><li><p><a href="https://www.audiolibrary.com.co/">Audio Library</a></p></li><li><p><a href="http://www.doyoudo.com/">doyoudo</a></p></li><li><p><a href="http://pengzhihui.xyz/">稚晖的个人站</a></p></li><li><p><a href="https://xenwayne.top/">XenWayne‘s Blog</a></p></li><li><p><a href="https://rafaltomal.com/">Rafal Tomal</a></p></li><li><p><a href="https://esappear.github.io/clover/">Clover Tuan</a></p></li><li><p><a href="https://www.arduino.cc/">Arduino</a></p></li><li><p><a href="https://www.raspberrypi.org/">Raspberry Pi</a></p></li><li><p><a href="https://www.dandyweng.com/">翁天信 · Dandy Weng 的个人网站主页</a></p></li><li><p><a href="https://www.julydate.com/">七夏浅笑</a></p></li><li><p><a href="https://www.lhteam.top/">LHteam</a></p></li><li><p><a href="https://element.eleme.cn/#/zh-CN">Element</a></p></li><li><p><a href="https://crashcourse.club/">CrashCourse</a></p></li><li><p><a href="https://bigjpg.com/zh">Bigjpg</a></p></li><li><p><a href="https://dribbble.com/">Dribbble</a></p></li><li><p><a href="https://www.webdesignrankings.com/resources/lolcolors/">LOL Colors - Curated color palette inspiration</a></p></li><li><p><a href="https://www.bootcss.com/p/websafecolors/">Web安全色</a></p></li><li><p><a href="https://color.adobe.com/create/color-wheel/">adobeColor</a></p></li><li><p><a href="https://flatuicolors.com/">Palettes</a></p></li><li><p><a href="https://colorsupplyyy.com/app">Color Picker</a></p></li><li><p><a href="https://mycolor.space/">ColorSpace</a></p></li><li><p><a href="https://www.iconfont.cn/">iconfont</a></p></li><li><p><a href="https://www.freepik.com/">Free Vectors, Photos and PSD Downloads | Freepik</a></p></li><li><p><a href="https://unsplash.com/">Unsplash</a></p></li><li><p><a href="https://balsamiq.com/">Balsamiq</a></p></li><li><p><a href="https://www.easyicon.net/">Easyicon</a></p></li><li><p><a href="https://magdeleine.co/">Magdeleine</a></p></li><li><p><a href="https://www.splitshire.com/">SplitShire</a></p></li><li><p><a href="https://flaticons.net/">FlatIcons</a></p></li><li><p><a href="https://www.91sotu.com/">搜图导航</a></p></li><li><p><a href="https://huaban.com/">花瓣网</a></p></li><li><p><a href="https://acg.rip/">ACG.RIP</a></p></li><li><p><a href="http://www.xuanfengge.com/funny/html5/element/">HTML5元素周期表</a></p></li><li><p><a href="https://zigzagpack.com/">ZigZag Pack</a></p></li><li><p><a href="https://www.udemy.com/">Udemy</a></p></li><li><p><a href="https://www.yuque.com/guigumentor/guigu">鬼谷·全球 · 语雀</a></p></li><li><p><a href="https://liam.page/2014/09/08/latex-introduction/">一份其实很短的 LaTeX 入门文档 | 始终</a></p></li><li><p><a href="https://www.jianshu.com/p/b31ae75ab6df">好书整理-朗道十卷+费曼物理学讲义+中英文 - 简书</a></p></li><li><p><a href="https://apps.evozi.com/apk-sownloader/">Evozi Apps</a></p></li><li><p><a href="https://magi.com/">Magi</a></p></li><li><p><a href="https://www.geogebra.org/">GeoGebra</a></p></li></ul><h4 id="Visual-Studio-Code"><a href="#Visual-Studio-Code" class="headerlink" title="Visual Studio Code"></a>Visual Studio Code</h4><p>插件：</p><ul><li>Auto Rename Tag</li><li>Autoprefixer</li><li>beautify</li><li>Prettier - Code formatter(format on save 查找是否应用存文件时格式化)</li><li>Bracket Pair Colorizer 2</li><li>Chinese(Simplified)Language Pack for Visual Studio Code</li><li>Code Spell Checker</li><li>file-size</li><li>Guides</li><li>Highlight</li><li>Image preview</li><li>Latex Workshop(需额外配置，附配置文件)</li><li>Live Server</li><li>Markdown PDF</li><li>Markdown Preview Enhanced</li><li>Markdown Theme Kit</li><li>markdownlint</li><li>Material Theme</li><li>Community Material Theme</li><li>Material Theme Icons</li><li>Path intellisense</li><li>Settings Sync</li><li>SVG</li><li>C&#x2F;C++</li><li>Cobalt Next</li><li>Cobalt2 Theme Official</li><li>Code Runner</li><li>Marp for VS Code</li><li>Path Interllisense</li></ul><p>另附:</p><p>C语言环境设置<code>.vscode</code>在project的C文件夹里</p><p>VS Code 设置json文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;workbench.iconTheme&quot;</span><span class="punctuation">:</span> <span class="string">&quot;material-icon-theme&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;editor.renderIndentGuides&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;workbench.colorTheme&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Cobalt Next&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;cSpell.userWords&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;Bandizip&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;HWND&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;Lightroom&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;Minecraft&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;Mockplus&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;Mware&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;Photoshop&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;Potplayer&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;Typora&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;Xmind&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;Zahlen&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;Zeplin&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;anchorjs&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;cnzz&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;doyoudo&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;favicon&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;hexo&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;iconfont&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;mware&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;subseteq&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;tencent&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;v&quot;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;workbench.statusBar.visible&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;editor.fontFamily&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Source Code Pro,Consolas, &#x27;Courier New&#x27;, monospace&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;workbench.startupEditor&quot;</span><span class="punctuation">:</span> <span class="string">&quot;newUntitledFile&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;C_Cpp.updateChannel&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Insiders&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Latex workshop</span></span><br><span class="line">    <span class="attr">&quot;latex-workshop.latex.tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="comment">// 编译工具和命令</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;latexmk&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;latexmk&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;-synctex=1&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-interaction=nonstopmode&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-file-line-error&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-pdf&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-outdir=%OUTDIR%&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;%DOC%&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;env&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xelatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xelatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;-synctex=1&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-interaction=nonstopmode&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-file-line-error&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-pdf&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-outdir=%OUTDIR%&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;%DOC%&quot;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lualatexmk&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;latexmk&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;-synctex=1&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-interaction=nonstopmode&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-file-line-error&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-lualatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-outdir=%OUTDIR%&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;%DOC%&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;env&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;latexmk_rconly&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;latexmk&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;%DOC%&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;env&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pdflatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pdflatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;-synctex=1&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-interaction=nonstopmode&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-file-line-error&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;%DOC%&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;env&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bibtex&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bibtex&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;%DOCFILE%&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;env&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;latex-workshop.latex.recipes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xelatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;xelatex&quot;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;latexmk 🔃&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;latexmk&quot;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xelatex ➞ xelatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;xelatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;xelatex&quot;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xelatex ➞ bibtex ➞ xelatex × 2&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;xelatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;bibtex&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;xelatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;xelatex&quot;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;latexmk (latexmkrc)&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;latexmk_rconly&quot;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;latexmk (lualatex)&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;lualatexmk&quot;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pdflatex ➞ bibtex ➞ pdflatex × 2&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;pdflatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;bibtex&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;pdflatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;pdflatex&quot;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;latex-workshop.view.pdf.viewer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;external&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;latex-workshop.view.pdf.external.command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:/SumatraPDF/SumatraPDF.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;%PDF%&quot;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;latex-workshop.view.pdf.external.synctex&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="comment">//正向搜索</span></span><br><span class="line">        <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:/SumatraPDF/SumatraPDF.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;-forward-search&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;%TEX%&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;%LINE%&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;%PDF%&quot;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;latex-workshop.latex.clean.fileTypes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;*.aux&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.bbl&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.blg&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.idx&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.ind&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.lof&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.lot&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.out&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.toc&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.acn&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.acr&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.alg&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.glg&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.glo&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.gls&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.ist&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.fls&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.log&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.fdb_latexmk&quot;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;latex-workshop.latex.autoBuild.run&quot;</span><span class="punctuation">:</span> <span class="string">&quot;never&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;terminal.integrated.shell.windows&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C:\\Windows\\System32\\cmd.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;sync.gist&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ce4d87f82ed3f5648debe41732530e35&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;cSpell.enableFiletypes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;tex&quot;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">    </span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="Atom"><a href="#Atom" class="headerlink" title="Atom"></a>Atom</h4><p>插件：</p><ul><li>atom-beautify</li><li>atom-gpp-compiler</li><li>atom-live-server</li><li>atom-markdown-table-editor</li><li>atom-material-syntax</li><li>atom-material-syntax-dark</li><li>atom-material-syntax-light</li><li>atom-material-ui</li><li>atom-minimap-plus</li><li>atom-quick-highlight</li><li>atom-script</li><li>atom-simplified-chinese-menu</li><li>busy-signal</li><li>color-picker</li><li>emmet-atom</li><li>file-icons</li><li>intentions</li><li>linter</li><li>linter-gcc</li><li>linter-javac</li><li>linter-jshint</li><li>linter-markdown</li><li>linter-phpcs</li><li>linter-pylint</li><li>linter-ui-default</li><li>markdown-preview-enhanced</li><li>monoid-ui</li><li>monoid-syntax</li><li>seti-syntax</li><li>seti-ui</li></ul><h4 id="CLion"><a href="#CLion" class="headerlink" title="CLion"></a>CLion</h4><p>破解获取链接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://idea.medeming.com/jets/</span><br><span class="line">http://idea.medeming.com/jihuo/</span><br></pre></td></tr></table></figure><h4 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h4><p>主题</p><ul><li>Barfi</li><li>Cobalt</li><li>Github</li><li>Gitlab</li><li>Newsprint</li><li>Night</li><li>PixyII</li><li>Vue Dark</li><li>Vue</li><li>Whitey</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> guide </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Trip to Ubuntu</title>
      <link href="/2020/03/testUbuntu/"/>
      <url>/2020/03/testUbuntu/</url>
      
        <content type="html"><![CDATA[<h2 id="Trip-to-Ubuntu"><a href="#Trip-to-Ubuntu" class="headerlink" title="Trip to Ubuntu"></a>Trip to Ubuntu</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前几天我在Microsoft Store里发现了Ubuntu，它是运行在Windows上的子系统，第一时间我就开始了Ubuntu的配置探索之旅。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>我在Microsoft Store安装之后，发现它是装在C盘系统盘的，为了节省C盘空间，我采取了转移到非系统盘的方式</p><p>通过安装，我定位到了它的安装路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\xxxx\AppData\Local\Packages\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc</span><br></pre></td></tr></table></figure><p>接着，我将它卸载，通过创建软链接来解决这个问题</p><p>先在想要安装的位置创建了Ubuntu文件夹</p><p>然后打开<code>cmd</code>终端，输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mklink /j C:\Users\XXXX\AppData\Local\Packages\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc  D:\Ubuntu\</span><br></pre></td></tr></table></figure><p>创建成功后，再重新在Microsoft Store中安装Ubuntu</p><p>安装过程中如果出现了安装失败的问题，可以运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">icacls D:\Ubuntu /grant <span class="string">&quot;用户名:(OI)(CI)(F)&quot;</span></span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h4 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h4><p>清华源</p><ul><li>网址：<a href="https://link.zhihu.com/?target=https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/">https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/</a></li><li>源地址：<a href="https://link.zhihu.com/?target=https://mirrors.tuna.tsinghua.edu.cn/ubuntu/">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line"># 预发布软件源，不建议启用</span><br><span class="line"># deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure><p>阿里源</p><ul><li>网址：<a href="https://link.zhihu.com/?target=https://opsx.alibaba.com/guide?lang=zh-CN&document=69a2341e-801e-11e8-8b5a-00163e04cdbb">https://opsx.alibaba.com/guide?lang=zh-CN&document=69a2341e-801e-11e8-8b5a-00163e04cdbb</a></li><li>源地址：<a href="https://link.zhihu.com/?target=http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 默认注释了源码仓库，如有需要可自行取消注释</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line"># deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line"># deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line"># deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line"># 预发布软件源，不建议启用</span><br><span class="line"># deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line"># deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure><p>中科大源</p><ul><li>网址：<a href="https://link.zhihu.com/?target=http://mirrors.ustc.edu.cn/help/ubuntu.html">http://mirrors.ustc.edu.cn/help/ubuntu.html</a></li><li>源地址：<a href="https://link.zhihu.com/?target=https://mirrors.ustc.edu.cn/ubuntu/">https://mirrors.ustc.edu.cn/ubuntu/</a></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 默认注释了源码仓库，如有需要可自行取消注释</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line"># 预发布软件源，不建议启用</span><br><span class="line"># deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure><p>网易源</p><ul><li>网址：<a href="https://link.zhihu.com/?target=http://mirrors.163.com/.help/ubuntu.html">http://mirrors.163.com/.help/ubuntu.html</a></li><li>源地址：<a href="https://link.zhihu.com/?target=http://mirrors.163.com/">http://mirrors.163.com</a></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 默认注释了源码仓库，如有需要可自行取消注释</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.163.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line"># deb-src http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line"># deb-src http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line"># deb-src http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line"># 预发布软件源，不建议启用</span><br><span class="line"># deb http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line"># deb-src http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure><p>先对系统给的镜像源进行备份，以防止出现问题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo <span class="built_in">cp</span> /etc/apt/sources.list /etc/apt/sources.list.backup </span><br></pre></td></tr></table></figure><p>然后，修改数据源配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vim /etc/apt/sources.list</span><br></pre></td></tr></table></figure><p>选择一个源添加到文件最前面或直接将官方的源注释掉替换掉原文件</p><p>更新软件源中的所有软件列表：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br></pre></td></tr></table></figure><p>更新软件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get upgrade</span><br></pre></td></tr></table></figure><p>更新系统版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get dist-upgrade</span><br></pre></td></tr></table></figure><p>下载中文语言包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install language-pack-zh-han*</span><br></pre></td></tr></table></figure><h4 id="安装-C-x2F-C-开发环境"><a href="#安装-C-x2F-C-开发环境" class="headerlink" title="安装 C&#x2F;C++ 开发环境"></a>安装 C&#x2F;C++ 开发环境</h4><p>安装编译工具包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install build-essential</span><br></pre></td></tr></table></figure><p>安装 nginx 依赖库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install libpcre3 libpcre3-dev libpcrecpp0 libssl-dev zlib1g-dev</span><br></pre></td></tr></table></figure><h4 id="图形界面"><a href="#图形界面" class="headerlink" title="图形界面"></a>图形界面</h4><p>首先安装使用VcXsrv Windows X Server</p><p>启动Launcher，首次启动自动进入界面设置后，选择：“one large window”，Display number设置成0，其它默认即可：</p><p><strong>安装桌面环境</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ubuntu-desktop unity compizconfig-settings-manager</span><br></pre></td></tr></table></figure><p>启动之前安装的X-Windows，在Bash中执行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span>  DISPLAY=localhost:0</span><br><span class="line">ccsm</span><br></pre></td></tr></table></figure><p><strong>启动compiz (打开桌面)</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compiz</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>first blog</title>
      <link href="/2020/02/first-blog/"/>
      <url>/2020/02/first-blog/</url>
      
        <content type="html"><![CDATA[<h2 id="这是我的第一条blog"><a href="#这是我的第一条blog" class="headerlink" title="这是我的第一条blog"></a>这是我的第一条blog</h2><p>今天我捣鼓着使用 hexo + Github 的方式搭建了自己的博客，从今天开始维护，希望自己能坚持下去。</p><p>加油鸭！！！</p>]]></content>
      
      
      
        <tags>
            
            <tag> first blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
