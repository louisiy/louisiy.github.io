<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>程设课笔记</title>
      <link href="/2023/05/c&amp;c++/"/>
      <url>/2023/05/c&amp;c++/</url>
      
        <content type="html"><![CDATA[<h2 id="C-对C的扩充"><a href="#C-对C的扩充" class="headerlink" title="C++对C的扩充"></a>C++对C的扩充</h2><p>在C++中引入术语stream(流)，指的是来自设备的一个数据流。</p><p>在输入操作中，字节从输入设备流向内存</p><p>在输出操作中，字节从内存流向输出设备</p><p>头文件iostream中定义了输入流cin和输出流cout对象</p><h3 id="用cout进行输出"><a href="#用cout进行输出" class="headerlink" title="用cout进行输出"></a>用<code>cout</code>进行输出</h3><p>cout表示输出流对象，与它相关联的设备是显示器。cout必须和输出运算符&lt;&lt;一起使用，表示将其后面的数据插入到输出流中去。</p><pre><code class="c++">cout = c + out//c -&gt; char</code></pre><p>举例:</p><pre><code class="c++">#include &lt;iostream&gt;using namespace std;int main()&#123;    int i =1;    float f = 3.14;    char c = &#39;A&#39;, str[]=&quot;hello,world\n&quot;;    cout &lt;&lt; i;    cout &lt;&lt; f;    cout &lt;&lt; c;    cout &lt;&lt; str;    cout &lt;&lt; i &lt;&lt; f &lt;&lt; c &lt;&lt; str &lt;&lt; endl;&#125;</code></pre><h3 id="用cin进行输出"><a href="#用cin进行输出" class="headerlink" title="用cin进行输出"></a>用<code>cin</code>进行输出</h3><p>cin表示输入流对象，与它相关联的输入输出设备是键盘。当我们从键盘输入字符串时，形成了输入流（数据流），用提取操作符&gt;&gt;将数据流储存到一个事先定义好的变量中。</p><pre><code class="c++">cin = c + in;</code></pre><p>举例：</p><pre><code class="c++">#include &lt;iostream&gt;using namespace std;int main()&#123;    int i;    float f;    char c, str[20];    cin &gt;&gt; i &gt;&gt; f &gt;&gt; c &gt;&gt; str;&#125;// 以空白字符（空格、制表符、换行、回车）作为输入数据之间的间隔//输入一个字符可以使用：cin.get(c);//输入一个字符串可用：cin.getline(str,20);</code></pre><h3 id="C-对数据类型的扩充"><a href="#C-对数据类型的扩充" class="headerlink" title="C++对数据类型的扩充"></a>C++对数据类型的扩充</h3><h4 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h4><p>取值为：true或false</p><pre><code class="c++">bool RealMonkey = true;bool RealMonkey, PrettyWoman;RealMoney = false;PrettyWoman =false;</code></pre><h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><p>引用（reference）的作用是为一个变量起一个别名</p><pre><code class="c++">int LiBai;int &amp;LiTaiBai = LiBai; // 必须初始化int &amp;QingLianJuShi =LiBai;int &amp;ShiXian = LiBai;int &amp;JiuXian = LiBai;LiBai = 49;LiTaiBai ++;</code></pre><h4 id="引用作为函数参数"><a href="#引用作为函数参数" class="headerlink" title="引用作为函数参数"></a>引用作为函数参数</h4><pre><code class="c++">// 使得在被调用的函数中可以修改作为实参的变量的值void main()&#123;    int salary, nCars, nHouses;    salary = 6000;    nCars = 0;    nHouses = 0;    DayDreaming(salary, nCars, nHouses);    cout &lt;&lt; salary &lt;&lt; &quot; &quot; &lt;&lt; nCars &lt;&lt; &quot; &quot; &lt;&lt; nHouses;&#125;void DayDreaming(int &amp;salary, int &amp;cars, int &amp;houses)&#123;    salary = salary * 3;    cars += 2;    houses ++;&#125;</code></pre><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><h3 id="对象（Object）"><a href="#对象（Object）" class="headerlink" title="对象（Object）"></a>对象（Object）</h3><p>什么是对象</p><ul><li>在认知心理学中，对象是指可触摸、可见或思维可理解的东西</li><li>软件工程中的定义：对象是一个具有状态、行为和标识的实体。相似对象的结构和行为在它们的共有的类中定义</li></ul><p>对象的属性：对象所具有的一些特征成为属性。这些属性会有其对应的值</p><p>对象的状态：一个对象的状态包括该对象的所有属性及每个属性的值</p><p>对象的行为：对象不是孤立存在的，一个对象可以作用于其他对象，也可被其他对象所作用，从而导致状态的变化</p><p>对象的操作：一个对象（类）对外提供的服务</p><h3 id="类（class）"><a href="#类（class）" class="headerlink" title="类（class）"></a>类（class）</h3><p>一组具有类似属性和行为的对象</p><h4 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h4><p>类：抽象地定义了该类对象地本质特征（属性和操作），类型定义、模板</p><p>对象：类的实例，具有各自的属性值，占用存储空间</p><h2 id="类的定义与使用"><a href="#类的定义与使用" class="headerlink" title="类的定义与使用"></a>类的定义与使用</h2><pre><code class="c++">//类定义class Baby&#123;    //成员变量        //成员函数      &#125;;//类实例Baby dawa, erwa;</code></pre><h3 id="成员变量的初始化"><a href="#成员变量的初始化" class="headerlink" title="成员变量的初始化"></a>成员变量的初始化</h3><ul><li>在<strong>定义类时</strong>即可确定，用构造函数，且无需参数</li><li>在<strong>创建对象时</strong>确定，用带参数的构造函数</li><li>在<strong>创建对象后</strong>才能确定，用成员函数</li></ul><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><pre><code class="c++">class CLASSNAME&#123;    CLASSNAME()&#123;            &#125;    CLASSNAME([ARGUMENTS])&#123;//带参数的构造函数            &#125;&#125;;</code></pre><ul><li><p>构造函数的名字 &#x3D; 类的名字</p></li><li><p>没有返回值类型：不返回任何数据</p></li><li><p>创建对象时自动调用，初始化成员变量</p></li><li><p>每个类需要至少一个构造函数，若不写，则默认为：</p><pre><code class="c++">CLASSNAME()&#123;    &#125;</code></pre></li></ul><p>类初始化时构造函数的调用顺序：</p><ul><li>初始化对象的储存空间或为零或为null</li><li>按顺序分别调用类成员变量和对象成员的初始化</li><li>调用构造函数</li></ul><pre><code class="c++">#include &lt;iostream&gt;using namespace std;class Dollar&#123;    public:        int n;        Dollar()&#123;                n = 100;                cout &lt;&lt; n &lt;&lt; &quot; dollars come to my home&quot; &lt;&lt;endl;            &#125;&#125;;class Money&#123;    public:        Dollar d;        Money()&#123;                cout &lt;&lt; &quot;All money come to my home&quot; &lt;&lt; endl;            &#125;&#125;;int main()&#123;    Money m;        return 0;&#125;</code></pre><p>运行结果为：</p><pre><code class="bash">$ .\test.exe100 dollars come to my homeAll money come to my home</code></pre><h4 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h4><p>调用时可以不需要实参的构造函数</p><ul><li>参数列表为空</li><li>全部参数都有默认值（略）</li></ul><p>每个类只能有一个默认的构造函数，否则将编译错误</p><p>一个构造函数的例子：</p><pre><code class="c++">class Baby &#123;public:    char name[20];    char gender;    int age;    double weight;    int numPoops;    Baby(char myname[], char g, double w) //创建对象时确定                                       : age(0), numPoops(0) &#123;//初始化成员列表，在定义类的时候确定        strcpy(name, myname);        gender = g;         weight = w;    &#125;   &#125;;</code></pre><h4 id="调用带参数的构造函数"><a href="#调用带参数的构造函数" class="headerlink" title="调用带参数的构造函数"></a>调用带参数的构造函数</h4><pre><code class="c++">//创建对象Baby dawa = Baby(&quot;大力士&quot;, &#39;M&#39;, 20);//或者Baby dawa(&quot;大力士&quot;, &#39;M&#39;, 20);</code></pre><h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><p>形如</p><pre><code class="c++">class Baby&#123;    public:        ...            void poop()&#123;                numPoops ++;                cout &lt;&lt; &quot;Dear mother,&quot; &lt;&lt; &quot;I have pooped.&quot; &lt;&lt; endl;            &#125;            void sayHi()&#123;            cout &lt;&lt; &quot;Hi, my name is &quot; &lt;&lt; name &lt;&lt; endl;        &#125;        void eat(double foodWeight)&#123;            weight +=foodWeight;        &#125; &#125;</code></pre><p>综上，完整的Baby类为</p><pre><code class="c++">class Baby&#123;    public:        char name[20];        char gender;        int age;        double weight;        int numPoops;        Baby(char myname[], char g, double w) //创建对象时确定                                       : age(0), numPoops(0) &#123;//初始化成员列表，在定义类的时候确定            strcpy(name, myname);            gender = g;             weight = w;        &#125;        void poop()&#123;                numPoops ++;                cout &lt;&lt; &quot;Dear mother,&quot; &lt;&lt; &quot;I have pooped.&quot; &lt;&lt; endl;            &#125;            void sayHi()&#123;            cout &lt;&lt; &quot;Hi, my name is &quot; &lt;&lt; name &lt;&lt; endl;        &#125;        void eat(double foodWeight)&#123;            weight +=foodWeight;        &#125; &#125;</code></pre><h3 id="函数声明与实现分离"><a href="#函数声明与实现分离" class="headerlink" title="函数声明与实现分离"></a>函数声明与实现分离</h3><p>对于普通函数，函数原型与函数的实现可以分离，即把函数原型放在文件开头，而把函数的实现放在后面</p><p>类似的，类的成员函数也可以这样做，函数的实现需要用<code>::</code>来表示它是哪一个类的成员函数</p><pre><code class="c++">//baby.h 头文件class Baby&#123;    public:        char name[20];        char gender;        int age;        double weight;        int numPoops;        Baby(char*, char, double);        void poop();        void sayHi();        void eat(double foodweight);&#125;//baby.cpp 源文件#include &quot;baby.h&quot;Baby::Baby(char myname[], char g, double w)&#123;    ...    &#125;void Baby::poop()&#123;    ...&#125;void Baby::eat(double foodweight)&#123;    weight +=foodweight;&#125;</code></pre><h3 id="类的使用"><a href="#类的使用" class="headerlink" title="类的使用"></a>类的使用</h3><pre><code class="c++">//类定义class Baby&#123;...&#125;//类实例Baby dawa = Baby(&quot;大力士&quot;, &#39;M&#39;, 20);Baby erwa = Baby(&quot;千里眼&quot;, &#39;M&#39;, 16);Baby sanwa = Baby(&quot;钢筋铁骨&quot;, &#39;M&#39;, 18);Baby siwa = Baby(&quot;火神&quot;, &#39;M&#39;, 16);</code></pre><h4 id="访问成员变量"><a href="#访问成员变量" class="headerlink" title="访问成员变量"></a>访问成员变量</h4><p><code>Object.FIELD_NAME</code></p><pre><code class="c++">cout &lt;&lt; dawa.name &lt;&lt; endl;cout &lt;&lt; erwa.weight &lt;&lt; endl;cout &lt;&lt; sanwa.numPoops &lt;&lt; endl;</code></pre><h4 id="调用成员参数"><a href="#调用成员参数" class="headerlink" title="调用成员参数"></a>调用成员参数</h4><p><code>Object.METHOD_NAME([参数])</code></p><pre><code class="c++">dawa.sayHi();//把sayHi作用于dawaerwa.eat(1);//把eat(1)作用于erwasanwa.poop();//把poop作用于sanwa</code></pre><h2 id="进一步内容"><a href="#进一步内容" class="headerlink" title="进一步内容"></a>进一步内容</h2><h3 id="对象的赋值"><a href="#对象的赋值" class="headerlink" title="对象的赋值"></a>对象的赋值</h3><h2 id="常用的C-类"><a href="#常用的C-类" class="headerlink" title="常用的C++类"></a>常用的C++类</h2><h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><h3 id="抽象与封装"><a href="#抽象与封装" class="headerlink" title="抽象与封装"></a>抽象与封装</h3><ul><li>将类的本质行为和它的具体实现分开</li><li>外部观点：类的对外接口</li><li>内部观点：类的具体实现</li></ul><table><thead><tr><th>关键字</th><th>含义</th></tr></thead><tbody><tr><td>public</td><td>任何地方都可以访问（的成员变量和方法）</td></tr><tr><td>protected</td><td>类及其子类的函数可访问，但对象.成员不行</td></tr><tr><td>private</td><td>只能在类内部访问</td></tr><tr><td>未指定（默认）</td><td>等价于private</td></tr></tbody></table><h3 id="直接访问成员变量"><a href="#直接访问成员变量" class="headerlink" title="直接访问成员变量"></a>直接访问成员变量</h3><pre><code class="c++">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class BankAccount&#123;    public:        string number;        double balance;        string password;  &#125;;int main()&#123;    BankAccount account;    account.balance = 1000000;    cout &lt;&lt; &quot;password is:&quot; &lt;&lt; account.password &lt;&lt; endl;    return 0;&#125;</code></pre><h3 id="不能直接访问成员变量"><a href="#不能直接访问成员变量" class="headerlink" title="不能直接访问成员变量"></a>不能直接访问成员变量</h3><pre><code class="c++">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class BankAccount&#123;    private:        string number;        double balance;        string password;      public:        void deposit(double money)&#123;            balance += money;        &#125;        void withdraw(double money)&#123;            balance -= money;        &#125;        void resetPassword(string pwd)&#123;            password = pwd;        &#125;&#125;;int main()&#123;    BankAccount account;    account.deposit(1000000);    string pwd =&quot;abc123&quot;;    account.resetPassword(pwd);    return 0;&#125;</code></pre><p>接口函数命名：<code>getXXX()</code> 查询类；<code>setXXX()</code> 修改类</p><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>其他类型转字符串</p><p>C语言的实现办法</p><pre><code class="c">char *itoa(int value,char *string,int radix);char *fcvt(double value, int ndigit,int *decpt, int *sign);char *ultoa(unsigned long value, char *string, int radix);</code></pre><p>C++11的实现方法</p><pre><code class="c++">std::to_string(int i)std::to_string(unsigned u)std::to_string(long l)std::to_string(unsigned long l)std::to_string(float f)std::to_string(double d)</code></pre><p>例子：小狗阿黄</p><pre><code class="c++">#include &lt;iostream&gt;using namespace std;class Dog&#123;    public:        void bark()&#123;            cout &lt;&lt; &quot;汪汪汪！&quot; &lt;&lt; endl;        &#125;        void bark(bool injured)&#123;            if(injured)&#123;                cout &lt;&lt; &quot;呜咽...&quot; &lt;&lt;endl;            &#125;        &#125;        void bark(int mood)&#123;            if(mood == 0)&#123;                cout &lt;&lt; &quot;汪汪汪！&quot; &lt;&lt; endl;            &#125;else if(mood == 1)&#123;                cout &lt;&lt; &quot;汪！汪汪！&quot; &lt;&lt; endl;            &#125;else if(mood == 2)&#123;                cout &lt;&lt; &quot;呜-呜&quot; &lt;&lt; endl;            &#125;        &#125;&#125;;void main()&#123;    Dog ahuang;    ahuang.bark();    ahuang.bark(true);    ahuang.bark(1);&#125;</code></pre><p>重载的条件</p><p>成员方法重名，但是</p><ul><li>参数个数不同</li><li>参数的类型不同</li><li>顺序不同</li></ul><pre><code class="c++">class Calculation&#123;    public:        void sum(int a,int b)&#123;            cout &lt;&lt; (a+b);        &#125;        void sum(int a,int b,int c)&#123;            cout &lt;&lt; (a+b+c);        &#125;&#125;class Calculation2&#123;    public:        void sum(int a,int b)&#123;            cout &lt;&lt; (a+b);        &#125;        void sum(double a,double b)&#123;            cout &lt;&lt; (a+b);                   &#125;&#125;class Calculation3&#123;    public:        void sum(int a,double b)&#123;            cout &lt;&lt; (a+b);        &#125;        void sum(double b,int a)&#123;            cout &lt;&lt; (a+b);        &#125;&#125;void main(String args[])&#123;    Calculation obj;    obj.sum(10,10,10);    obj.sum(20,20);        Calculation2 obj2;    obj2.sum(10.5,10.5);    obj2.sum(20,20);        Calculation3 obj3;    obj3.sum(10,10.5);    obj3.sum(20.5,20);&#125;</code></pre><p>参数个数相同，各个参数的数据类型和顺序也相同，但变量名不同。不能够构成函数重载。</p><pre><code class="c++">int move(string snake);int move(string turtle);</code></pre><h2 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h2><p>寄存器、栈（stack）、堆（heap）、静态数据区</p><h3 id="内存分布"><a href="#内存分布" class="headerlink" title="内存分布"></a>内存分布</h3><p>        <span class="lazyload-img-span">        <img              data-src="C:\Users\Louisiy\AppData\Roaming\Typora\typora-user-images\image-20230531174310352.png" >        </sapn>      </p>]]></content>
      
      
      
        <tags>
            
            <tag> C , C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>the C programing Language NOTES</title>
      <link href="/2023/04/TheC/"/>
      <url>/2023/04/TheC/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>现在学习进度，准备开始读一遍传世经典K&amp;R</p><h2 id="A-tutorial-introduction"><a href="#A-tutorial-introduction" class="headerlink" title="A tutorial introduction"></a>A tutorial introduction</h2><h2 id="Types-Operators-and-Expressions"><a href="#Types-Operators-and-Expressions" class="headerlink" title="Types, Operators and Expressions"></a>Types, Operators and Expressions</h2><h2 id="Control-Flow"><a href="#Control-Flow" class="headerlink" title="Control Flow"></a>Control Flow</h2><h2 id="Functions-and-program-structure"><a href="#Functions-and-program-structure" class="headerlink" title="Functions and program structure"></a>Functions and program structure</h2><h2 id="Pointers-and-Arrays"><a href="#Pointers-and-Arrays" class="headerlink" title="Pointers and Arrays"></a>Pointers and Arrays</h2><h2 id="Structures"><a href="#Structures" class="headerlink" title="Structures"></a>Structures</h2><h2 id="Input-and-Output"><a href="#Input-and-Output" class="headerlink" title="Input and Output"></a>Input and Output</h2><h2 id="The-UNIX-System-Interface"><a href="#The-UNIX-System-Interface" class="headerlink" title="The UNIX System Interface"></a>The UNIX System Interface</h2><h2 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h2><ul><li>Reference Manual </li><li>Standard Library</li><li>Summary of Changes</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo主题开发</title>
      <link href="/2023/02/HexoTheme/"/>
      <url>/2023/02/HexoTheme/</url>
      
        <content type="html"><![CDATA[<h2 id="主题开发"><a href="#主题开发" class="headerlink" title="主题开发"></a>主题开发</h2><p>由于之前采用的white主题的开发者已将开源主题归档跑路不再维护，并且相较于本人在其他地方所看到的个人博客还有很多可以修改的可能，故决定在此基础之上进行修改，最后做出另一款自用的主题</p><p>在正式修改开发前需要先学习hexo主题的制作知识，以下综述总结于网络</p><h3 id="预备"><a href="#预备" class="headerlink" title="预备"></a>预备</h3><p>针对Hexo主题的开发需要了解</p><ul><li><p>HTML&#x2F;CSS&#x2F;JavaScript</p></li><li><p>模板引擎语法，如EJS&#x2F;Jade&#x2F;Swig</p></li><li><p>CSS预处理器，如SASS&#x2F;LESS&#x2F;Stylus</p></li><li><p>YML语法</p></li><li><p>Hexo文档</p><ul><li>Hexo | 变量</li><li>Hexo | 辅助函数</li></ul></li></ul><h4 id="主题基本结构"><a href="#主题基本结构" class="headerlink" title="主题基本结构"></a>主题基本结构</h4><p>一般来说hexo的主题需要有以下页面：</p><ul><li>首页 <code>index</code></li><li>存档页 <code>archive</code></li><li>标签文章列表页 <code>tag</code></li><li>分类文章列表页 <code>category</code></li><li>文章详情页 <code>post</code></li><li>页面详情页 <code>page</code></li></ul><p>这些文件是Hexo在生成HTML文件时要用到的，全部放在<code>layout</code>文件夹中。这些页面内重复的组件代码，如页头页脚的部分，可以单独提取出来进行复用</p><p>此外，还有JS&#x2F;CSS&#x2F;图片&#x2F;favicon.ico等文件直接放入source文件夹里，不需要页面引用</p><h4 id="主题文件夹结构"><a href="#主题文件夹结构" class="headerlink" title="主题文件夹结构"></a>主题文件夹结构</h4><pre><code>├─languages//多语言文件夹│  └─en.yml├─layout//主题布局模板│  ├─layout.ejs│  └─_partial//各页面共享的模板部分├─scripts//hexo脚本插件目录，可以编写一些辅助函数脚本├─source//资源文件目录，包括页面样式，js脚本等│  ├─css│  │ └─index.styl│  └─js└─_config.yml//主题配置文件</code></pre><h4 id="应用主题"><a href="#应用主题" class="headerlink" title="应用主题"></a>应用主题</h4><p>修改<strong>站点配置文件</strong>中的主题配置，使用主题：</p><pre><code class="yaml"># Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: theme-example</code></pre><h3 id="详细"><a href="#详细" class="headerlink" title="详细"></a>详细</h3><h4 id="主题配置文件"><a href="#主题配置文件" class="headerlink" title="主题配置文件"></a>主题配置文件</h4><p><code>_config.yml</code>:</p><pre><code class="yaml">menu:  home: /  categories: /categories  tags: /tags  archives: /archives  about: /about  language: zh-CN# 或者多个配置文件language: - zh-CN - en</code></pre><h4 id="多语言支持"><a href="#多语言支持" class="headerlink" title="多语言支持"></a>多语言支持</h4><p>Hexo 支持多语言显示，在主题的 <code>languages</code> 文件夹中，存放具体的多语言文件，可以是 YML 或者 JSON 文件。再在主配置文件 <code>_config.yml</code> 中使用下面的方法来指定具体的使用的配置文件名：</p><pre><code class="yaml">language: zh-CN# 或者多个配置文件language: - zh-CN - en</code></pre><p>像下面这样组织语言文件，<code>languages/en.yml</code>：</p><pre><code class="yaml">archive_title: Archivescategory_title: Categorytag_title: Tag</code></pre><p>在模板里，当需要在页面中显示文字时，可以使用 Hexo 提供的帮助函数 <code>__()</code> &#x2F; <code>_p()</code> 来读取具体的值，如：</p><pre><code class="ejs">&#123;% if is_archive() %&#125;  &#123;% set pageTitle = _p('archive_title') %&#125;  &#123;% endif %&#125;   page_title </code></pre><h4 id="HTML框架"><a href="#HTML框架" class="headerlink" title="HTML框架"></a>HTML框架</h4><pre><code>├─layout   ├─layout.ejs//通用的布局文件模板   ├─index.ejs//继承layout.ejs布局模板，首页   ├─post.ejs//文章详情页   ├─archive.ejs//归档页     ├─page.ejs//自定义页面模板   └─_partial     ├─head.ejs     ├─header.ejs     ├─footer.ejs     ├─category.ejs     ├─tag.ejs     ├─custom.ejs     └─paginator.ejs</code></pre><p><code>layout/layout.ejs</code>:</p><pre><code class="ejs">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;%- partial(&#39;_partial/head&#39;) %&gt;//引入head.ejs&lt;body&gt;    &lt;div class=&quot;container&quot;&gt;    &lt;%- partial(&#39;_partial/header&#39;) %&gt;//引入header.ejs    &lt;%- body %&gt;   //新增的ejs文件将内容填充在这里    &lt;%- partial(&#39;_partial/footer&#39;) %&gt;  //引入footer.ejs    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; </code></pre><blockquote><p>partial()函数的作用是可以引入其他模板文件，详情参考hexo文档</p></blockquote><p><code>layout/_partial/head.ejs</code>:</p><pre><code class="ejs">&lt;head&gt;    &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;    &lt;meta content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot; name=&quot;viewport&quot;&gt;    &lt;title&gt;&lt;%= config.title %&gt;&lt;/title&gt;//config全局变量，包含站点配置&lt;/head&gt;</code></pre><p><code>layout/_partial/header.ejs</code>：</p><pre><code class="ejs">&lt;header class=&quot;header&quot;&gt;    &lt;div class=&quot;title&quot;&gt;        &lt;a href=&quot;&lt;%= url_for() %&gt;&quot; class=&quot;logo&quot;&gt;&lt;%= config.title %&gt;&lt;/a&gt;    &lt;/div&gt;    &lt;nav class=&quot;navbar&quot;&gt;        &lt;ul class=&quot;menu&quot;&gt;            &lt;% for (name in theme.menu) &#123; %&gt;            //theme.menu获取theme_config中导航菜单的设置            &lt;li class=&quot;menu-item&quot;&gt;                &lt;a href=&quot;&lt;%- url_for(theme.menu[name]) %&gt;&quot; class=&quot;menu-item-link&quot;&gt;&lt;%= name %&gt;&lt;/a&gt;            &lt;/li&gt;            &lt;% &#125; %&gt;        &lt;/ul&gt;    &lt;/nav&gt;&lt;/header&gt;</code></pre><p><code>layout/_partial/footer.ejs</code>：</p><pre><code class="ejs">&lt;footer&gt;    &lt;p&gt;Theme is &lt;a href=&quot;/&quot; target=&quot;_blank&quot;&gt;Theme-example&lt;/a&gt; by &lt;a href=&quot;&lt;%= config.url %&gt;&quot; target=&quot;_blank&quot;&gt;&lt;%= config.author %&gt;&lt;/a&gt;&lt;/p&gt;    &lt;p&gt;Powered by &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;hexo&lt;/a&gt; &amp;copy; &lt;%- date(Date.now(), &#39;YYYY&#39;) %&gt;&lt;/p&gt;&lt;/footer&gt;</code></pre><p><code>index.ejs</code>:</p><pre><code class="ejs">//变量page会根据不同的页面拥有不同的属性，page变量的posts属性可以拿到文章数据的集合//这个posts属性需要在layout的文件夹里新建post.ejs的文件才能获得对象的属性&lt;section class=&quot;posts&quot;&gt;    &lt;% page.posts.each(function (post) &#123; %&gt;//显示文章列表    &lt;article class=&quot;post&quot;&gt;        &lt;div class=&quot;post-title&quot;&gt;            &lt;a class=&quot;post-title-link&quot; href=&quot;&lt;%- url_for(post.path) %&gt;&quot;&gt;&lt;%= post.title %&gt;&lt;/a&gt;        &lt;/div&gt;        &lt;div class=&quot;post-content&quot;&gt;            &lt;%- post.content %&gt;  //显示文章的全部内容        &lt;/div&gt;        或者：        &lt;div class=&quot;post-content&quot;&gt;               &lt;%- post.excerpt %&gt;    //excerpt属性可获取文章的摘录部分，即文章中&lt;!--more--&gt;标记前的内容    //如果未标记，那么post.excerpt会是空的          &lt;/div&gt;        &lt;div class=&quot;post-meta&quot;&gt;            &lt;span class=&quot;post-time&quot;&gt;&lt;%- date(post.date, &quot;YYYY-MM-DD&quot;) %&gt;&lt;/span&gt;            //        &lt;/div&gt;    &lt;/article&gt;    &lt;% &#125;) %&gt;&lt;/section&gt;</code></pre><p> <code>post.ejs</code>:</p><pre><code class="ejs">&lt;article class=&quot;post&quot;&gt;    &lt;div class=&quot;post-title&quot;&gt;        &lt;h2 class=&quot;title&quot;&gt;&lt;%= page.title %&gt;&lt;/h2&gt;    &lt;/div&gt;    &lt;div class=&quot;post-meta&quot;&gt;        &lt;span class=&quot;post-time&quot;&gt;&lt;%- date(page.date, &quot;YYYY-MM-DD&quot;) %&gt;&lt;/span&gt;    &lt;/div&gt;    &lt;div class=&quot;post-content&quot;&gt;        &lt;%- page.content %&gt;    &lt;/div&gt;&lt;/article&gt;</code></pre><p><code>archive.ejs</code>:</p><pre><code class="ejs">&lt;section class=&quot;archive&quot;&gt;    &lt;ul class=&quot;post-archive&quot;&gt;    &lt;% page.posts.each(function (post) &#123; %&gt;        &lt;li class=&quot;post-item&quot;&gt;            &lt;span class=&quot;post-date&quot;&gt;&lt;%= date(post.date, &quot;YYYY-MM-DD&quot;) %&gt;&lt;/span&gt;            &lt;a class=&quot;post-title&quot; href=&quot;&lt;%- url_for(post.path) %&gt;&quot;&gt;&lt;%= post.title %&gt;&lt;/a&gt;        &lt;/li&gt;    &lt;% &#125;) %&gt;    &lt;/ul&gt;&lt;/section&gt;&lt;%- partial(&#39;_partial/paginator&#39;) %&gt;</code></pre><h4 id="CSS样式"><a href="#CSS样式" class="headerlink" title="CSS样式"></a>CSS样式</h4><pre><code>├─source//资源文件目录，包括页面样式，js脚本等   ├─css   │ ├─style.styl   │ ├─index.styl   │ └─_partial   │   ├─header.styl   │   ├─footer.styl      │   ├─post.styl   │   └─archive.styl   └─js</code></pre><p>Hexo提供 <code>hexo-renderer-stylus</code> 插件，只需要将样式文件放到 <code>source/css</code> 文件夹中。Hexo 在生成页面的时候会将 <code>source</code> 中的所有文件复制到生成的 <code>public</code> 文件中，并且在此之前会编译 <code>styl</code> 为 <code>css</code> 文件，把所有样式 <code>import</code> 到<code>style.styl</code>，编译之后只会有 <code>style.css</code> 一个文件</p><p><code>style.styl</code>:</p><pre><code class="ejs">body &#123;    background-color: #F2F2F2;    font-size: 1.25rem;    line-height: 1.5;&#125;.container &#123;    max-width: 960px;    margin: 0 auto;&#125;...@import &quot;_partial/header&quot;;@import &quot;index&quot;;</code></pre><h4 id="进一步细节"><a href="#进一步细节" class="headerlink" title="进一步细节"></a>进一步细节</h4><h5 id="添加分页"><a href="#添加分页" class="headerlink" title="添加分页"></a>添加分页</h5><p>首页显示的文章数量可以通过站点配置文件中的 <code>per_page</code> 字段来修改，但是不可能把所有文章都放在一页，所以需要添加文章列表的分页</p><p><code>_partial/paginator.ejs</code></p><pre><code class="ejs">&lt;% if (page.total &gt; 1)&#123; %&gt;    &lt;nav class=&quot;page-nav&quot;&gt;    &lt;%- paginator(&#123;        prev_text: &quot;&amp;laquo; Prev&quot;,        next_text: &quot;Next &amp;raquo;&quot;    &#125;) %&gt;    &lt;/nav&gt;&lt;% &#125; %&gt;</code></pre><p>在 <code>index.ejs</code> 中添加这个文件的内容：</p><pre><code class="ejs">...&lt;/section&gt;&lt;%- partial(&#39;_partial/paginator&#39;) %&gt;</code></pre><p>辅助函数 <code>paginator</code>能够插入分页链接，这是最基本的分页，具体的样式可以自行添加，或者根据文档使用其他配置自定义分页</p><h5 id="添加分类页-x2F-分类页"><a href="#添加分类页-x2F-分类页" class="headerlink" title="添加分类页&#x2F;分类页"></a>添加分类页&#x2F;分类页</h5><p>分类页和标签页的模板编写比较特殊，本质上，分类页和标签页属于自定义页面，需要新建自定义页面模板<code>page.ejs</code></p><pre><code class="ejs">&lt;% if (is_current(theme.menu.categories)) &#123; %&gt;&lt;%- partial(&#39;_partial/category&#39;) %&gt;&lt;% &#125; else if (is_current(theme.menu.tags)) &#123; %&gt;&lt;%- partial(&#39;_partial/tag&#39;) %&gt;&lt;% &#125; else &#123; %&gt;&lt;%- partial(&#39;_partial/custom&#39;) %&gt;&lt;% &#125; %&gt;</code></pre><p>需要根据当前自定义页面的类型来决定渲染何种自定义页面模板。</p><p><code>_partial/category.ejs</code>:</p><pre><code class="ejs">&lt;section class=&quot;archive&quot;&gt;    &lt;ul class=&quot;post-archive&quot;&gt;    &lt;% site.categories.each(function (category) &#123; %&gt;        &lt;span&gt;&lt;%= category.name %&gt;&lt;/span&gt;        &lt;% category.posts.forEach(function(post) &#123; %&gt;        &lt;li class=&quot;post-item&quot;&gt;            &lt;span class=&quot;post-date&quot;&gt;&lt;%= date(post.date, &quot;YYYY-MM-DD&quot;) %&gt;&lt;/span&gt;            &lt;a class=&quot;post-title&quot; href=&quot;&lt;%- url_for(post.path) %&gt;&quot;&gt;&lt;%= post.title %&gt;&lt;/a&gt;        &lt;/li&gt;        &lt;% &#125;) %&gt;    &lt;% &#125;) %&gt;    &lt;/ul&gt;&lt;/section&gt;</code></pre><p><code>_partial/tag.ejs</code>:</p><pre><code class="ejs">&lt;section class=&quot;archive&quot;&gt;    &lt;ul class=&quot;post-archive&quot;&gt;    &lt;% site.tags.each(function (tag) &#123; %&gt;        &lt;span&gt;&lt;%= tag.name %&gt;&lt;/span&gt;        &lt;% tag.posts.forEach(function(post) &#123; %&gt;        &lt;li class=&quot;post-item&quot;&gt;            &lt;span class=&quot;post-date&quot;&gt;&lt;%= date(post.date, &quot;YYYY-MM-DD&quot;) %&gt;&lt;/span&gt;            &lt;a class=&quot;post-title&quot; href=&quot;&lt;%- url_for(post.path) %&gt;&quot;&gt;&lt;%= post.title %&gt;&lt;/a&gt;        &lt;/li&gt;        &lt;% &#125;) %&gt;    &lt;% &#125;) %&gt;    &lt;/ul&gt;&lt;/section&gt;</code></pre><p><code>site.categories</code>包括了站点所有的分类信息，可以遍历获取分类信息，其中<code>category.posts</code>又包含了该分类的所有文章信息。</p><p>需要注意的是，要想在页面中展示分类页，需要先执行<code>hexo new page categories</code>(<code>tag</code>)生成分类页面，并修改<code>type</code>为<code>categories</code>(<code>tag</code>)</p><p><code>post/category(tag)/categories(tag).md</code>:</p><pre><code class="md">---title: categoriesdate: 2019-02-25 18:19:55type: &quot;categories/tag&quot;---</code></pre><h5 id="添加自定义页面"><a href="#添加自定义页面" class="headerlink" title="添加自定义页面"></a>添加自定义页面</h5><p>自定义页面与文章详情页类似</p><p><code>_partial/custom.ejs</code>:</p><pre><code class="ejs">&lt;article class=&quot;post&quot;&gt;    &lt;div class=&quot;post-title&quot;&gt;        &lt;h2 class=&quot;title&quot;&gt;&lt;%= page.title %&gt;&lt;/h2&gt;    &lt;/div&gt;    &lt;div class=&quot;post-meta&quot;&gt;        &lt;span class=&quot;post-time&quot;&gt;&lt;%- date(page.date, &quot;YYYY-MM-DD&quot;) %&gt;&lt;/span&gt;    &lt;/div&gt;    &lt;div class=&quot;post-content&quot;&gt;        &lt;%- page.content %&gt;    &lt;/div&gt;&lt;/article&gt;</code></pre><p>并需要在主题配置文件中添加自定义页面的菜单（见前文）</p><p>关于页面执行<code>hexo new page about</code>进行手动生成页面，编辑文件内容即可</p><h3 id="Hexo插件"><a href="#Hexo插件" class="headerlink" title="Hexo插件"></a>Hexo插件</h3><p>Hexo 有强大的插件系统，让我们能够轻松扩展功能而不用修改核心模块的源码。在 Hexo 中有两种形式的插件：</p><ul><li>脚本（Scripts）</li><li>插件（Packages）</li></ul><p>如果代码很简单，可以编写脚本，只需要把 JavaScript 文件放到 <code>scripts</code> 文件夹，在启动时就会自动载入</p><p>想给首页文章列表中的文章块添加一个背景颜色，背景颜色可以在文章md文件中定义，如果未定义，则随机选用一种颜色</p><p>首先，文章md文件中顶部Front-matter添加一个<code>color</code>字段：</p><p><code>_posts/hello-world-1.md</code>:</p><pre><code class="javascript">title: Hello World 1date: 2019-02-12 17:49:32categories: 分类1tags:     - 标签1color: blue---</code></pre><p>定义完成后，就可以在文章信息字段<code>post</code>或者<code>page</code>中获取到<code>color</code></p><p>然后，需要添加一个脚本函数来根据<code>color</code>字段来获取文章块的背景颜色，新增<code>scripts/getPostBgColor.js</code>:</p><pre><code class="javascript">const arr = [ &#39;blue&#39;, &#39;purple&#39;, &#39;green&#39;, &#39;yellow&#39;, &#39;red&#39;, &#39;orange&#39; ];var getPostBgColor = function(color) &#123;  if (arr.indexOf(color) &gt;= 0) &#123;    return `bg-$&#123;color&#125;`;  &#125;  return &#39;bg-&#39; + randBgColor();&#125;;function randBgColor() &#123;  return arr[randomInt(0, 5)];&#125;function randomInt(min, max) &#123;  return Math.round(Math.random() * (max - min)) + min;&#125;hexo.extend.helper.register(&#39;getPostBgColor&#39;, getPostBgColor);// 全局注册一个脚本函数</code></pre><p><code>layout/index.ejs</code>:</p><pre><code class="ejs">...&lt;article class=&quot;post &lt;%= getPostBgColor(post.color) %&gt;&quot;&gt;...</code></pre><p>添加背景颜色样式，编辑<code>css/index.styl</code>:</p><pre><code class="stylus">....bg-blue &#123;    background-color: #6fa3ef;&#125;.bg-purple &#123;    background-color: #bc99c4;&#125;.bg-green &#123;    background-color: #46c47c;&#125;.bg-yellow &#123;    background-color: #f9bb3c;&#125;.bg-red &#123;    background-color: #e8583d;&#125;.bg-orange &#123;    background-color: #f68e5f;&#125;</code></pre><p>有其他复杂的需求，可以通过编写更加复杂的脚本来实现</p><h3 id="Hexo的数据DB扩展查询"><a href="#Hexo的数据DB扩展查询" class="headerlink" title="Hexo的数据DB扩展查询"></a>Hexo的数据DB扩展查询</h3><p>我们已经知道，Hexo已经为我们预先义了很多常用的变量供我们使用，具体可以在 Hexo | 变量 查询。但是如果系统提供的变量数据不能满足我们的要求，那我们该怎么办呢？其实我们可以通过扩展查询来获取到我们期望的数据。</p><p>其实Hexo所有的文章分类标签等等变量信息，在编译成本地静态文件之前，都是本地存储在一个<code>db.json</code>中的，相当于小型的本地数据库，Hexo在运行阶段，所有的数据相关操作其实都是在这个小型数据库上进行操作，其底层使用的查询引擎就是Warehouse。因此我们可以通过Warehouse的语法进行自定义扩展查询。</p><p>比如我们需要在页面的底部展示全站的最近6篇文章列表，由于Hexo首页只提供了第一页的数据，因此我们可以基于<code>site</code>变量进行扩展查询：</p><pre><code class="ejs">site.posts.sort(&#123;date: -1&#125;).limit(6)</code></pre><p><code>site.posts</code>表示所有的文章，<code>sort（&#123;date: -1&#125;)</code>表示按创建时间倒序排列，<code>limit(6)</code>表示只取前6条数据，这样我们就可以拿到了全站的最近6文章信息，后续进行相应展示操作即可。</p><p>其他更多复杂的扩展查询都可以根据Warehouse语法文档进行按需扩展。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实说白了，Hexo就是把那些 Markdown 文件，按照我们编写的对应布局模板，填上对应的数据生成 HTML 页面，然后在编译的过程中将JS&#x2F;CSS等文件引入HTML，然后生成每个页面的对应HMTL静态文件。</p><p>而Hexo主题的作用就是决定每个布局模板长什么样</p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo建站</title>
      <link href="/2023/02/hexo/"/>
      <url>/2023/02/hexo/</url>
      
        <content type="html"><![CDATA[<p>采用Hexo建立个人博客，本文记录建站经历</p><h2 id="建站思路"><a href="#建站思路" class="headerlink" title="建站思路"></a>建站思路</h2><p>hexo+github+vercel+godaddy+dnspod</p><p>框架+GitHub存储 +网站托管服务 +域名注册+域名服务器DNS</p><p>先用着</p><p>上面已经备份之后，再继续进行操作就只需在hexo_src分支下进行</p><p>hexo的操作，以及git操作</p><p>批处理</p><pre><code class="bash">hexo clean;hexo g;hexo d;git status ;git add . ;git commit -m &#39;new push&#39;;git push origin hexo_src</code></pre><p>挺方便</p><h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><p>使用 <code>hexo init</code> 来生成基本文件，做一些基本的配置，像安装模块、配置主题等</p><p>使用 <code>hexo new page / post</code>来生成文章或页面的 md 文件，编辑</p><p>使用 <code>hexo g</code> 生成文件，Hexo 会根据主题中的模板，来生成对应的 html 文件，转译 CSS 文件，复制其它的静态文件（如图片图标字体等），组织为一个静态网站</p><p>使用 <code>hexo d</code> 来部署，一般是借助一些部署模块完成</p><h2 id="备份博客源文件"><a href="#备份博客源文件" class="headerlink" title="备份博客源文件"></a>备份博客源文件</h2><p>有时候我们想换一台电脑继续写博客，这时候就可以将博客目录下的所有源文件都上传到github上面。</p><h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><p>首先在github博客仓库下新建一个分支<code>hexo_src</code>，然后<code>git clone</code>到本地，把<code>.git</code>文件夹拿出来，放在博客根目录下。</p><p>然后<code>git checkout -b hexo_src</code>切换到<code>hexo_src</code>分支，然后<code>git add .</code>，然后<code>git commit -m &quot;xxx&quot;</code>，最后<code>git push origin hexo_src</code>提交就行了。</p><h3 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h3><p>首先在指定文件夹clone下来hexo_src分支</p><pre><code class="bash">$ git clone -b hexo_src [仓库地址]</code></pre><p>在该clone下来的文件夹里去安装hexo</p><pre><code class="bash">$ cnpm install hexo$ cnpm install//这一句不知道和上面这一句有何区别</code></pre><blockquote><p>特别注意，hexo_src中的theme文件夹在上传分支后为空，需要再次从原主题仓库clone下来处理</p></blockquote><h2 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h2><p>采用</p><p> jsdelivr (cdn) + github 存储 + PicGo </p><p>方案</p><p>&#x2F;&#x2F; load any GitHub release, commit, or branch</p><p>&#x2F;&#x2F; note: we recommend using npm for projects that support it</p><p><a href="https://cdn.jsdelivr.net/gh/user/repo@version/filecdn+">https://cdn.jsdelivr.net/gh/user/repo@version/filecdn+</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>white主题配置</title>
      <link href="/2023/02/whiteDoc/"/>
      <url>/2023/02/whiteDoc/</url>
      
        <content type="html"><![CDATA[<p>这里是复制了官方的文档，由于官方不再维护，故在此基础上个人增删修改</p><h2 id="👋Hi-there"><a href="#👋Hi-there" class="headerlink" title="👋Hi there"></a>👋Hi there</h2><p>欢迎使用本主题 ，<strong>White</strong> 是一个在个性和极简之间徘徊的主题，（因为作者本身性格就是这样的人，而且搞不好心态爆炸会删库跑路（现已跑路。。。），还请喜欢的各位及时fork🤣</p><p>如果你喜欢这款主题的话，不妨给我一个star 感激不尽！</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote><p>方便备份和更新</p></blockquote><ol><li>fork 本项目</li><li><code>git clone https://github.com/&lt;你的用户名&gt;/hexo-theme-white.git themes/white</code></li><li>修改根目录下的<code>_config.yml</code> 为<code>theme: white</code></li></ol><h2 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h2><blockquote><p>其实config文件里写的很明白了，现在就重新列一下，添加一些不必要的说明</p></blockquote><h3 id="可自定义style"><a href="#可自定义style" class="headerlink" title="可自定义style"></a>可自定义style</h3><pre><code>############## style ##############style:  layout:    max-width: 1130px #总体宽度    post-max-width: 800px #文章内容宽度  color:    theme-main: &quot;#1A98FF&quot; # 主色调    theme-secondary: &quot;#DDF0FF&quot; # 次色调    text-main: &quot;#333333&quot; # 文字主色调    text-secondary: &quot;#898FA0&quot; # 文字次色调  animation:    open: true # 如果开启动画的话会引入animation.css</code></pre><h3 id="主页配置"><a href="#主页配置" class="headerlink" title="主页配置"></a>主页配置</h3><h4 id="home页和archive可选配置"><a href="#home页和archive可选配置" class="headerlink" title="home页和archive可选配置"></a>home页和archive可选配置</h4><pre><code># home页可选类型home:  type: &quot;img&quot; # 主页的类型，可选 home | img | simple# archive页可选类型archive:  type: &quot;simple&quot; # archive的类型，可选 img | simple</code></pre><p>type为home就是一个封面，为img就是图片加标题的形式，simple就是极简模式</p><h3 id="随机cover"><a href="#随机cover" class="headerlink" title="随机cover"></a>随机cover</h3><p>当你懒的找封面而又想用img模式的时候，我为你准备了些随机封面</p><pre><code>archive_img_mode:  default_cover: #默认的cover    - https://cdn.jsdelivr.net/gh/fushaolei/cdn-white@1.0/cover/01.jpg    - https://cdn.jsdelivr.net/gh/fushaolei/cdn-white@1.0/cover/02.jpg    - https://cdn.jsdelivr.net/gh/fushaolei/cdn-white@1.0/cover/03.jpg    - https://cdn.jsdelivr.net/gh/fushaolei/cdn-white@1.0/cover/04.jpg    - https://cdn.jsdelivr.net/gh/fushaolei/cdn-white@1.0/cover/05.jpg    - https://cdn.jsdelivr.net/gh/fushaolei/cdn-white@1.0/cover/06.jpg</code></pre><blockquote><p>图片均来自于bing的每日图片，版权归图片原作者所有，我只是搬到了自己的仓库方便使用，如果有侵犯到你的权益，请和我联系 ( •̀ ω •́ )y</p></blockquote><h3 id="浏览器标签页配置"><a href="#浏览器标签页配置" class="headerlink" title="浏览器标签页配置"></a>浏览器标签页配置</h3><pre><code># iconicon:  #标签页图标，这里可填链接#  headersite_name: white.</code></pre><h3 id="menu"><a href="#menu" class="headerlink" title="menu"></a>menu</h3><pre><code>menu:  HOME: /  BLOG: /archives</code></pre><h3 id="全局搜索"><a href="#全局搜索" class="headerlink" title="全局搜索"></a>全局搜索</h3><pre><code>## 本地搜索search:  open: false # 是否开启  page: /search # 页面路径（通常命名为search）</code></pre><p>如果你想使用的话，请先到根目录执行</p><pre><code>npm install hexo-generator-search --save</code></pre><p>然后新建一个名为search的page</p><pre><code>hexo new page &quot;search&quot;</code></pre><p>进入这个文件夹，更改它的<code>index.md</code>文件，示例如下</p><pre><code>---layout: searchcover: #你还可以自定义cover---</code></pre><p>然后将open设置为true即可开启</p><h3 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h3><blockquote><p>当你的home页有用到type home模式的话 请配置此项</p></blockquote><pre><code># 自我介绍intro:  title: Hi.I&#39;m White.  sub: &#39;A [White](https://github.com/FuShaoLei/hexo-theme-white) theme for [Hexo](http://hexo.io/)&#39; # markdown语法  avator: https://cdn.jsdelivr.net/gh/fushaolei/img/20200524104925.jpg #头像 暂时还没用到  author: white #所有文章的默认作者</code></pre><h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><pre><code>#联系方式  #更多图标：https://remixicon.com/contact:  Github:    - https://github.com/FuShaoLei/hexo-theme-white    - ri-github-line  Email:     - mailto:1563250958@qq.com    - ri-mail-line</code></pre><p>格式就是</p><pre><code>名字:  - 链接  - 图标 </code></pre><p>更多图标请到 <a href="https://remixicon.com/">https://remixicon.com/</a> 搜寻，感谢此图标项目的开源作者<a href="https://github.com/xiaochunjimmy">xiaochunjimmy</a></p><h3 id="文章toc设置"><a href="#文章toc设置" class="headerlink" title="文章toc设置"></a>文章toc设置</h3><pre><code># 文章toc索引栏设置toc:  open: true # 是否开启  side: true  # 选择toc的位置，填true的话toc将会显示在文章的侧边，填false的话 toc将出现在文章的开头  max: 2 #最大深度  min: 2 #最小深度</code></pre><p>其中side如果设置为false的话，将会出现在文章的top部分，如果设置为true的话，将会出现在侧边<br>min设置的是最小深度，max设置的是最大深度，<del>如上面配置所示，min为2，说明h2索引是至少要出现的，不会出现h1索引 （ 突然不知道怎么表达，</del> 如果不理解的话建议你试试 😂</p><h3 id="highlight"><a href="#highlight" class="headerlink" title="highlight"></a>highlight</h3><p>代码高亮，想要使用代码高亮，得先把根目录的**<code>_config.yml</code>里的highlight的enable置成false**</p><pre><code># 插件plugins:  highlightjs:    js: https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.1/build/highlight.min.js    css: https://cdn.jsdelivr.net/npm/highlight.js@10.1.1/styles/github.css    # more: https://www.jsdelivr.com/package/npm/highlight.js?path=styles</code></pre><p><strong>注：</strong> hexo 5.0版本此处有bug（2020年8月10日写），就是渲染不出来大括号（<code>&#123;</code>和<code>&#125;</code>）</p><p>这里博主有点懒了，最近事多心烦，就等着hexo官方更新吧 QAQ</p><h3 id="评论系统"><a href="#评论系统" class="headerlink" title="评论系统"></a>评论系统</h3><pre><code># 评论系统设置comments:  open: false #是否开启评论系统  system: gitalk #选择评论系统 可选 valine gitalk livere  # Valine  valine:    appid: #Leancloud应用的AppID  这里和下面的要换成你自己的啊QAQ    appkey: #Leancloud应用的AppKey    verify: false #验证码    notify: true #评论回复提醒    avatar: robohash #评论列表头像样式：&#39;&#39;/mm/identicon/monsterid/wavatar/retro/hide    #头像类型可见： https://valine.js.org/avatar.html    placeholder: 留下你来过的痕迹~ #评论框占位符  # Gitalk  gitalk:    owner:  #Github 用户名,    repo:  #储存评论issue的github仓库名    admin:  #Github 用户名    clientID:  #`Github Application clientID`    clientSecret: #`Github Application clientSecret`  #livere  livere: # 前往 http://livere.com/ 申请账号    dataId: city #免费版本city    dataUid: #安装代码中 data-uid 后面数据</code></pre><p>这里的话相关教程大家网上搜就好了。这里就不赘诉了</p><blockquote><p>还是写一些gitalk的坑吧，一个是repo这里 写的应该是<strong>仓库名</strong>，而不是仓库链接或者其他的东西，然后gitalk要上线部署一次才可以，md文件名字最好用英文来命名，如果用中文的话，超出50个字符将会初始化失败</p></blockquote><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><pre><code># 页脚footer: Power by [Hexo](http://hexo.io/) Theme by [White](https://github.com/FuShaoLei/hexo-theme-white) # markdown语法#有分类时是否开启menu分类页和自定义名字menu_categories:  open: true  name: 分类#可自定义归档标签页名字 archive_tab_name: Blog#图片懒加载lazyload:  open: true #是否开启</code></pre><p>这里就不bb了 大家应该看的懂</p><h2 id="进阶使用"><a href="#进阶使用" class="headerlink" title="进阶使用"></a>进阶使用</h2><h3 id="平滑升级"><a href="#平滑升级" class="headerlink" title="平滑升级"></a>平滑升级</h3><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>因为主题的更新比较频繁，所以如果你想舒服用到最新的版本的话，就请使用平滑升级</p><ol><li>在你<strong>根目录</strong>下的<code>source</code>文件夹下新建一个名为<code>_data</code>的<strong>文件夹</strong></li><li>复制<strong>主题文件夹</strong>下的<code>_config.yml</code>到<code>_data</code>文件夹下，重命名为<code>white.yml</code></li></ol><p>好了，到这里差不多完成了，以后你需要改动什么，只需要在这个<code>white.yml</code>中进行修改(在编译时，会自动将此替换<code>_config.yml</code>)</p><h4 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h4><p>当你看到我的主题有<a href="https://github.com/FuShaoLei/hexo-theme-white/issues/3">变更</a>时，在主题文件中执行<code>git pull</code>拉取最新代码<br>然后，对比最新主题文件夹下的<code>_config.yml</code> 看看有无新增什么东西，添加到你的<code>white.yml</code>中即可</p>]]></content>
      
      
      
        <tags>
            
            <tag> document </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mermaid</title>
      <link href="/2023/02/mermaid/"/>
      <url>/2023/02/mermaid/</url>
      
        <content type="html"><![CDATA[<p>mermaid是一款支持在Markdown文档中使用的图表工具，可以用来画时序图，类图，流程图等。在Markdown中使用十分方便，编辑器Typora支持mermaid。mermaid是基于javascript实现的，将Markdown文档中的元素渲染成HTML元素。基于white搭建的博客起初并不支持mermaid，记录一下实现过程。</p><ol><li><p>安装插件</p><pre><code class="bash">$ npm install --save hexo-filter-mermaid-diagrams</code></pre></li><li><p>修改主题的配置文件<code>_config.yml</code></p><pre><code class="yaml"># Mermaid (markdown to flow chart, seq chart, class chart ...)mermaid:     enable: true    # Available themes: default | dark | forest | neutral    theme: default</code></pre></li><li><p>下载js文件</p><p>&#96;&#96;</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> mermaid </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RoadMaps</title>
      <link href="/2023/02/RoadMaps/"/>
      <url>/2023/02/RoadMaps/</url>
      
        <content type="html"><![CDATA[<h1 id="路线"><a href="#路线" class="headerlink" title="路线"></a>路线</h1><h2 id="Web-dev"><a href="#Web-dev" class="headerlink" title="Web dev"></a>Web dev</h2><p>基础–&gt;交互语言 –&gt; 框架 –&gt; 元框架 –&gt; 后端 –&gt; 无服务平台</p><pre class="mermaid">graph LRA(HTML) --> B(CSS) -->C(Javascript)C --> D(React) --> G(Nexj.js)C --> E(Vue) --> H(Nuxt.js)C--> F(Svelte) --> I(Svelte Kit)G --> J(Firebase\Pocket base\Super base)H --> JI --> JJ --> Node.js</pre><p>Angular Vite tailwindcss</p><p>java，Spring Boot，Ruby on Rails或Laravel </p><p>PHP</p>]]></content>
      
      
      
        <tags>
            
            <tag> learn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GNU和一些</title>
      <link href="/2023/01/GNU/"/>
      <url>/2023/01/GNU/</url>
      
        <content type="html"><![CDATA[<p>最近更新MinGW，并且由于学习原因需要Cygwin，下载过程中发现很多疑惑。故摘录了部分关于GNU以及相关开发的信息和后面补充的Unix、Linux的内容。信息源有Wikipedia、官网等。</p><h2 id="GNU计划"><a href="#GNU计划" class="headerlink" title="GNU计划"></a>GNU计划</h2><p><strong>GNU计划</strong>（英语：<strong>GNU Project</strong>），又译为<strong>革奴计划</strong>，是一个自由软件计划，1983年9月27日由理查德·斯托曼在麻省理工学院公开发起。它的目标是创建一套完全自由的操作系统，称为GNU。</p><p>理查德·斯托曼最早在net.unix-wizards新闻组上公布该消息，并附带一份《GNU宣言》等解释为何发起该计划的文章，其中一个理由就是要“重现当年软件界合作互助的团结精神”。</p><p>由于GNU将要实现UNIX系统的接口标准，因此GNU计划可以分别开发不同的操作系统。GNU计划采用了部分当时已经可自由使用的软件，例如TeX排版系统和X Window视窗系统等。不过GNU计划也开发了大批其他的自由软件，这些软件也被移植到其他操作系统平台上，例如Microsoft Windows、BSD家族、Solaris及Mac OS。</p><p>为保证GNU软件可以自由地“使用、复制、修改和发布”，所有GNU软件都包含一份在禁止其他人添加任何限制的情况下，授权所有权利给任何人的协议条款，GNU通用公共许可证（GNU General Public License，GPL）。这个就是被称为“公共著作权”的概念。GNU也针对不同场合，提供GNU宽通用公共许可证与GNU自由文档许可证这两种协议条款。</p><h2 id="GNU"><a href="#GNU" class="headerlink" title="GNU"></a>GNU</h2><p>GNU是一个自由的操作系统，其内容软件完全以GPL方式发布。</p><p>作为操作系统，GNU的发展仍未完成，其中最大的问题是具有完备功能的内核尚未被开发成功。GNU的内核，称为Hurd，是自由软件基金会发展的重点，但是其发展尚未成熟。在实际使用上，多半使用Linux内核、FreeBSD等替代方案，作为系统核心，其中主要的操作系统是Linux的发行版。Linux操作系统包涵了Linux内核与其他自由软件项目中的GNU组件和软件，可以被称为GNU&#x2F;Linux。</p><h2 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h2><p>GNU编译器套装（英语：GNU Compiler Collection，缩写为GCC）是GNU计划制作的一种优化编译器，支持各种编程语言、操作系统、计算机系统结构。该编译器是以GPL及LGPL许可证所发行的自由软件，也是GNU计划的关键部分，还是GNU工具链的主要组成部分之一。GCC（特别是其中的C语言编译器）也常被认为是跨平台编译器的事实标准。1985年由理查德·马修·斯托曼开始发展，现在由自由软件基金会负责维护工作。截至2019年，GCC大约有1500万行代码，是现存最大的自由程序之一。它在自由软件的发展中发挥了重要作用，不仅是一个工具，还是一个典例。</p><p>原名为GNU C语言编译器（GNU C Compiler），因为它原本只能处理C语言。同年12月，新的GCC编译器可以编译C++语言。后来又为Fortran、Pascal、Objective-C、Java、Ada，Go等其他语言开发了前端。C和C++编译器也支持OpenMP和OpenACC规范。</p><p>GCC编译器已经被移植到比其他编译器更多的平台和指令集架构上，并被广泛部署在开发自由和专有软件的工具中。GCC还可用于许多嵌入式系统，包括基于ARM和Power ISA的芯片。</p><p>GCC不仅是GNU操作系统的官方编译器，还是许多类UNIX系统和Linux发行版的标准编译器。BSD家族中的大部分操作系统也在GCC发布之后转用GCC；不过FreeBSD、OpenBSD和Apple macOS已经转向了Clang编译器，主要是因为许可问题。GCC也可以编译Windows、Android、iOS、Solaris、HP-UX、IBM AIX和DOS系统的代码。GCC原本用C开发，后来因为LLVM、Clang的崛起，它更快地将开发语言转换为C++。许多C的爱好者在对C++一知半解的情况下主观认定C++的性能一定会输给C，但是Ian Lance Taylor给出了不同的意见，并表明C++不但性能不输给C，而且能设计出更好，更容易维护的程序。</p><h2 id="Cygwin"><a href="#Cygwin" class="headerlink" title="Cygwin"></a>Cygwin</h2><p>Cygwin是许多自由软件的集合，最初由Cygnus Solutions开发，用于各种版本的Microsoft Windows上，运行类UNIX系统。Cygwin的主要目的是通过重新编译，将POSIX系统（例如Linux、BSD，以及其他Unix系统）上的软件移植到Windows上。Cygwin移植工作在Windows NT上比较好，在Windows 95和Windows 98上，相对差劲一些。目前Cygwin由Red Hat等负责维护。</p><h2 id="MinGW"><a href="#MinGW" class="headerlink" title="MinGW"></a>MinGW</h2><p>MinGW（Minimalist GNU for Windows），又称mingw32，是将GCC编译器和GNU Binutils移植到Win32平台下的产物，包括一系列头文件（Win32API）、库和可执行文件。</p><p>另有可用于产生32位及64位Windows可执行文件的MinGW-w64项目，是从原本MinGW产生的分支。如今已经独立发展。</p><h2 id="MinGW-w64"><a href="#MinGW-w64" class="headerlink" title="MinGW-w64"></a>MinGW-w64</h2><p>Mingw-w64是自由及开放源代码软件开发环境，用于创建Microsoft Windows应用程序。从2005–2008从MinGW(Minimalist GNU for Windows)分支出来。</p><p>Mingw-w64包括对GCC、GNU Binutils的Windows版本的移植（汇编器、链接器、库文件管理器），一套自由可分发的Windows特定的头文件与静态导入库以使用Windows API，一个 Windows本地版本的GNU的调试器，以及其它多种工具。</p><p>Mingw-w64可运行于本地Microsoft Windows平台，”cross-native”在MSYS2或Cygwin。Mingw-w64能生成32-或64-位可执行程序，运行于i686-w64-mingw32或x86_64-w64-mingw32目标平台</p><h2 id="MSYS2"><a href="#MSYS2" class="headerlink" title="MSYS2"></a>MSYS2</h2><p>MSYS2 (“minimal system 2”)是用于Microsoft Windows的软件发布与开发平台，基于Mingw-w64与Cygwin，把Unix环境中的代码移植到Windows。</p><h2 id="lint"><a href="#lint" class="headerlink" title="lint"></a>lint</h2><p>UNIX（非复用信息和计算机服务，英语：Uniplexed Information and Computing Service，UnICS），一种多用户、多进程的计算机操作系统，源自于从20世纪70年代开始在美国AT&amp;T公司的贝尔实验室开发的AT&amp;T Unix。</p><h2 id="BSD"><a href="#BSD" class="headerlink" title="BSD"></a>BSD</h2><p>伯克利软件包（英语：Berkeley Software Distribution，缩写：BSD；也被称为伯克利Unix或Berkeley Unix）是一个派生自Unix（类Unix）的操作系统，1970年代由伯克利加州大学的学生比尔·乔伊开创，也被用来代表其派生出的各种包。</p><p>BSD许可证非常地宽松，因此BSD常被当作工作站级别的Unix系统，许多1980年代成立的计算机公司都从BSD中获益，比较著名的例子如DEC的Ultrix，以及Sun公司的SunOS。 1990年代，BSD大幅度被System V 4.x版以及OSF&#x2F;1系统所取代，但其开源版本被用在互联网的开发。</p><h2 id="Unix"><a href="#Unix" class="headerlink" title="Unix"></a>Unix</h2><p>        <span class="lazyload-img-span">        <img              data-src="https://fastly.jsdelivr.net/gh/louisiy/ImageStorage/img/Unix_history-simple.svg" >        </sapn>      </p><p>UNIX（非复用信息和计算机服务，英语：Uniplexed Information and Computing Service，UnICS），一种多用户、多进程的计算机操作系统，源自于从20世纪70年代开始在美国AT&amp;T公司的贝尔实验室开发的AT&amp;T Unix。</p><p>UNIX操作系统，是一个强大的多用户、多任务操作系统，支持多种处理器架构，按照操作系统的分类，属于分时操作系统，最早由肯·汤普逊、丹尼斯·里奇和道格拉斯·麦克罗伊于1969年在AT&amp;T的贝尔实验室开发。目前它的商标权由国际开放标准组织所拥有，只有符合单一UNIX规范的UNIX系统才能使用UNIX这个名称，否则只能称为类UNIX（UNIX-like）。</p><p>Unix的前身为1964年开始的Multics，1965年时，贝尔实验室加入一项由通用电气和麻省理工学院合作的计划；该计划要创建一套多用户、多任务、多层次（multi－user、multi－processor、multi－level）的MULTICS操作系统。贝尔实验室参与了这个操作系统的研发，但因为开发速度太慢，1969年贝尔实验室决定退出这个计划。贝尔实验室的工程师，肯·汤普逊和丹尼斯·里奇，在此时自行开发了Unix。</p><p>此后的10年，Unix在学术机构和大型企业中得到了广泛的应用，当时的UNIX拥有者AT&amp;T公司以低廉甚至免费的许可将Unix源码授权给学术机构做研究或教学之用，许多机构在此源码基础上加以扩展和改进，形成了所谓的“Unix变种”，这些变种反过来也促进了Unix的发展，其中最著名的变种之一是由加州大学柏克莱分校开发的伯克利软件套件(BSD)产品。</p><p>后来AT&amp;T意识到了Unix的商业价值，不再将Unix源码授权给学术机构，并对之前的Unix及其变种声明了著作权权利。BSD在Unix的历史发展中具有相当大的影响力，被很多商业厂家采用，成为很多商用Unix的基础。其不断增大的影响力终于引起了AT&amp;T的关注，于是开始了一场持久的著作权官司，这场官司一直打到AT&amp;T将自己的Unix系统实验室卖掉，新接手的Novell采取了一种比较开明的做法，允许柏克莱分校自由发布自己的Unix变种，但是前提是必须将来自于AT&amp;T的代码完全删除，于是诞生了4.4 BSD Lite版，由于这个版本不存在法律问题，4.4 BSD Lite成为了现代柏克莱软件包的基础版本。尽管后来，非商业版的Unix系统又经过了很多演变，但其中有不少最终都是创建在BSD版本上（Linux、Minix等系统除外）。所以从这个角度上，4.4 BSD又是所有自由版本Unix的基础，它们和System V及Linux等共同构成Unix操作系统。</p><p>BSD使用主版本加次版本的方法标识，如4.2、4.3BSD，在原始版本的基础上还有派生版本，这些版本通常有自己的名字，如4.3BSD-Net&#x2F;1，4.3BSD-Net&#x2F;2等。BSD在发展中也逐渐派生出3个主要的分支：FreeBSD、OpenBSD和NetBSD。</p><p>此后的几十年中，Unix仍在不断变化，其著作权所有者不断变更，授权者的数量也在增加。Unix的著作权曾经为AT&amp;T所有，之后Novell拥有获取了Unix，再之后Novell又将著作权出售给了圣克鲁兹作业，但不包括知识产权和专利权（这一事实双方尚存在争议）。有很多大公司在获取了Unix的授权之后，开发了自己的Unix产品，比如IBM的AIX、惠普的HP-UX、SCO的Openserver、SUN的Solaris（被Oracle收购）和SGI的IRIX。</p><p>Unix因为其安全可靠，高效强大的特点在服务器领域得到了广泛的应用。直到GNU&#x2F;Linux流行开始前，Unix也是科学计算、大型机、超级计算机等所用操作系统的主流。现在其仍然被应用于一些对稳定性要求极高的数据中心之上。</p><h2 id="POSIX"><a href="#POSIX" class="headerlink" title="POSIX"></a>POSIX</h2><p>可移植操作系统接口（英语：Portable Operating System Interface，缩写为POSIX）是IEEE为要在各种UNIX操作系统上运行软件，而定义API的一系列互相关联的标准的总称，其正式称呼为IEEE Std 1003，而国际标准名称为ISO&#x2F;IEC 9945。此标准源于一个大约开始于1985年的项目。POSIX这个名称是由理查德·斯托曼（RMS）应IEEE的要求而提议的一个易于记忆的名称。它基本上是Portable Operating System Interface（可移植操作系统接口）的缩写，而X则表明其对Unix API的传承。</p><p>当前的POSIX主要分为四个部分：Base Definitions、System Interfaces、Shell and Utilities和Rationale。</p>]]></content>
      
      
      
        <tags>
            
            <tag> GNU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>When I learn C</title>
      <link href="/2023/01/When-I-learn-C/"/>
      <url>/2023/01/When-I-learn-C/</url>
      
        <content type="html"><![CDATA[<h1 id="HERE-IS-NOTE-FOR-Head-First-C-😃"><a href="#HERE-IS-NOTE-FOR-Head-First-C-😃" class="headerlink" title="HERE IS NOTE FOR Head First C 😃"></a>HERE IS NOTE FOR <em>Head First C</em> 😃</h1><h2 id="0-关于"><a href="#0-关于" class="headerlink" title="0 关于"></a>0 关于</h2><p>这里是符号说明，形如</p><ul><li>这是一条个人笔记</li></ul><blockquote><p>这是小拓展</p></blockquote><h2 id="1-入门"><a href="#1-入门" class="headerlink" title="1 入门"></a>1 入门</h2><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p><code>gcc -o</code> 设置文件名</p><p><code>./name</code> 类Unix操作系统中运行程序必须指定程序所在的目录，除非该程序目录已在PATH环境变量中</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>C不支持现成的字符串</p><p>定义字符串数组需额外加一个字符的空间来容纳<code>/0</code>（NULL字符），字符的索引值为偏移量</p><p>单引号通常用来表示单个字符，而双引号通常用来表示字符串。通常应该用双引号来定义字符串。用双引号定义的字符串叫字符串字面值（string literal），比起字符数组，它输入起来也更方便</p><p>总线错误（bus error）意味着程序无法更新那一块存储器空间</p><h3 id="等号"><a href="#等号" class="headerlink" title="等号"></a>等号</h3><p><code>num = 1</code> 等号用来赋值（assignment）</p><p><code>num == 1</code> 检查值是否相等</p><p><code>nunm += 2 or num -= 2</code> 加减2</p><p><code>num++ or num--</code> 加减1</p><h3 id="布尔运算"><a href="#布尔运算" class="headerlink" title="布尔运算"></a>布尔运算</h3><p><code>&amp;&amp; || !</code> 与或非</p><p><code>&amp;</code>和<code>|</code>操作符总是计算两个条件，而<code>&amp;&amp;</code>和<code>||</code>可以跳过第二个条件</p><p>位运算 <code>6 &amp; 4</code> 等于4</p><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>switch语句检查一个单独的值。计算机会在第一个匹配的case语句处开始执行代码。在遇到break或到达switch语句的末尾前，代码会一直运行。</p><pre><code class="c">switch(train) &#123;case 37:    winnings = winnings + 50;    break;case 65:    puts(&quot;头等奖!&quot;);    winnings = winnings + 80;//执行完这条接着再+20这条，直到breakcase 12:    winnings = winnings + 20;    break;default:    winnings = 0;&#125;</code></pre><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><pre><code class="c">int counter;for (counter = 1; counter &lt; 11; counter++) &#123;//(初始化循环变量；循环运行前检查；循环后执行)    printf(&quot;%i个枣\n&quot;, counter);&#125;</code></pre><p>可以用<code>break</code>在任意时刻退出循环</p><p>可以用<code>continue</code>随时跳到循环条件处</p><h3 id="链式赋值"><a href="#链式赋值" class="headerlink" title="链式赋值"></a>链式赋值</h3><p><code>x = y = 4;</code>给多个变量赋相同值</p><h2 id="2-指针"><a href="#2-指针" class="headerlink" title="2 指针"></a>2 指针</h2><p>使用指针的主要目的之一就是让函数共享存储器，指针只是一个保存存储器地址的变量，它们是进程存储器中真实编号的地址</p><h3 id="储存器"><a href="#储存器" class="headerlink" title="储存器"></a>储存器</h3><p>局部变量保存在栈（Stack），全局变量保存在全局量区（Globals）</p><p><code>&amp;x</code>指x的地址 <code>%p</code>来格式化输出</p><blockquote><p>栈<br>这是存储器用来保存局部变量的部分。每当调用函数，函数的所有局部变量都在栈上创建。它之所以叫栈是因为它看起来就像堆积而成的栈板：当进入函数时，变量会放到栈顶；离开函数时，把变量从栈顶拿走。奇怪的是，栈做起事来颠三倒四，它从存储器的顶部开始，向下增长。</p><p>堆<br>堆用于动态存储：程序在运行时创建一些数据，然后使用很长一段时间。</p><p>全局量<br>全局量位于所有函数之外，并对所有函数可见。程序一开始运行时就会创建全局量，可以修改它们，不像常量。</p><p>常量<br>常量也在程序一开始运行时创建，但它们保存在只读存储器中。常量是一些在程序中要用到的不变量，你不会想修改它们的值，例如字符串字面值。</p><p>代码<br>最后是代码段，很多操作系统都把代码放在存储器地址的低位。代码段也是只读的，它是存储器中用来加载机器代码的部分。</p></blockquote><h3 id="int"><a href="#int" class="headerlink" title="int *"></a>int *</h3><p><code>int *address_of_x = &amp;x;</code></p><p><code>*</code>来解引用，如<code>int value_stored = *address_of_x;</code> 、<code>*address_of_x = 99;</code></p><h3 id="sizeof（）"><a href="#sizeof（）" class="headerlink" title="sizeof（）"></a>sizeof（）</h3><p>这是个运算符</p><pre><code class="c">sizeof(int);sizeof(&quot;Turtles!&quot;);//返回9</code></pre><h3 id="数组变量"><a href="#数组变量" class="headerlink" title="数组变量"></a>数组变量</h3><p>数组变量可以被用作指针，指向数组中的第一个元素。函数参数声明如为数组，则其会被当作指针处理</p><p>计算机不会为数组变量分配任何空间，编译器仅在出现它的地方把它替换成数组的起始地址，所以不能把它指向任何其他地方</p><blockquote><p>指针退化</p><p>假如把数组赋给指针变量，指针变量只会包含数组的地址信息，而对数组的长度一无所知，相当于指针丢失了一些信息，也就是指针退化。</p><p>只要把数组传递给函数，数组免不了退化为指针，但需要记清楚代码中有哪些地方发生过数组退化，因为它们会引发一些不易察觉的错误。</p></blockquote><pre><code class="c">int drinks[] = &#123;4, 2, 3&#125;;//drinks[i] == *(drinks + i)doses[3] == *(doses + 3) == *(3 + doses) == 3[doses]</code></pre><h3 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h3><p>指针之所以有类型，是因为编译器在指针算术运算时需要知道加几</p><p>如<code>int nums[] = &#123;1, 2, 3&#125;;</code>中<code>nums</code>与<code>nums+1</code>的地址间隔4个字节（如果int通常占4个字节）</p><ul><li>这里的数组内的每一个值都是int类型，都占4字节</li></ul><h3 id="scanf-vs-fgets"><a href="#scanf-vs-fgets" class="headerlink" title="scanf() vs fgets()"></a>scanf() vs fgets()</h3><p><code>scanf()</code>会导致缓冲区溢出,引发段错误（abort trap）,应限制<code>scanf()</code>读取字符串的长度</p><p><code>scanf()</code>不但允许输入多个字段，而且允许输入结构化数据，可以指定两个字段之间以什么字符分割</p><p>当<code>scanf()</code>用<code>%s</code>读取字符串时，遇到空格就会停止。如果想要输入多个单词，需要多次调用<code>scanf()</code>，或使用一些复杂的正则表达式技巧</p><p><code>fgets(char指针，sizeof(char指针),stdin)</code> stdin表示数据来自键盘</p><p><code>fgets()</code>缓冲区大小把<code>\0</code>字符也算了进去，所以不必像<code>scanf()</code>那样把长度减1</p><p>如果要向<code>fgets()</code>函数传递数组变量，就用<code>sizeof</code>，如果只是传指针，就应该输入想要的长度。</p><p><code>fgets()</code>只允许向缓冲区中输入一个字符串，而且只能是字符串，不能是其他数据类型，只能有一个缓冲区</p><p><code>fgets()</code>总能读取整个字符串</p><p><strong>Conclusion</strong>:如果需要输入由多个字段构成的结构化数据，可以使用<code>scanf()</code>；而如果想要输入一个非结构化的字符串，<code>fgets()</code>将是不二之选</p><h3 id="cards-还是-cards"><a href="#cards-还是-cards" class="headerlink" title="cards[ ]还是*cards"></a>cards[ ]还是*cards</h3><p>字符串字面值保存在只读存储器中。如果想要修改字符串，需要在新的数组中创建副本。可以将char指针声明成为<code>const char *</code>，以防代码用它修改字符串</p><h2 id="2-5-字符串原理"><a href="#2-5-字符串原理" class="headerlink" title="2.5 字符串原理"></a>2.5 字符串原理</h2><h3 id="创建数组的数组"><a href="#创建数组的数组" class="headerlink" title="创建数组的数组"></a>创建数组的数组</h3><pre><code class="c">char tracks[][80] = &#123;//第一对方括号用来访问由所有字符串组成的数组                              //第二对方括号用来访问每个单独的字符串    &quot;I left my heart in Harvard Med School&quot;,    &quot;Newark, Newark - a wonderful town&quot;,    &quot;Dancing with a Dork&quot;,    &quot;From here to maternity&quot;,    &quot;The girl from Iwo Jima&quot;,&#125;;</code></pre><p>可以用<code>char strings[...][...]</code>来创建数组的数组。<br>第一组方括号用来访问外层数组<br>第二组方括号用来访问每个内层数组中的元素</p><h3 id="使用string-h"><a href="#使用string-h" class="headerlink" title="使用string.h"></a>使用string.h</h3><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;string.h&gt;strcmp()可以比较字符串strchr()用来在字符串中找到某个字符的位置strlen()可以得到字符串的长度strcpy()可以复制字符串</code></pre><p>使用以上代码引用头文件</p><h3 id="使用strstr（）"><a href="#使用strstr（）" class="headerlink" title="使用strstr（）"></a>使用strstr（）</h3><pre><code class="c">char s0[] = &quot;dysfunctional&quot;;char s1[] = &quot;fun&quot;;if (strstr(s0, s1))    puts(&quot;我在dysfunctional中找到fun了!&quot;);</code></pre><blockquote><p>全局变量位于任何函数之外，所有函数都可以调用它们。</p></blockquote><h3 id="指针的数组"><a href="#指针的数组" class="headerlink" title="指针的数组"></a>指针的数组</h3><pre><code class="c">char *names_for_dog[] = &#123;&quot;Bowser&quot;, &quot;Bonza&quot;, &quot;Snodgrass&quot;&#125;;//可以像访问数组的数组那样访问指针的数组,一个字符串字面值配一个指针</code></pre><h2 id="3-小工具"><a href="#3-小工具" class="headerlink" title="3 小工具"></a>3 小工具</h2><p>小工具设计遵循以下原则：</p><ul><li>从标准输入读取数据</li><li>在标准输出显示数据</li><li>处理文本数据，而不是难以阅读的二进制格式</li><li>只做一件简单的事</li><li>如果想完成一个不同的任务，应该另外写一个小工具</li><li>小工具通常读写文本数据</li></ul><h3 id="过滤器（filter）"><a href="#过滤器（filter）" class="headerlink" title="过滤器（filter）"></a>过滤器（filter）</h3><p>这是一种小工具，它逐行读取数据，对数据进行处理，再把数据写到某个地方。如果你的计算机是Unix，或你在Windows上安装了Cygwin，就已经拥有很多过滤器工具了。</p><blockquote><p>head：显示文件前几行的内容<br>tail：显示文件最后几行的内容<br>sed：流编辑器（stream editor），用来搜索和替换文本</p></blockquote><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>可以重定向标准输入、标准输出，让程序从键盘以外的地方读数据、往显示器以外的地方写数据，如文件。可用命令</p><pre><code class="bash">$ ./geo2json &lt; gpsdata.csv &gt; output.json</code></pre><h3 id="错误状态码"><a href="#错误状态码" class="headerlink" title="错误状态码"></a>错误状态码</h3><p>程序在数据中发现错误就会退出，并把退出状态置为2。怎么在程序结束后检查错误状态呢？</p><p>要看操作系统</p><p>如果你的计算机是Mac、Linux、其他UNIX，或你在Windows上使用Cygwin，可以用以下命令显示错误状态：</p><pre><code class="bash">$ echo $?</code></pre><p>如果用的是Windows的命令提示符，则可以输入：</p><pre><code class="bash">C:\&gt; echo %ERRORLEVEL%</code></pre><p>这两条命令做了相同的事：显示程序结束时返回的那个数字。</p><h3 id="标准错误"><a href="#标准错误" class="headerlink" title="标准错误"></a>标准错误</h3><p>标准错误——一个用来发送错误消息的二号输出</p><p>人有两只耳朵和一张嘴，但进程有一只耳朵（标准输入）和两张嘴（标准输出和标准错误）</p><h3 id="fprintf-打印到数据流"><a href="#fprintf-打印到数据流" class="headerlink" title="fprintf()打印到数据流"></a>fprintf()打印到数据流</h3><p>printf()函数可以将数据发送到标准输出，但printf()只是fprintf()一个的特例</p><p>scanf()  fscanf(stdin, …)</p><pre><code class="c">printf(&quot;我喜欢乌龟！&quot;);fprintf(stdout, &quot;我喜欢乌龟！&quot;);//以上命令等价</code></pre><p>stdout 标准输出</p><p>stderr  标准错误</p><p>stdin 标准输入</p><p><code>&gt;</code>重定向标准输出<code>&lt;</code>重定向标准输入<code>2&gt;</code>重定向标准错误</p><h3 id="用管道连接输入与输出"><a href="#用管道连接输入与输出" class="headerlink" title="用管道连接输入与输出"></a>用管道连接输入与输出</h3><p>符号 | 表示管道（pipe），它能连接一个进程的标准输出与另一个进程的标准输入</p><p><code>bermuda | geo2json</code></p><pre><code class="bash">&gt; (./bermuda | ./geo2json) &lt; spooky.csv &gt; output.json</code></pre><p>只要在每个程序前加上一个<code>|</code>就可以连接多个程序，一连串相连的进程就叫流水线（pipeline），这时<code>&lt;</code>会把文件内容发送到流水线中第一个进程的标准输入，<code>&gt;</code>会捕获流水线中最后一个进程的标准输出</p><p>外面的括号是必需的,这对括号保证了数据文件由bermuda程序的标准输入来读取</p><h3 id="创建自己的数据流"><a href="#创建自己的数据流" class="headerlink" title="创建自己的数据流"></a>创建自己的数据流</h3><p>每条数据流用一个指向文件的指针来表示，可以用<code>fopen()</code>函数创建新数据流</p><pre><code class="c">FILE *in_file = fopen(&quot;input.txt&quot;, &quot;r&quot;);//将创建一条数据流，从文件中读取数据FILE *out_file = fopen(&quot;output.txt&quot;, &quot;w&quot;);//将创建一条数据流，向文件写数据</code></pre><p>fopen()函数接收两个参数：文件名和模式。共有三种模式</p><p>“w”&#x3D; 写（write）写文件<br>“r”&#x3D; 读（read）读文件<br>“a”&#x3D; 追加（append）在文件末尾追加数据</p><p>创建数据流后，可以用fprintf()往数据流中打印数据<br>可以用fscanf()函数从文件中读取数据</p><pre><code class="c">fprintf(out_file, &quot;%s 和 %s &quot;, &quot;红 &quot;, &quot;绿&quot;);fscanf(in_file, &quot;%79[^\n]\n&quot;, sentence);</code></pre><p>最当用完数据流，别忘了关闭它。虽然所有的数据流在程序结束后都会自动关闭，但你仍应该自己关闭它们</p><pre><code class="c">fclose(in_file);fclose(out_file);</code></pre><p>通常情况下，一个进程最多可以有256条数据流。但数据流的数量是有限的，用完后应该关闭它们。</p><p>最早FILE是用宏定义的，而宏的名字通常都要大写。</p><h3 id="首选项"><a href="#首选项" class="headerlink" title="首选项"></a>首选项</h3><p>对GUI程序来说，可以修改程序的首选项；而对于categorize这样的命令行程序，可以传给它命令行参数</p><pre><code class="c">int main(int argc, char *argv[])&#123;.... 做事情....&#125;</code></pre><p>main()函数有两个版本，一个有命令行参数，一个没有。命令行参数通过两个变量传递给main()函数，一个是参数的计数（argc），另一个是指针（指向参数字符串）数组</p><p>用户运行程序时，命令行中第一个参数是程序名。也就是说，第一个命令行参数其实是argv[1]</p><pre><code class="bash">&gt;./categorize mermaid mermaid.csv Elvis elvises.csv the_rest.csv   argv[0] argv[1]...argv[5]</code></pre><p>在程序中打开文件准备读写时，最好检查一下有没有错误发生。好在如果数据流打开失败，fopen()函数会返回0，也就是说如果想检查错误，可以将下面这段代码：</p><pre><code class="c">FILE *in = fopen(&quot;我不存在.txt&quot;, &quot;r&quot;);</code></pre><p>改成这样：</p><pre><code class="c">FILE *in;if (!(in = fopen(&quot;我不存在.txt&quot;, &quot;r&quot;))) &#123;    fprintf(stderr, &quot;无法打开文件.\n&quot;);    return 1;&#125;</code></pre><h3 id="使用库-getopt"><a href="#使用库-getopt" class="headerlink" title="使用库 getopt()"></a>使用库 getopt()</h3><p>unistd.h头文件不属于C标准库，而是POSIX库中的一员。POSIX的目标是创建一套能够在所有主流操作系统上使用的函数。</p><p>getop()使用范例</p><pre><code class="bash">&gt; rocket_to -e 4 -a Brasilia Tokyo London</code></pre><pre><code class="c">#include &lt;unistd.h&gt;...while ((ch = getopt(argc, argv, &quot;ae:&quot;)) != EOF)//ae:告诉getopt()函数“a和e是有效选项”，e后面的冒号表示“-e后面需要再跟一个参数”，getopt()会用optarg变量指向这个参数    switch(ch) &#123;    ...    case &#39;e&#39;:        engine_count = optarg;    ...    &#125;argc -= optind;//最后这两行用来跳过已读取的选项argv += optind;//optind保存了“getopt()函数从命令行读取了几个选项”</code></pre><p>经过一番处理，0号参数不再是程序名了。argv[0]会指向选项后的第一个命令行参数。循环结束以后，为了让程序读取命令行参数，需要调整一下argv和argc变量，跳过所有选项。</p><pre><code class="bash">&gt; rocket_to -e 4 -a Brasilia  Tokyo   London                    argv[0]  argv[1]  argv[2]</code></pre><p>Tips：</p><ul><li>可以多个选项<code>abc:d</code></li><li>可以合并命令行里的选项，如：<code>-td now</code> 与 <code>-d now -t</code></li><li>可以改变选项之间顺序，因为我们用循环读取选项，所以 <code>-d now -t</code>、<code>-t -d now</code>、<code>-td now</code>都一样(</li><li>只要程序在命令行看到一个前缀为－值，就会把它当成选项处理，前提是它必须在命令行参数之前出现</li><li>为了避免歧义，可以用<code>--</code>隔开参数和选项，比如<code>set_temper-ature -c -- -4</code>。getopt()看到<code>--</code>就会停止读取选项，程序会把后面的内容当成普通的命令行参数读取</li></ul><h2 id="4-使用多个源文件"><a href="#4-使用多个源文件" class="headerlink" title="4 使用多个源文件"></a>4 使用多个源文件</h2><h3 id="简明数据类型指南"><a href="#简明数据类型指南" class="headerlink" title="简明数据类型指南"></a>简明数据类型指南</h3><ul><li>char<br>字符在计算机的存储器中以字符编码的形式保存，字符编码是一个数字，因此在计算机看来，A与数字65完全一样（ASCII码）</li><li>int<br>如果你要保存一个整数，通常可以使用int。不同计算机中int的大小不同，但至少应该有16位。一般而言，int可以保存几万以内的数字</li><li>long<br>但如果想保存一个很大的计数呢？long数据类型就是为此而生的。在某些计算机中，long的大小是int的两倍，所以可以保存几十亿以内的数字；但大部分计算机的long和int一样大，因为在这些计算机中int本身就很大。long至少应该有32位</li><li>float<br>float是保存浮点数的基本数据类型。平时你会碰到很多浮点数，比如一杯香橙摩卡冰乐有多少毫升，就可以用float保存</li><li>double<br>但如果想表示很精确的浮点数呢？如果想让计算结果精确到小数点以后很多位，可以使用double。double比float多占一倍空间，可以保存更大、更精确的数字</li></ul><blockquote><p>为什么把一个很大的数保存到short中会变成负数？</p><p>数字以二进制保存，二进制的100 000看起来像这样：<br>x &lt;- 0001 1000 0110 1010 0000<br>当计算机想把这个值保存到short时，发现只能保存2个字节，所以只保存了数字右半边：<br>y &lt;- 1000 0110 1010 0000<br>最高位是1的二进制有符号数会被当成负数处理，它等价于下面的十进制数：<br>-31072</p></blockquote><h3 id="使用类型转换临时转换数值的类型"><a href="#使用类型转换临时转换数值的类型" class="headerlink" title="使用类型转换临时转换数值的类型"></a>使用类型转换临时转换数值的类型</h3><pre><code class="c">int x = 7;int y = 2;//float z = (float)x / (float)y;float z = (float)x / y//如果编译器发现有整数在加、减、乘、除浮点数，会自动完成转换，因此可以减少代码中显式类型转换的次数：printf(&quot;z = %f\n&quot;, z);</code></pre><h3 id="两个关键字"><a href="#两个关键字" class="headerlink" title="两个关键字"></a>两个关键字</h3><p>unsigned<br>用unsigned修饰的数值只能是非负数。由于无需记录负数，无符号数有更多的位可以使用，因此它可以保存更大的数。unsigned int可以保存0到最大值的数。这个最大值是int可以保存最大值的两倍左右。还有signed关键字，但你几乎从没见过，因为所有数据类型默认都是有符号的。<br><code>unsigned char c;</code></p><p>long<br>没错，你可以在数据类型前加long，让它变长。longint是加长版的int；long int可以保存范围更广的数字；long long比long更长；还可以对浮点数用long。(c99和c11支持long long)<br><code>long double d;</code></p><blockquote><p>%.2f把浮点数格式化为小数点后两位</p><p>%hi用来格式化short</p></blockquote><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;limits.h&gt; //含有表示整型（比如int和char）大小的值#include &lt;float.h&gt; //含有表示float和double类型大小的值int main()&#123;printf(&quot;The value of INT_MAX is %i\n&quot;, INT_MAX);printf(&quot;The value of INT_MIN is %i\n&quot;, INT_MIN);printf(&quot;An int takes %z bytes\n&quot;, sizeof(int));printf(&quot;The value of FLT_MAX is %f\n&quot;, FLT_MAX);printf(&quot;The value of FLT_MIN is %.50f\n&quot;, FLT_MIN);printf(&quot;A float takes %z bytes\n&quot;, sizeof(float));    //可把INT和FLT替换成CHAR（char）、DBL（double）、SHRT（short）或LNG（long）return 0;&#125;</code></pre><blockquote><p>位数是计算机能够处理的数值长度</p></blockquote><h3 id="声明与定义分离"><a href="#声明与定义分离" class="headerlink" title="声明与定义分离"></a>声明与定义分离</h3><p><code>float add_with_tax()(float f);</code></p><p>声明只是一个函数签名：一条包含函数名、形参类型与返回类型的记录</p><h3 id="创建头文件"><a href="#创建头文件" class="headerlink" title="创建头文件"></a>创建头文件</h3><p>两步</p><ol><li>创建一个扩展名为.h的文件，把你的声明写在里面，不用在头文件中包含main()函数，反正也没有函数会调用它</li><li>在主代码中包含头文件，应该在代码的顶部加一句include</li></ol><p><code>#include &#39;asdf.h&#39;</code> <code>#include &lt;stdio.h&gt;</code></p><p>通常情况下，引号表示以相对路径查找头文件，如果不加目录名，只包含一个文件名，编译器就会在当前目录下查找头文件；如果用了尖括号，编译器就会以绝对路径查找头文件</p><p>当编译器看到尖括号，就会到标准库代码所在目录查找头文件，但现在你的头文件和.c文件在同一目录下，用引号把文件名括起来，编译器就会在本地查找文件。本地头文件也可以带目录名，但通常会把它和C文件放在相同目录中。</p><p>当编译器在代码中读到#include，就会读取头文件中的内容，仿佛它们本来就在代码中。</p><blockquote><p>如果编译器发现你调用了一个它没见过的函数，就会假设这个函数返回int</p></blockquote><h3 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h3><table><thead><tr><th align="center">1</th><th align="center">2</th><th align="center">3</th></tr></thead><tbody><tr><td align="center">auto</td><td align="center">if</td><td align="center">break</td></tr><tr><td align="center">int</td><td align="center">case</td><td align="center">long</td></tr><tr><td align="center">char</td><td align="center">register</td><td align="center">continue</td></tr><tr><td align="center">return</td><td align="center">default</td><td align="center">short</td></tr><tr><td align="center">do</td><td align="center">sizeof</td><td align="center">double</td></tr><tr><td align="center">static</td><td align="center">else</td><td align="center">struct</td></tr><tr><td align="center">entry</td><td align="center">switch</td><td align="center">extern</td></tr><tr><td align="center">typeof</td><td align="center">float</td><td align="center">union</td></tr><tr><td align="center">for</td><td align="center">unsigned</td><td align="center">goto</td></tr><tr><td align="center">while</td><td align="center">enum</td><td align="center">void</td></tr><tr><td align="center">const</td><td align="center">signed</td><td align="center">volatile</td></tr></tbody></table><h3 id="共享代码"><a href="#共享代码" class="headerlink" title="共享代码"></a>共享代码</h3><p>为了共享代码，可以把代码放到一个单独的C文件中。<br>需要把函数声明放到一个单独的.h头文件中。<br>在所有需要使用共享代码的C文件中包含这个头文件。<br>在编译的命令中列出所有C文件。</p><pre><code class="c">//encrypt.hvoid encrypt(char *message);</code></pre><pre><code class="c">//encrypt.c#include &quot;encrypt.h&quot;void encrypt(char *message)&#123;    char c;    while (*message) &#123;    *message = *message ^ 31;    message++;    &#125;&#125;</code></pre><pre><code class="c">//mainprog.c#include &lt;stdio.h&gt;#include &quot;encrypt.h&quot;int main()&#123;    char msg[80];    while (fgets(msg, 80, stdin)) &#123;    encrypt(msg);    printf(&quot;%s&quot;, msg);    &#125;&#125;</code></pre><pre><code class="bash">./ gcc message_hider.c encrypt.c -o message_hider</code></pre><blockquote><p>共享变量<br>为了防止两个源文件中的同名变量相互干扰，变量的作用域仅限于某个文件内。如果你想共享变量，就应该在头文件中声明，并在变量名前加上extern关键字：<br><code>extern int passcode;</code></p></blockquote><h3 id="gccの编译"><a href="#gccの编译" class="headerlink" title="gccの编译"></a>gccの编译</h3><p>gcc -c会编译代码，但不会链接目标文件</p><pre><code class="bash">./ gcc -c *.c</code></pre><p>gcc -o 链接，在例子中把目标文件链接为一个叫launch的可执行程序</p><pre><code class="bash">./ gcc *.o -o launch</code></pre><h3 id="Make"><a href="#Make" class="headerlink" title="Make"></a>Make</h3><p>如果你掌握了某样东西的简单规则，别多想，自动化它</p><p>make编译的文件叫目标（target）。目标可以是任何用其他文件生成的文件，也就是说目标可以是一批文件压缩而成的压缩文档</p><p>make需要知道：依赖项、生成方法。依赖项和生成方法合在一起构成了一条规则。有了规则，make就知道如何生成目标</p><blockquote><p>versions :</p><p>UNIX make</p><p>MinGW mingw32-make</p><p>Microsoft  NMAKE</p></blockquote><p>makefile文件书写</p><pre><code class="makefile">launch.o: launch.c launch.h thruster.h//目标：依赖项    gcc -c launch.c//生成方法（必须以tab开头）                                            //这是规则thruster.o: thruster.h thruster.c    gcc -c thruster.claunch: launch.o thruster.o    gcc launch.o thruster.o -o launch</code></pre><p>之后直接</p><pre><code class="bash">./ make launch</code></pre><blockquote><p>更自动化的工具：autoconf</p></blockquote><p>-&gt; <a href="http://tinyurl.com/yczmjx">GUN Make Manual</a></p><h2 id="5-结构、联合与位字段"><a href="#5-结构、联合与位字段" class="headerlink" title="5 结构、联合与位字段"></a>5 结构、联合与位字段</h2><h3 id="结构-Struct"><a href="#结构-Struct" class="headerlink" title="结构 Struct"></a>结构 Struct</h3><p>结构化数据结构 structured data type</p><p>结构是一种由一系列其他数据类型组成的数据类型。</p><pre><code class="c">struct fish &#123;    const char *name;    const char *species;    int teeth;    int age;&#125;;</code></pre><p>创建一个新自定义的数据类型，由其它一批数据组成。</p><ul><li>结构的大小固定</li><li>结构中的数据都有名字</li></ul><p>创建数据：</p><pre><code class="c">struct fish snappy = &#123;&quot;Snappy&quot;, &quot;Piranha&quot;, 69, 4&#125;</code></pre><p>把参数封装在结构中，代码会更稳定</p><p>结构变量是结构本身的名字</p><p>读取时只能按名访问，使用“.”运算符读取结构字段：&lt;结构&gt;.&lt;字段名&gt;语法（也叫“点表示法”）</p><pre><code class="c">struct fish snappy = &#123;&quot;Snappy&quot;, &quot;piranha&quot;, 69, 4&#125;;printf(&quot;Name = %s\n&quot;, snappy.name);</code></pre><p>为结构变量赋值相当于叫计算机复制数据</p><h3 id="结构中的结构"><a href="#结构中的结构" class="headerlink" title="结构中的结构"></a>结构中的结构</h3><p>为什么要嵌套定义结构？</p><p>之所以要这么做是为了对抗复杂性 。通过使用结构，我们可以建立更大的数据块。通过把结构组合在一起，我们可以创建更大的数据结构。本来你只能用int、short，但有了结构以后，就可以描述十分复杂的东西，比如网络流和视频图像。</p><pre><code class="c">struct preferences &#123;    const char *food;    float exercise_hours;&#125;;struct fish &#123;    const char *name;    const char *species;    int teeth;    int age;    struct preferences care; //nesting 嵌套   struct fish snappy = &#123;&quot;Snappy&quot;, &quot;Piranha&quot;, 69, 4, &#123;&quot;Meat&quot;, 7.5&#125;&#125;;   printf(&quot;Snappy 喜欢吃 %s&quot;, snappy.care.food);    printf(&quot;Snappy 喜欢锻炼 %f hours&quot;, snappy.care.exercise_hours); //访问&#125;;</code></pre><h3 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h3><p>在C语言中可以为结构创建别名，你只要在struct关键字前加上typedef，并在右花括号后写上类型名，就可以在任何地方使用这种新类型。</p><pre><code class="c">typedef struct cell_phone &#123;    int cell_no;    const char *wallpaper;    float minutes_of_charge;&#125; phone;</code></pre><p>当你用typedef为结构创建别名，需要决定别名叫什么。别名其实就是类型名，也就是说结构有两个名字：一个是结构名（struct cell_phone），另一个是类型名（phone）。为什么要有两个名字？一般一个就够了。如果只写类型名而不写结构名，编译器也没意见：</p><pre><code class="c">typedef struct &#123;    int cell_no;    const char *wallpaper;    float minutes_of_charge;&#125; phone;phone p = &#123;5557879, &quot;s.png&quot;, 1.35&#125;;</code></pre><p>这样的结构称为匿名结构。</p><h3 id="更新结构"><a href="#更新结构" class="headerlink" title="更新结构"></a>更新结构</h3><pre><code class="c">fish snappy = &#123;&quot;Snappy&quot;, &quot;piranha&quot;, 69, 4&#125;;printf(&quot;Hello %s\n&quot;, snappy.name);snappy.teeth = 68;</code></pre><p>计算机通过把值赋给函数形参的方式向函数传值，所有赋值都会复制</p><p>如果想让函数更新结构变量，就不能把结构作为参数传递，因为这样做仅仅是将数据的副本复制给<br>了函数。取而代之，可以传递结构的地址</p><p>还有一种表示结构指针的方法，它更易于阅读。</p><p><code>(*t).age</code> 和 <code>t-&gt;age</code> 等价</p><p>“指针-&gt;字段”等于“(*指针).字段”“-&gt;”表示法省掉了括号，代码更易阅读。</p><h3 id="联合？"><a href="#联合？" class="headerlink" title="联合？"></a>联合？</h3><p>每次创建结构实例，计算机都会在存储器中相继摆放字段</p><p>联合则不同。当定义联合时，计算机只为其中一个字段分配空间，并且计算机会为其中最大的字段分配空间，然后由你决定里面保存什么值</p><blockquote><p>计算机需要保证联合的大小固定。唯一的办法就是让它足够大，任何一个字段都能装得下</p></blockquote><pre><code class="c">typedef union &#123;//这里的关键字是union    short count;    float weight;    float volume;&#125; quantity;</code></pre><h3 id="使用联合"><a href="#使用联合" class="headerlink" title="使用联合"></a>使用联合</h3><ul><li><p>C89 方式</p><p>把值赋给联合中第一个字段</p><pre><code class="c">quantity q = &#123;4&#125;;</code></pre></li><li><p>指定初始化器（designated initializer）</p><pre><code class="c">quantity q = &#123; .weight = 1.5 &#125;;</code></pre></li><li><p>点 表示法</p><p>在第一行创建变量，然后在第二行设置字段的值</p><pre><code class="c">quantity q;q.volume = 3.7;</code></pre></li></ul><p>无论用哪种方法设置联合的值，都只会保存一条数据。联合只是提供了一种创建支持不同数据类型的变量的方法</p><p>“指定初始化器”也可以用来设置结构字段的初值，并提高代码的可读性</p><pre><code class="c">typedef struct &#123;    const char *color;    int gears;    int height;&#125; bike;bike b = &#123;.height=17, .gears=21&#125;;</code></pre><h3 id="联合与结构"><a href="#联合与结构" class="headerlink" title="联合与结构"></a>联合与结构</h3><pre><code class="c">typedef struct &#123;    const char *name ;    const char *country;    quantity amount;&#125; fruit_order;fruit_order apples = &#123;&quot;apples&quot;,&quot;English&quot;,.amount.weight = 4.2&#125;printf(&quot;This order contains %2.2f lbs of %s\n&quot;,apples.amount.weight, apples.name);</code></pre><h3 id="枚举变量保存符号"><a href="#枚举变量保存符号" class="headerlink" title="枚举变量保存符号"></a>枚举变量保存符号</h3><p>你需要某种方法记录我们在联合中保存了什么值。</p><p>结构与联合用分号（;）来分割数据项，而枚举用逗号。</p><pre><code class="c">enum colors &#123;RED, GREEN, PUCE&#125;;//可以用typedef为类型起个名字enum colors favorite = PUCE;</code></pre><p><em><strong>so？枚举好处？？？</strong></em> 限制我能给的值？ 实例感受下：</p><pre><code class="c">typedef enum &#123;    COUNT,    POUNDS,    PINTS&#125;unit_of_measure;typedef struct &#123;    const char *name;    const char *country;    quantity amount;    unit_of_measure units;&#125;fruit_order;void display(fruit_order order) &#123;    printf(&quot;This order contains &quot;);    if (order.units==PINTS) printf(&quot;%2.2f pints of %s\n&quot;, order.amount.volume, order.name);    else if (order.units==POUNDS) printf(&quot;%2.2f lbs of %s\n&quot;, order.amount.weight, order.name);    else printf(&quot;%i %s\n&quot;, order.amount.count, order.name);&#125;int main() &#123;    fruit_order strawberries= &#123;        &quot;strawberries&quot;,        &quot;Spain&quot;,        .amount.weight=17.6,        POUNDS    &#125;;    display(strawberries);    return 0;&#125;</code></pre><h3 id="位字段（bitfield）"><a href="#位字段（bitfield）" class="headerlink" title="位字段（bitfield）"></a>位字段（bitfield）</h3><p>C语言不支持二进制字面值，不过它支持十六进制字面值。每当C语言看到0x开头的数字，就认为它是以16为基数的数字（0x54）</p><p>可以用位字段指定一个字段有多少位</p><pre><code class="c">typedef struct &#123;    unsigned int low_pass_vcf:1;//位字段应当声明为unsigned int    unsigned int filter_coupler:1;//表示该字段只使用1位存储空间    unsigned int reverb:1;    unsigned int sequential:4;    ...&#125; synth;</code></pre><p>如果你有一连串的位字段，计算机会放在一起，以节省空间，也就是说如果有8个1位的位字段，计算机就会把它们保存在一个字节中</p><p>如果编译器发现结构中只有一个位字段，还是会把它填充成一个字，这就是为什么位字段总是组合在一起</p><h2 id="6-数据结构与动态存储"><a href="#6-数据结构与动态存储" class="headerlink" title="6 数据结构与动态存储"></a>6 数据结构与动态存储</h2><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>保存可变数量的数据，插入数据非常快</p><p>链表是一种抽象数据结构。链表是通用的，可以用来保存很多不同类型的数据</p><p>链表保存了一条数据和一个链向另一条数据的链接</p><p>如果一个结构包含一个链向同种结构的链接，那么这个结构就被称为递归结构</p><p>只要在结构中保存指针，island数据就含有下一个我们将游览的island的地址。只要我们的代码能访问一个island，就能够跳到下一个island。</p><p>在递归结构中，需要包含一个相同类型的指针， C语言的语法不允许用typedef别名来声明它，因此必须为结构起一个名字</p><pre><code class="c">typedef struct island &#123;char *name;char *opens;char *closes;struct island *next;&#125; island;island amity = &#123;&quot;Amity&quot;, &quot;09:00&quot;, &quot;17:00&quot;, NULL&#125;;island craggy = &#123;&quot;Craggy&quot;, &quot;09:00&quot;, &quot;17:00&quot;, NULL&#125;;island isla_nublar = &#123;&quot;Isla Nublar&quot;, &quot;09:00&quot;, &quot;17:00&quot;, NULL&#125;;island shutter = &#123;&quot;Shutter&quot;, &quot;09:00&quot;, &quot;17:00&quot;, NULL&#125;;amity.next = &amp;craggy;craggy.next = &amp;isla_nublar;isla_nublar.next = &amp;shutter;\\插入数据island skull = &#123;&quot;Skull&quot;, &quot;09:00&quot;, &quot;17:00&quot;, NULL&#125;;isla_nublar.next = &amp;skull;skull.next = &amp;shutter;void display(island *start)&#123;    island *i = start;    for(; i != NULL; i = i-&gt;next)&#123;    printf(&quot;Name:%s\n open:%s-%s\n&quot;,i-&gt;name,i-&gt;open,i-&gt;closes);            &#125;&#125;</code></pre><p>在C语言中，NULL的值实际上为0，NULL专门用来把某个指针设为0。</p><p>想快速地插入数据，就需要<strong>链表</strong>。想直接访问元素，就应该用<strong>数组</strong></p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>栈是存储器用来保存局部变量的区域。数据保存在局部变量中，一旦离开函数，变量就会消失。堆是程序中用来保存长期使用数据的地方。堆上的数据不会自动清除，因此堆是保存数据结构的绝佳场所</p><h3 id="malloc-与-free"><a href="#malloc-与-free" class="headerlink" title="malloc() 与 free()"></a>malloc() 与 free()</h3><p><code>malloc()</code>，memory allocation 申请储存器。接收一个参数：所需要的字节数。常与<code>sizeof</code>一起使用。<code>sizeof</code>告知某种数据类型在系统中占了多少字节。这种数据类型可以是结构，也可以是int或double这样的基本数据类型。返回一个指针，指针中保存了存储器块的起始地址。<code>free()</code>需要接收<code>malloc()</code>创建的存储器的地址。只要告诉C标准库存储器块从哪里开始，它就能查阅记录，知道要释放多少存储器。</p><pre><code class="c"># include &lt;stdlib.h&gt;//使用malloc()和free()需要包含这个头文件malloc(sizeof(island));island *p = malloc(sizeof(island));//返回的通用指针，即void*类型free(p);</code></pre><p>虽然程序结束以后，所有堆空间会自动释放，但用free()显式释放创建的所有动态存储器是一种好的做法</p><h3 id="字符串复制"><a href="#字符串复制" class="headerlink" title="字符串复制"></a>字符串复制</h3><p><code>string.h</code>的头文件中有一个函数<code>strdup()</code>。它可以把字符串复制到堆上</p><pre><code class="c">char *s = &quot;MONA LISA&quot;char *copy = strdup(s);</code></pre><p>作用机理为： 计算出字符串的长度，然后调用malloc()函数在堆上分配相应的空间。再把所有字符复制到堆上的新空间。</p><p>strdup()总是在堆上创建空间，而不是在栈上，因为栈用来保存局部变量，而局部变量很快就会被清除。</p><p>并且因为strdup()把新字符串放在堆上，所以千万记得要用free()函数释放空间。</p><p>有了动态分配存储器，就能在运行时创建需要的存储器。使用malloc()与free()，可以访问动态堆存储器。</p><h3 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h3><p>一些语言会跟踪程序在堆上分配的数据，当程序不再使用这些数据时，就会释放它们。</p><p>C语言非常古老，发明它的时候，绝大多数语言都没有自动 “垃圾回收”机制。</p><p>操作系统会在程序结束时清除所有存储器。不过，还是应该显式释放你创建的每样东西，这是一种好的习惯。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>一些举例：</p><ul><li>关联数组（也叫映射）<ul><li>连接“键”（key）信息与“值”（value）信息。可以用来连接两种不同类型的数据。</li></ul></li><li>双向链表<ul><li>和普通链表很像，但双向连接，可以双向处理。</li></ul></li><li>链表<ul><li>可以用来保存一串数据项，并使插入新数据项变得简单，但只能沿着一个方向处理。</li></ul></li><li>二叉树<ul><li>每一项都与其他两项相连，可以用来保存层次信息。</li></ul></li></ul><h3 id="valgrind"><a href="#valgrind" class="headerlink" title="valgrind"></a>valgrind</h3><p>valgrind通过伪造malloc()可以监控分配在堆上的数据。当程序想分配堆存储器时，valgrind将会拦截对malloc()和free()的调用，然后运行自己的malloc()和free()。valgrind<br>的malloc()会记录调用它的是哪段代码和分配了哪段存储器。程序结束时，valgrind会汇报堆上有哪些数据，并告诉这些数据是由哪段代码创建的。</p><p>调试信息是编译时打包到可执行文件中的附加数据，比如某段代码在源文件中的行号。只要有调试信息，valgrind就能提供更多有助于发现存储器泄漏的信息。</p><p>为了在可执行文件中加入调试信息，需要加上-g开关，并重新编译源代码。</p><pre><code class="bash">$ gcc -g spies.c -o spies// -g 开关告诉编译器要记录要编译代码的行号</code></pre><p>存储器泄漏是C程序中最难发现的错误。</p><p>valgrind工具可以发现泄漏、定位泄漏、检验泄漏是否修复</p><h2 id="7-高级函数"><a href="#7-高级函数" class="headerlink" title="7 高级函数"></a>7 高级函数</h2><h3 id="向函数传递函数"><a href="#向函数传递函数" class="headerlink" title="向函数传递函数"></a>向函数传递函数</h3><pre><code class="c">int sports_no_bieber(char *s)&#123;    return strstr(s, &quot;sports&quot;) &amp;&amp; !strstr(s, &quot;bieber&quot;);&#125;void find(int(*match)(char*))&#123;    int i;    puts(&quot;Search results:&quot;);    puts(&quot;------------------------------------&quot;);    for (i = 0; i &lt; NUM_ADS; i++) &#123;        if (match(ADS[i])) &#123;            printf(&quot;%s\n&quot;, ADS[i]);        &#125;    &#125;    puts(&quot;------------------------------------&quot;);&#125;find(sports_no_bieber);</code></pre><p>函数名是指向函数的指针，创建函数的同时也创建了一个同名函数指针，指针中保存了函数的地址，当调用函数时，你在使用函数指针。</p><blockquote><p>两者并不完全相同，函数名是L-value，而指针变量是R-value，因此函数名不能像指针变量那样自加或自减。</p></blockquote><p>函数有不同的返回类型和形参，所以它有许多不同的类型，没有<code>function*</code>的说法。</p><h3 id="创建函数指针"><a href="#创建函数指针" class="headerlink" title="创建函数指针"></a>创建函数指针</h3><p>需要把函数的返回类型和接收参数类型告诉C编译器。</p><pre><code class="c">int (*warp_fn)(int);warp_fn = go_to_warp_speed;//创建一个叫warp_fn的变量，用来保存go_to_warp_speed()函数的地址。相当于调go_to_warp_speed(4)warp_fn(4);char** (*names_fn)(char*,int);names_fn = album_names;//创建一个叫names_fn的变量，用来保存album_names()函数的地址。char** results = names_fn(&quot;Sacha Distel&quot;, 1972);</code></pre><p>一旦声明了函数指针变量，就可以像其他变量一样使用它，可以对它赋值，也可以把它加到数组中，还可以把它传给函数</p><blockquote><p>char**是一个指针，通常用来指向字符串数组</p></blockquote><p>函数指针是C语言最强大的特性之一</p><pre><code class="c">char** (*names_fn)(char*,int)返回类型       指针变量    参数类型            在这里声明形参的名称</code></pre><blockquote><p><code>match(ADS[i])</code>可以换成<code>(*match)(ADS[i])</code></p><p><code>find(sports_or_workout)</code>可以写成<code>find(&amp;sports_or_workout)</code></p><p>即使省略*和&amp;，C编译器也能识别它们，这样代码更好读</p></blockquote><h3 id="排序qsort"><a href="#排序qsort" class="headerlink" title="排序qsort()"></a>排序qsort()</h3><blockquote><p>void指针(void *)可以保存任何类型数据的地址，但使用前必须把它转换为具体类型</p></blockquote><pre><code class="c">qsort(void *array, size_t length, size_t item_size, int (*compar)(const void *, const void *));//qsort(数组指针，数组长度，数组中每个元素长度，比较器函数指针（参数）)</code></pre><p>比较器会返回给qsort()三种值</p><p>如果第一个值比第二个值大，就返回正数；如果第一个值比第二个值小，就返回负数；如果两个值相等，就返回0</p><pre><code class="c">int compare_scores(const void* score_a, const void* score_b)&#123;    int a = *(int*)score_a;    int b = *(int*)score_b;//这样将void指针转换为整型指针        ...&#125;</code></pre><p>字符串是字符指针，指向字符串的指针是指针的指针（绕口令哈哈哈）</p><pre><code class="c">int compare_names(const void* a, const void* b)&#123;    char** sa = (char**)a;    char** sb = (char**)b;    return strcmp(*sa, *sb); //需要用*来取得字符串&#125;</code></pre><h3 id="创建函数指针数组"><a href="#创建函数指针数组" class="headerlink" title="创建函数指针数组"></a>创建函数指针数组</h3><p>如果想在数组中保存函数，就必须告诉编译器函数的具体特征：函数返回什么类型以及接收什么参数</p><pre><code class="c">void (*replies[])(response) = &#123;dump, second_chance, marriage&#125;;//返回类型（*指针变量）（参数类型）</code></pre><blockquote><p>C语言在创建枚举时会给每个符号分配一个从0开始的数字</p></blockquote><p>函数指针数组让代码易于管理，它们让代码变得更短、更易于扩展，从而可以伸缩</p><h3 id="可变参数函数"><a href="#可变参数函数" class="headerlink" title="可变参数函数"></a>可变参数函数</h3><p>参数数量可变的函数被称为可变参数函数。C标准库<code>stdarg.h</code>中有一组宏（macro）可以帮助建立可变参数函数</p><blockquote><p>可以把宏想象成一种特殊类型的函数，它可以修改源代码</p></blockquote><pre><code class="c">\\打印一连串int函数#include &lt;stdarg.h&gt;void print_ints(int args, ...)&#123;\\在C语言中，函数参数后的省略号“…”表示还有更多参数    va_list ap;\\保存传给函数的其他参数    va_start(ap, args);    \\需要把最后一个普通参数写明(至少需要一个普通参数)    int i;    for (i = 0; i &lt; args; i++) &#123;        printf(&quot;argument: %i\n&quot;, va_arg(ap, int));\\用va_arg读取保存在va_list中的参数    &#125;    va_end(ap);   \\当读完了所有参数，要用va_end宏来让C结束&#125;</code></pre><blockquote><p>va_arg接收两个值：va_list和要读取参数的类型。本例中所有参数都是int</p><p>宏用来在编译前重写代码，这里的几个宏<code>va_start</code>、<code>va_arg</code>和<code>va_end</code>看起来很像函数，但实际上隐藏在它们背后的是一些神秘的指令。在编译前，预处理器会根据这些指令在程序中插入巧妙的代码</p></blockquote><ul><li>va_arg 会返回下一个额外参数，那么一定要搭配循环遍历吗？🤔</li></ul><h2 id="8-静态库与动态库"><a href="#8-静态库与动态库" class="headerlink" title="8 静态库与动态库"></a>8 静态库与动态库</h2><h3 id="库文件引用"><a href="#库文件引用" class="headerlink" title="库文件引用"></a>库文件引用</h3><p>&lt;stdio.h&gt;尖括号代表标准头文件，编译器就会在标准头文件目录中查找文件</p><p>“encrypt.h”引号代表本地头文件，与程序在同一目录中</p><blockquote><p>通常类UNIX操作系统（如Mac或Linux）中，编译器会在以下目录查找头文件：<br>&#x2F;usr&#x2F;local&#x2F;include<br>&#x2F;usr&#x2F;include</p><p>如果是MinGW版的gcc，编译器会在\MinGW\include中查找</p></blockquote><h3 id="共享代码-1"><a href="#共享代码-1" class="headerlink" title="共享代码"></a>共享代码</h3><p>会希望在程序之间共享两类代码：.h头文件和.o目标文件</p><h4 id="h头文件"><a href="#h头文件" class="headerlink" title=".h头文件"></a>.h头文件</h4><ol><li><p>把头文件保存在标准目录中</p><p>可以在源代码中用尖括号包含它们</p></li><li><p>在include语句中使用完整路径名</p><pre><code class="c"># include &quot;/my_header_files/encrypt.h&quot;</code></pre></li><li><p>告诉编译器去哪找头文件</p><p>可以使用gcc的<code>-I</code>选项</p><pre><code class="bash">$ gcc -I/my_header_files test_code.c  ...   -o test_code</code></pre></li></ol><p>编译器会先检查<code>-I</code>选项中的目录，然后像往常一样检查所有标准目录</p><h4 id="o目标文件"><a href="#o目标文件" class="headerlink" title=".o目标文件"></a>.o目标文件</h4><p>可以把.o目标文件放在一个类似共享目录的地方，用完整路径名共享</p><pre><code class="bash">$ gcc -I/my_header_files test_code.c       /my_object_files/encrypt.o       /my_object_files/checksum.o -o test_code</code></pre><h4 id="存档"><a href="#存档" class="headerlink" title="存档"></a>存档</h4><p>把一批目标文件打包在一起就成了存档文件。只要创建目标文件存档，就可以一次告诉编译器一<br>批目标文件</p><p>可以使用<code>nm</code>命令查看存档中的内容，列出存档中保存文件的名字</p><p>可以使用<code>ar</code>命令来存档</p><pre><code class="bash">$ ar -rcs libhfsecurity.a encrypt.o checksum.o</code></pre><p>参数r表示如果.a文件存在就更新它，参数c表示创建存档时不显示反馈信息，参数s表示需要ar在.a文件开头建立索引。接着是.a文件的文件名，以及需要存档的文件</p><p>所有.a文件名都是libXXX.a的形式。这是命名存档的标准方式，存档是静态库（static library），所以要以lib开头，否则编译器找不到它们</p><p>接着可以把存档保存在库目录中，并不同情况下进行编译</p><ol><li><p>把.a文件保存在标准目录中，如&#x2F;usr&#x2F;local&#x2F;lib</p><p>确保代码能正确运行之后会把存档安装在标准目录，这个目录专门用来放本地自定义库</p><p>用-I开关编译代码</p><pre><code class="bash">$ gcc test_code.c -lhfsecurity -o test_code</code></pre></li><li><p>把.a文件放在其他目录中</p><p>如果还处于开发阶段，或者在系统目录中安装代码不合适，也可以创建自己的库目录<code>/my_lib</code></p><p>用-L选项告诉编译器去哪找存档</p><pre><code class="bash">$ gcc test_code.c -L/my_lib -lhfsecurity -o test_code</code></pre></li></ol><p>如果要使用多个存档，可以设置多个-l选项，<code>hfsecurity</code>叫编译器去找一个叫<code>libhfsecurity.a</code>的存档，-l选<br>项后的名字必须与存档名的一部分匹配，如果存档叫libawesome.a，可以用-lawesome开关编译程序</p><blockquote><p>不同机器库目录的内容可以相差很多。因为不同操作系统提供了不同的服务。每个.a文件都是一个独立的库，有的库用来连接网络，有的用来创建GUI程序</p><p>找几个.a文件来试用一下nm命令。每个模块都列出了很多名字，它们是一些已经编译好了的函数，可以在程序中使用它们：0000000000000000 T _yywrap，T代表文本(Text)，说明这是一个函数，函数名为yywrap</p><p>nm命令会告诉你每个.o目标文件的名字，然后列出所有目标文件中的名字，如果某个名字前出现了T，就说明它是目标文件中某个函数的名字</p></blockquote><h3 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h3><p>带有元信息的可重定位目标文件，由一个或多个.o文件创建，核心是一段目标代码</p><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>首先创建目标文件</p><pre><code class="bash">$ gcc -I/includes -fPIC -c hfcal.c -o hfcal.o</code></pre><p><code>-fPIC</code>表示创建位置无关代码。有的操作系统和处理器要用位置无关代码创建库，这样它们才能在运行时决定把代码加载到存储器的哪个位置，事实上在大多数操作系统中都不需要加这个选择</p><blockquote><p><strong>位置无关代码</strong></p><p>位置无关代码就是无论计算机把它加载到存储器的哪个位置都可以运行的代码。想象你有一个动态库，它要使用加载点500个字节以外的某个全局变量的值，那么如果操作系统把库加载到其他地方就会出错。只要让编译器创建位置无关的代码，就可以避免这种问题。<br>包括Windows在内的一些操作系统在加载动态库时会使用一种叫存储器映射的技术，也就是说所有代码其实都是位置无关的。若你在Windows上用刚刚那条命令编译代码，gcc可能会给出一条警告，告诉你不需要-fPIC选项。你既可以奉命删除它，也可以当作没看见。</p></blockquote><p>然后生成动态库</p><p>绝大部分操作系统都支持动态库，它们的工作方式也大抵相同，但称呼却大相径庭</p><p>Windows 动态链接库；Linux和Unix 共享目标文件；Mac 动态库</p><pre><code class="bash">$ gcc -shared hfcal.o -oC:\libs\hfcal.dll//Windows 上的MinGW                       /libs/libhfcal.dll.a   //Windows上的Cygwin                       /libs/libhfcal.so      //Linux或Unix                       /libs/libhfcal.dylib  //Mac</code></pre><p>-shared选项告诉gcc你想把.o目标文件转化为动态库</p><p>编译器创建动态库时会把库的名字保存在文件中，假设你在Linux中创建了一个叫libhfcal.so的库，那么libhfcal.so文件就会记住它的库名叫hfcal。也就是说，一旦你用某个名字编译了库，就不能再修改文件名了。若想重命名库，就必须用新的名字重新编译一次</p><blockquote><p>在一些古老的Mac系统中没有-shared 选项，但是可以用-dynamiclib代替</p></blockquote><p>最后编译程序</p><p>一旦创建了动态库，你就可以像静态库那样使用它</p><pre><code class="bash">$ gcc -I/include -c elliptical.c -o elliptical.o$ gcc elliptical.o -L/libs -lhfcal -o elliptical</code></pre><blockquote><p>在MinGW和Cygwin上，库名的格式有很多种，hfcal的库名可以是: libhfcal.dll.a、libhfcal.dll、hfcal.dll</p></blockquote><p>尽管使用的命令和静态存档一模一样，但两者编译的方式不同。因为库是动态的，所以编译器不会在可执行文件中包含库代码，而是插入一段用来查找库的“占位符”代码，并在运行时链接库</p><p>可以运行程序了</p><p>Mac可以直接运行当你在Mac中编译程序时，文件的完整路径&#x2F;libs&#x2F;libhfcal.dylib保存在可执行文件中，程序启动时知道去哪里找它</p><p>在Linux和大部分Unix中，编译器只会记录libhfcal.so库的文件名，而不会包含路径名。也就是说如果不把hfcal库保存到标准目录（如&#x2F;usr&#x2F;lib），程序就找不到它。为了解决这个问题，Linux会检查保存在LD_LIBRARY_PATH变量中的附加目录。只要把库目录添加到LD_LIBRARY_PATH中，并export它，elliptical就能找到libhfcal.so</p><pre><code class="bash">&gt; export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/libs</code></pre><p>Windows同Linux一样，它的可执行文件也只保存hfcal库的名字，不保存目录名。不过Windows没有用LD_LIBRARY_PATH变量去找hfcal库。Windows程序会先在当前目录下查找，如果没找到就去查找保存在PATH变量中的目录</p><pre><code class="bash">//CygwinPATH=&quot;$PATH:/libs&quot;//MinGWPATH=&quot;%PATH%:C:\libs&quot;</code></pre><p>在Linux和Mac中，动态库通常保存在&#x2F;usr&#x2F;lib或&#x2F;usr&#x2F;local&#x2F;lib中；而在Windows中，程序员通常把.DLL和可执行文件保存在同一个目录下</p><ul><li>动态库在修改库文件后不用再重新编译项目文件</li></ul><p>有了动态库，就能在运行时替换代码。不用重新编译程序，你就能修改它。如果你有很多程序，它们共享一段相同的代码，通过建立动态库，就可以同时更新所有程序</p><h2 id="9-进程与系统调用"><a href="#9-进程与系统调用" class="headerlink" title="9 进程与系统调用"></a>9 进程与系统调用</h2><p>C程序无论做什么事都要靠操作系统。如果它想与硬件打交道，就要进行系统调用。系统调用是操作系统内核中的函数，C标准库中大部分代码都依赖于它们</p><h3 id="system"><a href="#system" class="headerlink" title="system()"></a>system()</h3><p>接收一个字符串参数，并把它当作命令执行</p><pre><code class="c">system(&quot;dir D:&quot;);//打印D盘内容system(&quot;gedit&quot;);       //在Linux中启动编辑器system(&quot;say &#39;End of Line&#39; &quot;);//在Mac上朗读文本</code></pre><p>在一些操作系统中，系统调用的代码位于操作系统内核。而对其他操作系统而言，系统调用可能保存在动态库中</p><blockquote><p><strong>内核</strong>？</p><p>在大部分计算机上，系统调用就是操作系统内核中的函数。什么是内核？虽然你从来没在屏幕上看到过它，但内核其实一直都在那里控制计算机。内核是计算机中最重要的程序，它主管三样东西：<br>    进程<br>只有当内核把程序加载到存储器时程序才能运行。内核创建进程，并确保它们得到了所需资源。内核同时也会留意那些变得贪得无厌或者已经崩溃的进程。<br>    存储器<br>计算机所能提供的存储器资源是有限的，因此内核必须小心翼翼地分配每个进程所能使用的存储器大小。内核还能把部分存储器交换到磁盘从而增加虚拟存储器空间。<br>    硬件<br>内核利用设备驱动与连接到计算机上的设备交互。你的程序在不了解键盘、屏幕和图形处理器的情况下就能使用它们，因为内核会代表你与它们交涉。系统调用是程序用来与内核对话的函数。</p></blockquote><h3 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h3><p>进程是存储器中运行的程序。操作系统用一个数字来标识进程，它叫进程标识符（process identifier，简称PID）</p><p>exec()函数通过运行其他程序来替换当前进程。你可以告诉exec()函数要使用哪些命令行参数和环境变量。新程序启动后PID和老程序一样。</p><p>exec()函数在unistd.h中，它版本众多，但可以分为列表函数和数组函数。</p><h4 id="列表函数"><a href="#列表函数" class="headerlink" title="列表函数"></a>列表函数</h4><p>execl()、execlp()、execle()</p><p>列表函数以参数列表的形式接收命令行参数：</p><ol><li><p>程序</p><p>告诉exec()函数将运行什么程序。对execl()或execle()来说，它是程序的完整路径名；对execlp()来讲就是命令的名字，execlp()会根据它去查找程序</p></li><li><p>命令行参数</p><p>需要依次列出想使用的命令行参数。别忘了，第一个命令行参数必须是程序名，也就是说列表版exec()的前两个参数是相同字符串</p><blockquote><p><strong>命令行参数之间的空格会把MinGW弄糊涂</strong></p><p>如果把“I like”和“turles”这两个参数传给exec()，MinGW程序可能会发送三个参数：“I”、“like”和“turtle”。</p></blockquote></li><li><p>NULL</p><p>需要在最后一个命令行参数后加上NULL，告诉函数没有其他参数了</p></li><li><p>环境变量（如果有的话）</p><p>如果调用了以 …e() 结尾的 exec() 函数，还可以传递环境变量数组，像”POWER&#x3D;4”,”PORT&#x3D;OPEN”……那样的字符数组</p></li></ol><pre><code class="c">execl(&quot;/home/flynn/clu&quot;, &quot;/home/flynn/clu&quot;, &quot;paranoids&quot;, &quot;contract&quot;, NULL)//execL = 参数列表(List)execlp(&quot;clu&quot;, &quot;clu&quot;, &quot;paranoids&quot;, &quot;contract&quot;, NULL)//execLP = 参数列表（List） + 在PATH中查找程序execle(&quot;/home/flynn/clu&quot;, &quot;/home/flynn/clu&quot;, &quot;paranoids&quot;, &quot;contract&quot;, NULL, env_vars)//execLE = 参数列表（List） + 环境变量（Environment）</code></pre><h4 id="数组函数"><a href="#数组函数" class="headerlink" title="数组函数"></a>数组函数</h4><p>execv()、execvp()、execve()</p><p>如果已经把命令行参数保存在了数组中，就会发现这两个版本用起来更容易</p><pre><code class="c">execv(&quot;/home/flynn/clu&quot;, my_args);//execV=参数数组或参数向量（Vector）execvp(&quot;clu&quot;, my_args);//execVP = 参数数组/向量（Vector） + 在PATH中查找//参数需要保存在字符串数组my_args中//以上两函数唯一区别是execvp会用PATH变量查找程序</code></pre><table><thead><tr><th>使用</th><th>字符</th></tr></thead><tbody><tr><td>参数列表</td><td>l</td></tr><tr><td>参数数组&#x2F;向量</td><td>v</td></tr><tr><td>根据PATH查找</td><td>p</td></tr><tr><td>环境变量</td><td>e</td></tr></tbody></table><p>l、v总是在p、e之前出现；p、e是可选的</p><h3 id="环境变量（具体做法见练习文件）"><a href="#环境变量（具体做法见练习文件）" class="headerlink" title="环境变量（具体做法见练习文件）"></a>环境变量（具体做法见练习文件）</h3><p>每个进程都有一组环境变量。你可以在命令行中输入set或env查看它们的值，它们一般会告诉进程一些有用的信息，比如用户主目录的位置，或去哪里找命令。C程序可以用getenv()系统调用读取环境变量</p><p>可以用字符串指针数组的形式创建一组环境变量。环境变量的格式是“变量名&#x3D;值”。数组最后一项必须是NULL</p><pre><code class="c">char *my_env[] = &#123;&quot;JUICE=peach and apple&quot;, NULL&#125;;execle(&quot;diner_info&quot;, &quot;diner_info&quot;, &quot;4&quot;, NULL, my_env);</code></pre><blockquote><p><strong>在Cygwin中传递环境变量时一定要包含PATH变量</strong></p><p>在Cygwin中，加载程序时需要用PATH变量，因此在Cygwin上传递环境变量时一定要包含PATH&#x3D;&#x2F;usr&#x2F;bin</p></blockquote><h3 id="系统调用错误"><a href="#系统调用错误" class="headerlink" title="系统调用错误"></a>系统调用错误</h3><p>如果在调用程序时发生错误，当前进程会继续运行，于是可以向用户报告错误信息</p><pre><code class="c">execle(&quot;diner_info&quot;, &quot;diner_info&quot;, &quot;4&quot;, NULL, my_env);puts(&quot;哥们，diner_info程序肯定发生了什么问题&quot;);</code></pre><p>所有的系统调用都遵循“失败黄金法则”</p><ol><li>尽可能收拾残局</li><li>把errno变量设为错误码</li><li>返回-1</li></ol><p>errno变量是定义在errno.h中的全局变量，还一并定义了许多标准错误码</p><table><thead><tr><th>标准错误码</th><th>错误消息</th></tr></thead><tbody><tr><td>EPERM&#x3D;1</td><td>不允许操作</td></tr><tr><td>ENOENT&#x3D;2</td><td>没有该文件或目录</td></tr><tr><td>ESRCH&#x3D;3</td><td>没有该进程</td></tr></tbody></table><p>可以拿errno和这些值比较，也可以用string.h中的<code>strerror()</code>的函数查询标准错误消息</p><pre><code class="c">puts(strerror(errno));//strerror()将错误码转换为一条消息</code></pre><h3 id="用fork-克隆进程"><a href="#用fork-克隆进程" class="headerlink" title="用fork()克隆进程"></a>用fork()克隆进程</h3><p>exec() 是程序中最后一行代码</p><p>fork()会克隆当前进程。新建副本将从同一行开始运行相同程序，变量和变量中的值完全一样，只有进程标识符（PID）和原进程不同。原进程叫父进程，而新建副本叫子进程</p><blockquote><p>注意！与Unix和Mac不同，**Windows天生不支持fork()**，如果想在Windows中使用fork()，必须先要安装Cygwin</p><p>Windows有一个<code>Create-Process()</code>函数。它是一个加强版的system()</p><p>此处<a href="https://learn.microsoft.com/en-us/windows/win32/procthread/creating-processes">官方文档</a></p></blockquote><p>用fork()+exec()运行子进程，在子进程中调用exec()函数，这样原来的父进程就能继续运行了</p><p>复制进程后，为区分父子进程，fork()函数向子进程返回0，向父进程返回非零值</p><blockquote><p><strong>fork()</strong></p><p>你可以像这样调用fork()：<code>pid_t pid = fork();</code><br>fork()会返回一个整型值：为子进程返回0，为父进程返回一个正数。父进程将接收到子进程的进程标识符<br>什么是pid_t？不同操作系统用不同的整数类型保存进程ID，有的用short，有的用int，操作系统使用哪种类型，pid_t就设为哪个</p></blockquote><ul><li><p>这样的设计中一般现在要考虑可能出现错误了，可以这样写</p></li><li><p>&#96;&#96;&#96;c<br>pid_t pid &#x3D; fork();<br>if (pid &#x3D;&#x3D; -1) {<br>fprintf(stderr, “Can’t fork process: %s\n”, strerror(errno));<br>return 1;<br>}<br>if (!pid) {<br>  …<br>}</p></li></ul><blockquote><p>在用exec()替换子进程前可以不用等fork()复制完整个进程，操作系统会采用写时复制（copy-on-write）技术等技巧。比如操作系统不会真的复制父进程的数据，而是让父子进程共享数据。如果操作系统发现子进程要修改存储器，就会为它复制一份</p></blockquote><h2 id="10-进程间通信"><a href="#10-进程间通信" class="headerlink" title="10 进程间通信"></a>10 进程间通信</h2><p>在命令行中，重定向是非常有用的命令，也可以让进程重定向自己</p><h3 id="进程内部"><a href="#进程内部" class="headerlink" title="进程内部"></a>进程内部</h3><p>进程含有它正在运行的程序，还有栈和堆数据空间。进程还需要记录数据流的连向，它用文件描述符表示数据流，所谓的描述符其实就是一个数字。进程会把文件描述符和对应的数据流保存在描述符表中（下表仅为示意）描述符表的一列是文件描述符号，另一列是它们对应的数据流</p><table><thead><tr><th>#</th><th>数据流</th></tr></thead><tbody><tr><td>0</td><td>键盘</td></tr><tr><td>1</td><td>屏幕</td></tr><tr><td>2</td><td>屏幕</td></tr><tr><td>3</td><td>数据库连接</td></tr></tbody></table><p>描述符表的前三项万年不变：0号标准输入，1号标准输出，2号标准错误。其他项要么为空，要么连接进程打开的数据流。比如程序在打开文件进行读写时，就会占用其中一项</p><p>创建进程以后，标准输入连到键盘，标准输出和标准错误连到屏幕。它们会保持这样的连接，直到有人把它们重定向到了其他地方</p><ul><li>文件描述符描述的不一定是文件</li></ul><p>在 类Unix操作系统中，可以用以下命令把标准错误和标准输出重定向到一个地方：</p><p><code>./myprog 2&gt;&amp;1</code></p><p>“2&gt;”表示“重定向标准错误”;“&amp;1”表示“到标准输出”</p><h3 id="fileno-返回描述符号"><a href="#fileno-返回描述符号" class="headerlink" title="fileno()返回描述符号"></a>fileno()返回描述符号</h3><p>每打开一个文件，操作系统都会在描述符表中新注册一项</p><pre><code class="c">FILE *my_file = fopen(&quot;guitar.mp3&quot;, &quot;r&quot;);</code></pre><p>操作系统会打开<em>guitar.mp3</em>文件，然后返回一个指向它的指针，操作系统还会遍历描述符表寻找空项，把新文件注册在其中</p><p>调用fileno()函数可以根据文件指针知道它是几号描述符</p><pre><code class="c">int descriptor = fileno(my_file);</code></pre><blockquote><p>在失败时不返回-1的函数很少，fileno()就是其中之一。只要你把打开文件的指针传给fileno()，它就一定会返回描述符编号😴？？</p></blockquote><h3 id="dup2-复制数据流"><a href="#dup2-复制数据流" class="headerlink" title="dup2()复制数据流"></a>dup2()复制数据流</h3><p>可以用dup2()函数修改某个已经注册过的数据流，dup2()可以复制数据流</p><pre><code class="c">dup2(4, 3);//同时将4号数据流连接到3号描述符</code></pre><h3 id="exit"><a href="#exit" class="headerlink" title="exit()"></a>exit()</h3><p>exit()系统调用是结束程序的最快方式，为了使用exit系统调用，必须包含stdlib.h头文件</p><pre><code class="c">#include &lt;stdlib.h&gt;void error(char *msg)&#123;    fprintf(stderr, &quot;%s: %s\n&quot;, msg, strerror(errno));    exit(1);//exit(1)会立刻终止程序，并把退出状态置1&#125;</code></pre><p>每次程序执行只有一次调用exit()的机会</p><h3 id="等待子进程"><a href="#等待子进程" class="headerlink" title="等待子进程"></a>等待子进程</h3><p>子进程一创建就和父进程没关系了，有时候子进程还未完成任务，父进程就已经结束了，操作系统必须提供一种方式，让你等待子进程完成任务</p><h4 id="waitpid-函数"><a href="#waitpid-函数" class="headerlink" title="waitpid()函数"></a>waitpid()函数</h4><p>waitpid()函数会等子进程结束以后才返回，也就是说可以在父进程中加几行代码，让它等到子进程运行结束以后才退出</p><p>需要包含sys&#x2F;wait.h的头文件(Windows平台似乎并不支持)</p><pre><code class="c">#include &lt;sys/wait.h&gt;</code></pre><p>接收三个参数</p><pre><code class="c">waitpid(pid,pid_status, options )</code></pre><ol><li><p>pid</p><p>父进程在克隆子进程时会得到子进程的ID</p></li><li><p>pid_status</p><p>pid_status用来保存进程的退出信息。因为waitpid()需要修改pid_status，因此它必须是个指针</p></li><li><p>options</p><p>waitpid()有一些选项，详情可以输入man waitpid查看。如果把选项设为0，函数将等待进程结束</p></li></ol><p><strong>pid_status</strong>?</p><p>waitpid()函数结束等待时会在pid_status中保存一个值，它告诉你进程的完成情况</p><p>为了得到子进程的退出状态，可以把pid_status的值传给WEXITSTATUS()宏</p><pre><code class="c">if (WEXITSTATUS(pid_status))    puts(&quot;Error status non-zero&quot;);</code></pre><p>pid_status中保存了好几条信息，只有前8位表示进程的退出状态，所以需要用宏来查看</p><p>重定向输入、输出，然后让进程相互等待，这就是进程间通信</p><p>进程之间通过共享数据和互相可以等待实现更多功能</p><h3 id="管道连接进程"><a href="#管道连接进程" class="headerlink" title="管道连接进程"></a>管道连接进程</h3><p>可以在命令行用管道把一个进程的输出连接到另一个进程的输入</p><pre><code class="bash">python rssgossip.py -u &#39;pajama death&#39; | grep &#39;http&#39;    http://www.rock-news.com/exclusive/24.html    http://www.rolling-stone.com/pdalbum.html</code></pre><p>grep找出了包含http的那些行</p><p>管道两侧的命令是父子关系，如上例中grep命令是rssgossip.py脚本的父进程</p><ol><li>命令行创建了父进程</li><li>父进程在子进程中克隆出了rssgossip.py脚本</li><li>父进程用管道把子进程的输出连接到自己的输入</li><li>父进程运行了grep命令</li></ol><h3 id="pipe-打开两条数据流"><a href="#pipe-打开两条数据流" class="headerlink" title="pipe()打开两条数据流"></a>pipe()打开两条数据流</h3><p>用pipe()函数建立管道</p><p>每当打开数据流时，它都会加入描述符表。pipe()函数也是如此，它创建两条相连的数据流，并把它们加到表中，然后只要往其中一条数据流中写数据，就可以从另一条数据流中读取</p><p>pipe()在描述符中创建这两项时，会把它们的文件描述符保存在一个包含两个元素的数组中</p><pre><code class="c">int fd[2];if (pipe(fd) == -1) &#123;    error(&quot;Can&#39;t create the pipe&quot;);&#125;</code></pre><p>pipe()函数创建了管道，并返回了两个描述符： fd[1]用来向管道写数据，fd[0]用来从管道读数据</p><p>在子进程中，关闭管道的fd[0]端，修改子进程的标准输出，让它指向描述符fd[1]对应的数据流；在父进程中需要关闭管道的fd[1]端，重定向父进程的标准输入，让它从描述符fd[0]对应的数据流中读取数据</p><pre><code class="c">// 子进程close(fd[0]);dup2(fd[1], 1);//父进程dup2(fd[0], 0);close(fd[1]);</code></pre><p>不同操作系统打开网页？较为简单粗暴的system()写法</p><pre><code class="c">void open_url(char *url)&#123;    char launch[255];    sprintf(launch, &quot;cmd /c start %s&quot;, url);//Windows    system(launch);    sprintf(launch, &quot;x-www-browser &#39;%s&#39; &amp;&quot;, url);//Linux    system(launch);    sprintf(launch, &quot;open &#39;%s&#39;&quot;, url);     //Mac    system(launch);&#125;</code></pre><blockquote><p>在类Unix机器或任何使用Cygwin的Windows机器中可以获取以下程序</p><p><strong>curl&#x2F;wget</strong><br>可以用这两个程序与网络服务器通信，也可以在C代码中使用它们与网络通信<br><strong>mail&#x2F;mutt</strong><br>可以在命令行用这两个程序发送邮件。如果在机器上装了它们，C程序就能发送邮件<br><strong>convert</strong><br>convert命令可以转换图片格式。你可以写一个C程序，它输出文本格式的SVG图表，然后用convert命令把SVG转化成PNG图片</p></blockquote><p><strong>关于管道的Q&amp;A</strong></p><p>管道可能是文件。可以创建基于文件的管道，它们通常叫有名管道或FIFO(First In First Out，先进先出)文件。因为基于文件的管道有名字，所以两个进程只要知道管道的名字也能用它来通信，即使它们非父子进程。使用<a href="http://tinyurl.com/cdf6ve5">mkfifo()系统调用</a>有名管道</p><p>如果不用文件来实现管道, 那么通常用存储器。数据写到存储器中的某个位置，然后再从另一<br>个位置读取</p><p>如果试图读取一个空的管道，程序会等管道中出现东西</p><p>子进程结束时，管道会关闭。fgets()将收到EOF（End Of File，文件结束符），于是fgets()函数返回0，循环就结束了</p><p>管道只能单向通信。不过可以创建两个管道，一个从父进程连到子进程，另一个从子进程连到父进程</p><h3 id="杀死进程😎Ctrl-C"><a href="#杀死进程😎Ctrl-C" class="headerlink" title="杀死进程😎Ctrl-C"></a>杀死进程😎Ctrl-C</h3><p>操作系统会从键盘读取数据，但当它看到用户按了Ctrl-C，就会向程序发送中断信号，进程运行默认中断处理器，调用了exit()</p><p>信号是一条短消息，即一个整型值。当信号到来时，进程必须停止手中一切工作去处理信号。进程会查看信号映射表，表中每个信号都对应一个信号处理器函数。中断信号的默认信号处理器会调用exit()函数</p><p>既然有这么一张信号映射表，那么就可以修改进程收到信号时运行的函数</p><h3 id="sigaction是一个函数包装器"><a href="#sigaction是一个函数包装器" class="headerlink" title="sigaction是一个函数包装器"></a>sigaction是一个函数包装器</h3><p><strong>以下均需要包含signal.h文件</strong></p><p>sigaction是一个结构体，它有一个函数指针。sigaction告诉操作系统进程收到某个信号时应该调用哪个函数。</p><p>创建方法：</p><pre><code class="c">struct sigaction action;action.sa_handler = diediedie;//指定计算机调用哪个函数，这个被sigaction包装起来的函数就叫处理器sigemptyset(&amp;action.sa_mask);  //用掩码来过滤sigaction要处理的信号，通常会用一个空的掩码action.sa_flags = 0;//一些附加标志位，将它们置0就行了</code></pre><p>处理器必须接收信号参数，为整型</p><pre><code class="c">void diediedie(int sig)&#123;    puts (&quot;Goodbye cruel world....\n&quot;);    exit(1);&#125;</code></pre><p>处理器的代码应该短而快，刚好能处理接收到的信号就好</p><blockquote><p>在处理器函数中使用标准输出和标准错误时要小心</p><p>之所以会有信号就是因为程序中发生了故障，而故障可能就是这些无法使用</p></blockquote><h3 id="用sigaction-来注册sigaction"><a href="#用sigaction-来注册sigaction" class="headerlink" title="用sigaction()来注册sigaction"></a>用sigaction()来注册sigaction</h3><p>创建sigaction以后，需要用sigaction()函数来让操作系统知道它的存在</p><pre><code class="c">sigaction(signal_no, &amp;new_action, &amp;old_action);</code></pre><p>接收三个参数：</p><ol><li><p>信号编号</p><p>这个整型值代表了你希望处理的信号。通常会传递SIGINT或SIGQUIT这样的标准信号</p></li><li><p>新动作</p><p>你想注册的新sigaction的地址</p></li><li><p>旧动作</p><p>如果你想保存被替换的信号处理器，可以再传一个sigaction指针；如果不想保存，可以设置为NULL</p></li></ol><p>如果sigaction()函数失败，会返回－1，并设置errno变量</p><p>以下函数简化了注册过程</p><pre><code class="c">int catch_signal(int sig, void (*handler)(int))&#123;    struct sigaction action;    action.sa_handler = handler;    sigemptyset(&amp;action.sa_mask);    action.sa_flags = 0;    return sigaction (sig, &amp;action, NULL);&#125;catch_signal(SIGINT, diediedie);</code></pre><h3 id="操作系统的信号（部分）"><a href="#操作系统的信号（部分）" class="headerlink" title="操作系统的信号（部分）"></a>操作系统的信号（部分）</h3><table><thead><tr><th>信号</th><th align="left">引起原因</th></tr></thead><tbody><tr><td>SIGINT</td><td align="left">进程被中断</td></tr><tr><td>SIGQUIT</td><td align="left">有人要求停止进程，并把存储器中的内容保存到核心转储文件</td></tr><tr><td>SIGFPE</td><td align="left">浮点错误</td></tr><tr><td>SIGTRAP</td><td align="left">调试人员询问进程执行到了哪里</td></tr><tr><td>SIGSEGV</td><td align="left">进程企图访问非法存储器地址</td></tr><tr><td>SIGWINCH</td><td align="left">终端窗口的大小发生改变</td></tr><tr><td>SIGTERM</td><td align="left">有人要求内核终止进程</td></tr><tr><td>SIGPIPE</td><td align="left">进程在向一个没有人读的管道写数据</td></tr></tbody></table><h3 id="使用kill发送信号"><a href="#使用kill发送信号" class="headerlink" title="使用kill发送信号"></a>使用kill发送信号</h3><p>在类Unix操作系统中有一个叫kill的命令（在Windows上用Cygwin）</p><p>叫kill是因为这个命令通常用来“杀死”进程。事实上，kill只是向进程发送了一个信号，kill默认会向进程发送SIGTERM信号</p><p>kill －KILL一定能杀死进程</p><h3 id="raise-给自己发送信号"><a href="#raise-给自己发送信号" class="headerlink" title="raise()给自己发送信号"></a>raise()给自己发送信号</h3><pre><code class="c">raise(SIGTERM);</code></pre><p>通常会在自定义的信号处理函数中使用raise()，这样程序就能在接收到低级别的信号时引发更高级别的信号。这就是信号升级</p><h3 id="SIGALRM"><a href="#SIGALRM" class="headerlink" title="SIGALRM"></a>SIGALRM</h3><p>当计算机中发生了进程需要知道的事情时，操作系统就会向进程发送信号，除了在发生错误时使用，有时进程也需要产生自己的信号</p><pre><code class="c">alarm(120);//把闹钟调到120秒以后闹铃do_important_busy_work();do_more_busy_work();//其间代码就会做其他事</code></pre><p>进程在收到闹钟信号以后默认会结束进程，但通常情况下使用定时器不是为了让它帮你“杀死”程序，而是为了利用闹钟信号的处理器去做另一件事</p><pre><code class="c">catch_signal(SIGALRM, pour_coffee);alarm(120);</code></pre><p>闹钟信号可以实现多任务。如果需要每隔几秒运行一个任务，或者想限制花费在某个任务上的时间，就可以用闹钟信号让程序打断自己</p><p>一个进程只有一个定时器。定时器由操作系统的内核管理，如果一个进程有很多定时器，内核就会变得很慢，因此操作系统需要限制进程能使用的定时器个数</p><p>每次调用alarm()函数都会重置定时器</p><blockquote><p><strong>不要同时使用alarm()和sleep()</strong></p><p>sleep()函数会让程序沉睡一段时间。和alarm()函数一样，它也使用了间隔计时器，因此同时使用这两个函数会发生冲突</p></blockquote><blockquote><p>setitimer()函数可以把进程间隔计时器的单位设为几分之一秒</p></blockquote><h3 id="重置信号和忽略信号"><a href="#重置信号和忽略信号" class="headerlink" title="重置信号和忽略信号"></a>重置信号和忽略信号</h3><p>如果想还原默认的信号处理器，signal.h头文件中有一个特殊的符号SIG_DFL，它代表以默认方式处理信号</p><pre><code class="c">catch_signal(SIGTERM, SIG_DFL);</code></pre><p>同时，还可以用SIG_IGN符号让进程忽略某个信号</p><pre><code class="c">catch_signal(SIGINT, SIG_IGN);</code></pre><p>在决定忽略某个信号前一定要慎重考虑，信号是控制进程和终止进程的重要方式，如果忽略了它们，程序就很难停下来</p><h2 id="11-网络与套接字"><a href="#11-网络与套接字" class="headerlink" title="11 网络与套接字"></a>11 网络与套接字</h2><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><p>互联网中大部分的底层网络代码都是用C语言写的。网络程序通常由两部分程序组成：服务器和客户端</p><p>可以使用一个叫telnet的客户端程序连接服务器。telnet接收两个参数：一个是服务器地址，另一个是服务器运行的端口</p><blockquote><p>需要用telnet程序连接服务器。很多系统自带了telnet，可以用以下命令检查计算<br>机上有没有telnet：<code>telnet</code><br>如果你的计算机上没有telnet，可以用以下方式安装：<br>Cygwin:<br>打开Cygwin的安装程序（setup.exe），搜索telnet。<br>Linux:<br>在包管理器中搜索telnet，很多操作系统的包管理器叫新立得（synaptic）。<br>Mac:<br>如果没有telnet，可以从<a href="http://www.macports.org或www.finkproject.org安装./">www.macports.org或www.finkproject.org安装。</a></p></blockquote><p>服务器将同时与多个客户端通信。客户端与服务器之间将展开一段结构化对话，叫做协议。互联网使用了各种协议，一部分是低层协议，另一部分是高层协议。低层协议有IP（Internet Protocol，网际协议），它用来控制二进制的0和1在互联网中的发送方式；高层协议有HTTP（Hypertext Transfer Protocol，超文本传输协议），它用来控制浏览器和网络服务器的对话</p><p>协议通常有一套严格的规则。客户端和服务器都遵守这些规则就没事，但只要它们中有一方违反了规则，对话就会戛然而止</p><h3 id="BLAB"><a href="#BLAB" class="headerlink" title="BLAB"></a>BLAB</h3><p>如果想要写一个与网络通信的程序，就需要一种新数据流——套接字</p><pre><code class="c">#include &lt;sys/socket.h&gt;//需要包含这个头文件...int listener_d = socket(PF_INET, SOCK_STREAM, 0);//listener_d是套接字描述符，0是协议号if (listener_d == -1)    error(&quot;无法打开套接字&quot;);</code></pre><p>在使用套接字与客户端程序通信前，服务器需要历经四个阶段：绑定（Bind）、监听（Listen）、接受（Accept）和开始（Begin），首字母缩写为BLAB</p><ol><li><p>绑定端口</p><p>计算机可能同时运行多个服务器程序，每项服务必须使用不同的端口（port）。端口就好比电视频道，我们在不同端口使用不同的网络服务，就像我们通过不同频道收看不同的电视节目</p><p>服务器在启动时，需要告诉操作系统将要使用哪个端口，这个过程叫端口绑定。为了绑定它，你需要两样东西：套接字描述符和套接字名</p><pre><code class="C">#include &lt;arpa/inet.h&gt;...struct sockaddr_in name;name.sin_family = PF_INET;name.sin_port = (in_port_t)htons(30000);name.sin_addr.s_addr = htonl(INADDR_ANY);int c = bind (listener_d, (struct sockaddr *) &amp;name, sizeof(name));if (c == -1)    error(&quot;无法绑定端口&quot;);</code></pre></li><li><p>监听</p><p>可以用listen()系统调用告诉操作系统队列有多长</p><p>调用listen()把队列长度设为10，也就是说最多可以有10个客户端同时尝试连接服务器，它们不会立即得到响应，但可以排队等待，而第11个客户端会被告知服务器太忙</p><pre><code class="c">if(listen(listener_d, 10) == -1)    error(&quot;无法监听&quot;);</code></pre></li><li><p>接受连接</p><p>accept()系统调用会一直等待，直到有客户端连接服务器时，它会返回第二个套接字描述符，然后就可以用它通信了</p><pre><code class="c">struct sockaddr_storage client_addr;unsigned int address_size = sizeof(client_addr);int connect_d = accept(listener_d, (struct sockaddr *)&amp;client_addr, &amp;address_size);if (connect_d == -1)    error(&quot;无法打开副套接字&quot;);</code></pre><p>服务器将用新的连接描述符connect_d进行通信</p></li></ol><h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h3><p>套接字是双向的，它既可以用作输入也可以用作输出，也就是说要用其他函数和它通信</p><p>如果想向套接字输出数据，就要用send()函数，而不是fprintf()</p><pre><code class="c">char *msg = &quot;Internet Knock-Knock Protocol Server\r\nVersion 1.0\r\nKnock! Knock!\r\n&gt; &quot;;if (send(connect_d, msg, strlen(msg), 0) == -1)    error(&quot;send&quot;);</code></pre><blockquote><p><strong>如何选择端口号</strong></p><p>为服务器程序选择端口号时千万要小心。现如今有各式各样的服务器，所以不要选其他程序用过的端口号。在Cygwin和大多数Unix中有一个&#x2F;etc&#x2F;services文件，它列出了很多常用服务使用的端口号。在选择端口时必须确保没有其他程序用过</p><p>端口号从0开始一直到65535，首先你需要决定用小号码（1024以下）还是大号码。很多计算机中，只有超级用户或管理员才有资格使用1024号以下的端口，因为小号的端口留给了一些知名服务，如网页服务器和邮件服务器。操作系统只允许管理员使用这些端口，防止普通用户启动一些多余的服务</p><p>通常情况下，请使用1024号以上的端口</p></blockquote><h2 id="12-线程"><a href="#12-线程" class="headerlink" title="12 线程"></a>12 线程</h2><h2 id="十大遗漏知识点"><a href="#十大遗漏知识点" class="headerlink" title="十大遗漏知识点"></a>十大遗漏知识点</h2><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul><li><p>递增与递减</p><p>++和–的位置决定了表达式返回i的原始值还是新值，前新后旧</p></li><li><p>三目运算符</p><pre><code class="c">if (x == 1)    return 2;else    return 3;return (x == 1) ? 2 : 3;//这里上下等价</code></pre></li><li><p>位运算</p><p>C语言可以用来编写底层代码，为此它提供了一组位运算符：</p><table><thead><tr><th align="center">运算符</th><th>说明</th></tr></thead><tbody><tr><td align="center">~a</td><td>a中所有位都取反</td></tr><tr><td align="center">a &amp; b</td><td>a中的位“与”b中的位</td></tr><tr><td align="center">a | b</td><td>a中的位“或”b中的位</td></tr><tr><td align="center">a ^ b</td><td>a中的位“异或”b中的位</td></tr><tr><td align="center">&lt;&lt;</td><td>位左移（值增加）</td></tr><tr><td align="center">&gt;&gt;</td><td>位右移（值减小）</td></tr></tbody></table><p>&lt;&lt;运算符可以用来快速地将某个整型值乘以2的幂，但小心千万别溢出</p></li><li><p>用逗号分割表达式<br>for循环在每次循环的末尾都会出现递增操作。<br>但如果你想在循环末尾执行多个运算怎么办？可以使用逗号运算符：<br><code>for (i = 0; i &lt; 10; i++, j++)</code> 递增i和j。<br>之所以要有逗号运算符是因为有时你不想用分号来分割表达式</p></li></ul><h3 id="预处理指令"><a href="#预处理指令" class="headerlink" title="预处理指令"></a>预处理指令</h3>]]></content>
      
      
      
        <tags>
            
            <tag> C notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一封新年的信</title>
      <link href="/2023/01/LetterToYYY/"/>
      <url>/2023/01/LetterToYYY/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Sorry, you aren't her." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="34d310f3dea690e604a6b9079b2dc27dff2567dff8dd41f08c1810ce183acdbf">cb1516b36de741a2b3bbe43b3982941151bd781dfac26e1ae42cb0a497475ef30d0317d3bb0df941088886f08b53b9739d45ce49a4458d97508c1032876a0744d017d3e202ff507c726851df781b127b6dcdc75097a5df6a00936e9b60e2f843d6f6440d2f0b84958da61c485b3a64cf6a309f1a100cdb646d609ae902dd1634a7d0a4ecdd175af4f6f253cb8d3160595a8d3f1e74d3d93ec665bb616353a4d63054fd4b8405c4014afb27c3f01973898dcc1652b2e6fe5e9501ba91ae049737c657ddbb7864e077041bf1dd2e154861eb12abf57f8c34206794bc10ea0ae18c395ed05f89efa74c9788fede833c5923ca7a2c07536d61a6ab7b34da59eb6fea2e34cee4339968a33c1e6ab79a9163f9c7d02e456b3a0d721e4dca2ba8d1fe678c68b66d66b673f0788ab10d15891788f6bc860167153785b527db0fbdf9161b5c54ec06f006fc53fb5b6e8fbae5e384398aca79abd2d6c203f7ce0e2a761cb07fd93c8cd60de42e010cc27aec3a6ad4458af084438a9ff86f3bf887190ff21a63232e494561a72db409e9b20f1e38ffba5a38f5c914cafa20d3a009fcb623eb2d468f1e14318a033acc572aadb003006b0b13b9073c97a1751428b309b0237e5d682d548ba16219ece4cb8a35a79d42a376037769aa2baba78bb5cd607ec9af42cbe32d03963df5682977c9ed70739d59de182dbfd3dc50ae7d5493500e7f8aaa9ebfa629d0e34878e9ddb6a572eb7aebcffda9e1419f2c55fd334f8c66e644e3c431cea4999ebdde4c2f68071f9467e0531fd99104e22cc09f5059c90ca095050f4a679a45dc411b9eb298c3486fe7b9e095c0a5f9d5b202c3718471f40869901d75a69652f88b3dcf244d3cec928df686b7e569c0630224d2f2126d1d29ce3d706fdb4d8a8bd671d496fbc47b1030c3d8aed93a1bcb3ee4aab5b292320e6103c03989876a29194b9fb5e075872aa7b961043d3f0d2505f30ab5e0e515d2b79961340d31cf393ecbc93f315c0448a17b43f82402e6fcdc986307dcdd1b8f463fbca355a8dc0781b5a7db0fe107f8422ea461ada853167697e54824d8b0f7ed502cf1adfba1c86c26f8ffef3bc5f272df19faad434c087126822c85f6be9079e8bc3f983643edf24a60048b7006f0fd69151a8f10398494aed5408fd7f8ace568e76b8c2472d8a79b07e4f3a3bdb1493d303c030695fcd833bdc352fe93ec450f72e90c9268ea47b561ee9a73b54c5e4faa509bb97021128fc3100ebbc711d6f4ae8e6662772739b9edb5dc5f595111f0202fa134bfa26427dc4337b7f2033751094aadc0302e1e1542e0e86abb01213c1ab05b366f6d278ceb88159181193ec139da28defb639f4133632dd3b0413e30d3c04992c70e7f0e99fe4a815b52342cde15f22e857fddc1a77fbb9b436244b198632d759c3308e6c0e181681f9a99600094bed490bfd70412fb17d77664e6eb5343377822d0819ef3e8d364d21e63808e9ec30daad571707b795727eae50f079b238086cf4cdbbdc49a841b41f55592d5e6b22b27b2f36dd770a77d786687a260ac50b3552b9d155d2e7772f46c44a16d38b2ed5418193221a42962acef4302359a966cfda35d001b3a4fb39164cc484776fabefe2899e3108570d7de237c3aa2ba33c0032a3c9ed932fcb12cc22a783b7e25b85d318f5be8134e60a4fb181c89c5c65fa537dd6093d93dcf96ce29004b470b03f01bcb317ade72b599c0a6147175aec970f95e39f7a68bf44c4a14fc719a7e7342d83c147c53ccaf212a86b90f485683b5a3869b45f4678b434914e1cb0475b3f47d63a92f960507c42e52d3966ac15e81e9461f8bf03b262be7848c295ff6929c725465c6928a89018c72f8d4a50945e2850cfe37d252314a185222e62ddc70f5b823012a3d7490950117f37223ffe06ce38ceb7a32d435d49942048fb9dc8616dce7af416d1c6d03f895bd4732f91f19d0bfe1c7d389bd44621a65c6ca9aeabb57547e7d719030ed68b60401fb07e2be257b9292c3b59b4a4187ec0ec495a06426997965eed01e2dc2bf7a16287df48f1f87de7ddb4585c02f12dbd6c332dc345d543a2469e595eaab2fd46b9b58551ec5b3a75a415ad884da46749a8a097bddbe75f5bdc95853b25cb0b407da2fcfc2e3821fad0873c10783e2794bd77f550ecef2010513d940087f49cc284933f003621de13601978ff3a0014a59826ae28a9617adef933bccd571f0ff4f1596e13e533c63640809fce96b67fed464088d37fe092e27809e6f4514dc6507ecb3b5e0e93243af7a1eb76af848f528ee54ccec264aa4b00a0da28cc7c8ec7264143dc97ba5bfe321efd1adb9e8bd9d87d342e3a4cdbf922c2dab3fadf6b0ef2439b18403862a7669e580430d40767651e7a1f3f095e0465ba027f99d9e5aed9f05f5532c770649fedaa42ccbb2fa7e6b3305fc6682d7099bb3f1239bcdc881625b679192e3703477a43d4dd15d5a55741150ffa44f43247dcc2ec2c1d3e5ac05c6941569fe7d7d6fbf1cbb37bd11c287cbb237e239943ba1d63b7fed94a15d07ebb26f373b1218078af2c208d3ee4ac2bdf699b54a3584f1fa9328f66c2ba0d42503f80b01c71b255955ef749ad8a599cbfed7b5495a697df1905ec7c72e2c31c851e5614d921e715b6508fbf5500a62a8a9496ea42c28ea646e9b503201478d889abfda39a956f3eaefd88dcad260d76b3474f43987fd0b333dc072db1492b453e999d77ad38f4c8245f8278b02aea81d853f690c92c5c843240958ca2d9adbf1467673bcd2f85c065b36c6f4927e5200bca291ac3f57621c9cc39c78a445f6df09dbdf11823e97c13f61a1589d66b349d254f73424da278d35b22da5b7bfb7556a6d505f9b360aabb8307b1a6e803f7ead149acec77c42b071ce50a1e57f5c67d6d127cacb0c99716b4c65fcfe99b56ee850f94214d22b108a1bf7c8a8ad01a0a1db731273c11301a973b0a1eb6010236fe289051458bc3669a689235279eda9411940cbe838ed40b1d5aed213f0f4c99d255661a52b5795b9a24d272b4aa9268ef9b6cc41a62ac6498515a8bb68717c7bbc1be17ef73f3b1be1cb4810fc21878410fef8ace37184aceb2c4d9e3212bedd7098fd46451967bbd3005045d09c9dc53240e3a63d6db3c1ad4967eb706beafac5089b654fe6c822718438662a602c91dcbb05f739987bd97c778ee46f53abaab81314e4b3db389cf7fd0bb86f3bd1023f865b12e91a990ee9d2655f730c463256fb1b929e3ff85c52e0c1672442053018df5ef1a552ae997ccd2abe748850069391a6c3683a6aadeb83e336217e6c3d0c4ad819e9eeaead16b2636852a8f5d7aabcef6e9b7dd5c9a037697c901eabfaebcb6b7ccec9293b012b8c6c92a6acfcbe9e69e13c032efa5da6ed130b34fb8405ab1b6a34d2eb99720a4fd15fc7a012c64abe3f70b825368a6ceb89a622d3b653b7bffa4c58d8bbf492d37ebc6516419b112c30f4693a138b7054f5ecaa7680007f0fb55ca5e9cb951210ab240422da5311dc110188123bb0079aabe85726e3e5dba96c0d3955133f83a6e38315584e5cea57df4f7c493c3f887f88f5edb714b620e2e6e7eebe39b3e247ce4bc51fb7015d3593d9815b9c4766e9a98852c126b26ccdc1adf955ad1b1b4a3ca54bfab5aaf17e650f655e83b1cf820c87674e95a632806d99ecc5202b10157411cb18e5a3f6e771b2b2ae176b6ea35311f3f17f0eba2d2e2702d5fb0775cc4d6a0fd28c44c364e6a0eb7a8fbf1ba20127a60f83c9540907ab42cd347517a0ed0249a03d3c9792f747c3db729e4a6405f279fe9d89d848bd15311cef09e6a4d889b265771a7cb0f70f90698a18760b71931f3d18a272f00228cc04ddcae844427fc417a8ae058cac9ab85491b019b286e900c99c031879f311cedb914a7d8b18bee972e246bda51487b919b19a152f9cfed03a904f144aac93847a6e1e10aaea5b3210892431180c0cae7ea362482a78d4d03ba676ee9d3a3bc9ee1bb596808f78b78384df5fa6cfe1b5b9bea2f2e033e0085dbb796a1ca18fcae7108823b73c50b5e4611031fc4cd373f56f1b1ced4efa8070acd053a762b409d19070724367aa4faf3816e677b4af0f818660d9a668bffb0b7314baff12f8d2a408d2d642c4007da4b9ef46b14211050065cbe5a37859c6459e59b659996d3ad2e51c58b6a1b727dc7892dd6b41dc4f32b09fefa2cdabdb2f0c1150d3faedc08fe4e1c447aae15c74c2cda234f32cc21f4243833089d531dd1d36670bc3a8023ba6a7ff9a5a096a1e5033e0061ab49e0c0a3c077960b9ce11f650847989cbdd10af1736ecd1fb080ae77af73201d6d09ed93fbcdb4a6751efd63c830c641650ded40c52f3412e7aefc45a6ea96c2b090aceb535fa3f14f2b2c4e9e11787e47a49480d498acd8494d7ff0dec8c96116b01f8dc59b6111e602f56451bb45def7c39ecc79b13418d4cf09da3123a02d7f8ed366347dfee1876a3f73d0875e8874d2bab31cad79109f58b8b4dda78c7972431da9d511d6e92dcab5a118cd5675d7b2e95fcd842f4c25530131f2200c6749c5ca7ff6c2fc40daff4802a521d112698396cd3ad33a1e117565703cf5b00af83c9957ca68a22bc551676acfa4d7f9f139c1d737efa3bf3908e9648ce2473a9992947bd6879a1046a9932b4dcfabd850e91bd82f707586b99ccf9f0d8f0d28462f4b72471063bea8520b312310ede60461e988268d7317bc1c4d7d90398ffaed91808c2350968b1bc789161eb2956295bffb057fb5f4b89abe161ced5240a20b005dde587212e9d18157860a2742f06bc153c1c393d2efbf1be753ed56a39db4be09281899ef50410e99b158f7bbe03b636fca9dd7713da4635a5a74a41946df00ec450449dd9e0102b696aa871ea67212334d6ef3c033b53005e29ead454873b87eda5de19d7b105cdf4ff2425e8dde28530a4a3cb499dc6805a5ac276ab3c4f7bb6ecff37572f4ac7d62d84a04ebbb97eade6e62a43249b3e664edbe8d77e11102280065bd046bfe2207f52524b231a4d64fc7cbd0c28b7f5a9c1b162d41a35785a1f1635129eec3a0810f7dfafd3d0c8f4e55e728d63ff1f7c4841b4bfc28a2ef8dc44d893aab10602c86138f7ad60f84555455a96cfe729610f63a5f4b00b49afbcd7e98b9b02624955c74c9381604318f16b14b25328510117a52be73a118362d5851d6aad5684ab3a64b1aea469db769cf936fc959099b4f048e72daf9816b5944a380efa248b36e9c5fe4d68f77476c70ca8a52c3584a2302554fc93a1baaacab5a92275249a135c1486b3f5a5a924eacfa8633328e75aaf63c5e7c4e874475e26b64b519962dbfc2fe4adbbe9301fd7e1dc7cd8724f6307b7475cb7c25dfd7e6ec59b395119eee643ff47f0ad14c4381a239f51081ae998f4eb4c0fd255e08ffd7048899bfe512700579c5576a4a5866e58f5f9c7f78883dd0a185297d7969a4de875095cc305e5296e66781473ded683ce9eca315df7c097c4e4ef31ef6a43c0320fcf52fab82cfd6d80426563e484ae546ccb6e677b25aa58f13019b649c8e0130af9669c5b271a0edadf49173d6a90f34fe68de01a0a76e6186d43958f9b1b494b70b7928762453edaa38b8ac8b98d26530a7cce331423018f8dc6b6ed3a82daaa5f8037a1c15f8ac566203979c7171ebfe4a7168f6c4fe0aac11b83b94e61fdd926e6c8a236aa31e079b0c7b6cf9db0768a1377716edf42f0b55b22418e705d38c87b328ce5fb7891f178a642b6b4850fca2c207780803e10ab0dca10af88f72fdc26aa9b1e15591d54c7b74308b7d038ebdc66bac77f1f4919b6dd84c330d577542192bed910bab1ae0d0fbdbad4f47c88436e441c9d163cc3e8541b9a3731f45b00885a6599109653a32cdb73354683a5ed9fd18da60d9cdef335cbaf3d1ebca282159e8412a6ccb066d701adb8e78dd0dca9602e1bc8285c339cd9fa025ad5779d5eae4c95f7738262a142445532d9cb0930ed55f75603bdd79ca13b058e55a69140175b00464db21d5532f770ff5cf2f98b8b7326d25fbfe0240d2e76fda3383f6503ecfd92ec456f29e010ee420c8d8ac4d0525ec66ae240b92538315bafc3722c5f4da4f1b4ec78227d1c953f84783f586877321b13aa97d6017205e857569c6a0ab84a8c79c45539290ca87e1fbdecc22596cc6cb9fa7795acdff296892e86ac8b8ae2db50d34eb8d3535930a89b0bb4853e979d62fdc985c4a07f19e13326772602a3e0b9c02cf7ace224a2b7000ae4bbccfafad028908a3d88e354791308ff5fab47a70946b5896ae37594a3963d0fe1aa7c5b0b71d4062de28f7f74dda51725c289df4038c3becefaf20256971ccf253f7d163cf61b1bd967f35c2822055547a53a10d61546b3e7b0b1288c8bde7da95160fc4810e71d3169895d0e1891473d00c1a409d3b89fb795b6ef668d71e51fd1530b35d16d8232bb9e41afc8066d51668d86d6005550fe0e4583b796bdaecdd52413c24c48bcbdb170467b20e4f938d5ce42643e0332ff004adeae8a48aae3c683050d30605a56a9bf52f04cbff7cffa4248aaf0e9a3031fefb13a81365b10f555fe60ae531694b1bb40ba37f75e33c38c04a960b18580e1ae73d0e23bfabc824e17ceaf642509e862c7eae1ad3e1004bd77fa84bdc72af4965ca72d1ecc9c5fbc2a69a7278da8c0ef57f3d5128deaa628d6fe76fa6c0910526a9b22075d55fa681c4d04bd879088f845c122af0e25fc305e243ef841bddf518bf0bb0e5e33be3a7ce6ba2e60a2fd42b907e177c4d301d91743301fb337db008279a396fd7a37e80a18f0835980e6981bd4982a8ef3c30760deda4c0f533a2245ad5bcf24a8add58a0362f042e875c68056038574029d362bf4fb79221ed48e23cb96231d21e7a90885e52edb7342d62056dc7fb3e91ead0bd233bac919f93291fa4c252a423d34004a034b3b81b64dd45c505df4aae841881d549eb5fdc8015ecd52479375807e9440df75498603d047f1958b6bccb2670cccfb0b3013606aa48bf40caebde7d5bc1f04e0db96cfbb4ea771d5732d77274c305152f246d774522854343077d9996003eba2df0c7149a7fab10e3273f327189bc86c3887813edaf7643be4ffa2be7717e8088d029c3247f6fcd99b230f4303b3bc58f2fb276c9fe193ba2ac8ac2e22c0330f57022f565ac122a04adaf894bf243f4a48c32d2bf183aad77a7eecc7a2e6e39ab42fedea51af20031e78949e414e91e0b0562e23cf9e66e13ae27745084920b9207ed3cb415f76c8a6c35501f78cfc8b9421c1ba3f00f811f1422cdf91cb91ca2dbe4696ba67519d3b7e1aa9ac004a3dd6a9e6ab354716434987b79fa02f85e225e7c27e8b36bd523b7725848e4ff1d7a0921b7525ad7cfa93c0fc7d15a6d7fe2d2f768c44ea16c8df9d6bcd64495cf4a84cd75b800bf3abc1de745efdd53d8abc402225685a99df348087612388bd2f0881c2d11d07c0e8e93ac150d1c87ab88740c1251d66a65e1513f3fe0620aace0346e96b2f9acdc62e9699cd702be08df9c780289e8119bd24c93f78960ad4a17789cd85ebb51206c0b0db5452f92a853e6e9f9f7cc89328eb42f93fd8cf527a1495ba2a0e767d0a7dc7d7a54dce9354dc61e64f19a85e0880a8291c0512a2d658b672071dcaada7fc8b2e23913a406969dc52e4a69ea48b8cd7460fef5e7efc004eb951fa9054f808db2dca00b84ae7fd6b3331ba410e330ad3ef1988ed4f36848e36813660a7144b20dddd6b0ef87fae3d535ab607cefac82992de617210fc1fc08c4db08205395eae6ac0c0572b19da3272404e3318cda8dd2b9d38043e341a5cf59083cca04f16c0ce9f330d473ff539f064f560d80304fd8789dbcd9ee7e7d3020066768d812f1d0eef12341dd2a404be711dc04d4b9f471445cad4444ee7fd09903c554bbe1e41f4d17b0751b8068261d5a061c441644a8018fc2a41efed28a4f45d08c056081b0dae59531800b7407941d4c21713dafec55426c8a8062e44ffa3d4af0925fa1c4d1e0f1d41ec5f62c00566e7d4f91f12550aa01d652cc6eff0acf2612384672f43ad09cf651f5ff14f91f0f130d7b5dc93c2e94a85068b6f8784b7fb9038bf07dfa687aa00bccc331fdf35096e506ae73646a021769888bb9409e3bade61e66811d9f6de42b886e53c1cb9fa98c0693c67dcfc071d81f9b3f10220efb1f34d4378aeb46783d11f3e91d2bf2d91cd8fd45ad3bf646aa21f16adf1504d6548a94cffd25aca29b5a76b598a9c56c02141ba904570004268310bb4e050d81e8418d95b32e8d6e52512aabd6ab4cdea68748b122808b11a061b9a3e6cf2c907201a109870efd5a4500baf1c1b455d7d9585e1c4535fa98b0d2cdd5e055e637203a13b97610c2ef42d26e8b5fed3d2781c5b53baf6e400c63124e53279c8871fd0966556153b29df4c4d5e9db5aa0819ffe38f8670aa19d4554f653497ebdf543d9a319102a7b623f3fe1e65703bf90bfd516636051a0e5cba98eef8f1a2ca5fa8d2607e3db00f32cb00d862be6afbcedf91bfda05b2f06da008dd0929dff59a0771724d671fcd7dc8033ae51865411668cf2634b0d7635261ae554db5731005da309e76b53c0c6c48a6ee0fc8d48509b78db7b13b90f0916f679f3a276737e506a5bc2815367d87232ed761a469b64dc9e503ebf0d189422cf8fa09ba84bc5f3be17390b038930f92fb7e6dac26d86b54060421af6a850cb07258e0219e7b3dd6c2c5e987b9ace70207024cce3a1edb2f38943f1e2e6ae5a1e4f1205775b05650cf6eb80872c2330d3aeed4b7c85d9a73150ff36ea36a55429983103842a9de18cbefef567c8fdc5406cde853853a9d31b7fbc0b7e4dae61a5a10ccb072e717eeec4a15accd5ab92640311753e93a45fb85f700ebd5d2e8155f4344a699cff3d8505427d1ce49927243ef3aae02c333a5dcdf42a82afbee684670216c3754f84fa535e47029ceddbf4b0b3cd6d8e229439756139106c0184c11e7ecd9f70e6873f842196247b52ebc0e7b77b70569505ad33660e05c9373b75186418ef1d79b03a9fc071c2c207d5e4e4486472b400baa01adb0d8afc69633742921cdd3258d5aa4ab1d56d2f6dcecd56ec366dc2a71471ac41cd47d91b19bc75aac9ecff97e7ecf18b0a335767c59bae64dae25fbe9d3e1c075100455644a0f9793083b51e4cbd976fd8aae125f153b64904a33d25567b1168a58e3164343116fc104058408e653d633759745af1a0f489975a7077870ab381be04d36ff8249667069cf64e1a1fd15388ff4928b2a65638cdc37202d9ffc45e72cebe46a32562cd21315078f3dbd5546837375521ef6087610622419265d0eceedfe2c38a12b422cd24c7e95c814e37d53961ba6274699636c3d23c84dbe2b5299192e5b6a06b876d13838a85e0d88f1089b8d29aae915c08fc54e0dd44952f0d480eedc75968967f8bec8a67716c15c131b924fe15f319fcc3fe4754cb2ba3c09090195a3cdb5cfc397d6388787a6ae28c692fcef03162a62845b3a6510f393362b628f614fa56cdfa0fc067c5fc1ebfe7c563494d2b5f7c1d60c78d83dca6092a87fde0d1fc258309cb4affdd602ebba9e39cbb762db6577b233b5735aa505a1e73b71508fec36b611ff53968fb4ef000a1b77f627cc4684fb08f0fd14b96c93517ef31e79ee484119be4a715d56401b069cd1c5d48c25a2cca37b12f1dc2881415db28a7c90adaee7683926fb40e853fdfad16492697f9764de4f535cc8e23dd871833441188ef84b77686caef14d19b8efa0c9d939c899215c1f425c0533c3c32be3c969732726e5d550664203fab5d080e9191488a640f50b417e89b7372ce5fccff07b2c90cbe2c03015eaabc06cbc994f898d1d906cc8a2189806805ce8919d550f40c2b6ca676343ee369ba979701cd76f011b4ddbffe73a39339adf495a3e3b4202a909df4d4ca398c0ad03c8f0efa9611c7485d6a06c8b5efcb2eb7dc9b81796cf20e416f6c5e600273191329252f5c5d1855f404de1492a572e9d23c1489d73b7cd22a71541bd8f2418189ad024895f9fb7afbd0e3559ece172fec515ace0e94d29e50631a5e2e7234f727a945d57b7304585db44cbab4c5ceac6a391e4f7f89fe4af2114e6e654d7396836407ba61cf6dea85cc568655f4832fe11e4581596e00ccf6f8a17c894c53a35b58f3d0a0538e636aa90753e5d6f373a2248dc88ff0d05b2a139acc181c1df63bb81121d0df33de18aefac6ee6a4b62db45e35119ec07698f56ef5e3e9e5046945a49024ee31b67b08e7bbe1e1342365a97c1293a5e4faf6ebaae6187236356dfe51b62d7fdca8ca0e91717ec7103f9b7bd36758f2c7fd09d2fed1efb7a4d78b352f97039f1298a2fa001d787a59d7bd37c426e824e604e947b2cd7ef8ebfb5b708412c2ee6c1cdd3970efd8a9bd73015cd5e8b28e3699ac98d91122f4e286ab871190943961956438e62fa57de504c623be3bfb22789a8595822f13d69351c28b9f60d07b4fa4e33d0265df691eaf214417840bc9bff95ad87f249b51ac624722092e66084f47a3055ab30adb076b7ff82bbcf0beeca816befea133fe5410968652bfe441814b37ee20ab62a1e0282e14a5d3965cf9d996479291d1c936bc012720800ede19ffdc984d9a78f600986ecd76ad7d665707674d1e38c6dc15e1d60753968a1fad1cbb1ec3858e0bf50ed9239c08adc9c24f089abd7f4837cb53cb451e0f421635eac764de34d3b8fee7971f6b0f39d710846a1db30d3cd44a5ace8164f45cb7ab686997efa7436ae50bcf7ec9ebd543756731e35075e9f6144568b57d6441097899fe777de7352d0b132ce23ae8b594426b79c3e7e450e3980fe10bda9ba064f928d17f029f03ba0839cbad56d6e1380c3a04373a62a88ba2e91716dc8d65bd7898b69da00d719d52cb8005ad46c44c34058bb8efb4447edfc65aee610d28c92e6cd29e29</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">You know what this means.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> letter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂记录</title>
      <link href="/2022/11/issues/"/>
      <url>/2022/11/issues/</url>
      
        <content type="html"><![CDATA[<h1 id="常见小问题"><a href="#常见小问题" class="headerlink" title="常见小问题"></a>常见小问题</h1><h2 id="终端无法运行脚本"><a href="#终端无法运行脚本" class="headerlink" title="终端无法运行脚本"></a>终端无法运行脚本</h2><p>参考<a href="https://go.microsoft.com/fwlink/?LinkID=135170">Microsoft文档</a> 中about_Execution_Policies</p><h2 id="遇到的一些问题"><a href="#遇到的一些问题" class="headerlink" title="遇到的一些问题"></a>遇到的一些问题</h2><p>1 Q&amp;E</p><pre><code class="bash">platform unsupported hexo-deployer-git@3.0.0 › hexo-fs@3.1.0 › chokidar@3.5.3 › fsevents@~2.3.2 Package require os(darwin) not compatible with your platform(win32)[fsevents@~2.3.2] optional install error: Package require os(darwin) not compatible with your platform(win32)</code></pre><p>A 这是一个可以忽略的错误，fsevents是可选的依赖，只能应用于maxOS系统，不适合Windows或者Linux，也就是忽略即可</p>]]></content>
      
      
      
        <tags>
            
            <tag> record&amp;reference </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游玩LaTeX</title>
      <link href="/2022/11/LaTeX/"/>
      <url>/2022/11/LaTeX/</url>
      
        <content type="html"><![CDATA[<h1 id="LaTeX笔记"><a href="#LaTeX笔记" class="headerlink" title="LaTeX笔记"></a>LaTeX笔记</h1><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><pre><code class="latex">//English\documentclass&#123;article&#125;\begin&#123;document&#125;&quot;Hello world!&quot; from \LaTeX\end&#123;document&#125;//中文\documentclass&#123;ctexart&#125;\begin&#123;document&#125;“你好，世界！” 来自 \LaTeX&#123;&#125; 的问候  //怀疑这里新版本不需要&#123;&#125;占空格了\end&#123;document&#125;</code></pre><h2 id="相关概念辨析"><a href="#相关概念辨析" class="headerlink" title="相关概念辨析"></a>相关概念辨析</h2><h3 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h3><p>排版引擎是编译源代码并生成文档的程序，如pdfLaTeX、XeLaTeX等。有时也称为编译器</p><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>是定义了一组命令的代码集。如LaTeX。高纳德本人也编写了一个简单的plain TeX格式，但仍不便于使用</p><h3 id="编译命令"><a href="#编译命令" class="headerlink" title="编译命令"></a>编译命令</h3><p>是实际调用的、结合了引擎和格式的命令。如<code>xelatex</code>命令是结合了XeTeX引擎和LaTeX格式的一个编译命令</p>]]></content>
      
      
      
        <tags>
            
            <tag> LaTeX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chem-E-Car 小车动力控制电路部分记录</title>
      <link href="/2022/10/Car_Doc/"/>
      <url>/2022/10/Car_Doc/</url>
      
        <content type="html"><![CDATA[<h2 id="材料选用"><a href="#材料选用" class="headerlink" title="材料选用"></a>材料选用</h2><p>主板：ARDUINO UNO R3</p><p>拓展板：ARDUINO MOTOR SHIELD REV3</p>]]></content>
      
      
      
        <tags>
            
            <tag> Chem-E-Car </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ToDo</title>
      <link href="/2022/08/Todo/"/>
      <url>/2022/08/Todo/</url>
      
        <content type="html"><![CDATA[<h1 id="接下来的任务"><a href="#接下来的任务" class="headerlink" title="接下来的任务"></a>接下来的任务</h1><ul><li>hexo更深度自定义主题</li><li>favicon自定义</li><li>404页面</li><li>图床建设</li><li>图片模式选用</li><li>用户名重新选择</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> todo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Notes For Git</title>
      <link href="/2022/07/Notes-For-Git/"/>
      <url>/2022/07/Notes-For-Git/</url>
      
        <content type="html"><![CDATA[<h1 id="Notes-For-Git"><a href="#Notes-For-Git" class="headerlink" title="Notes For Git"></a>Notes For Git</h1><h2 id="Settings"><a href="#Settings" class="headerlink" title="Settings"></a>Settings</h2><pre><code class="bash">$ git config --list --show-originfile:D:/Git/etc/gitconfig       diff.astextplain.textconv=astextplainfile:D:/Git/etc/gitconfig       filter.lfs.clean=git-lfs clean -- %ffile:D:/Git/etc/gitconfig       filter.lfs.smudge=git-lfs smudge -- %ffile:D:/Git/etc/gitconfig       filter.lfs.process=git-lfs filter-processfile:D:/Git/etc/gitconfig       filter.lfs.required=truefile:D:/Git/etc/gitconfig       http.sslbackend=opensslfile:D:/Git/etc/gitconfig       http.sslcainfo=D:/Git/mingw64/ssl/certs/ca-bundle.crtfile:D:/Git/etc/gitconfig       core.autocrlf=truefile:D:/Git/etc/gitconfig       core.fscache=truefile:D:/Git/etc/gitconfig       core.symlinks=falsefile:D:/Git/etc/gitconfig       pull.rebase=falsefile:D:/Git/etc/gitconfig       credential.helper=managerfile:C:/Users/[]/.gitconfig        user.name=[]file:C:/Users/[]/.gitconfig        user.email=[]@[]$ git config --global user.name &quot;a&quot;$ git config --global user.email &quot;@&quot;$ git config --global core.editor &quot;code --wait&quot;$ git config --global core.editor &quot;code --wait&quot;$ git config --list$ git config user.name$ git config --global init.defaultBranch main$ git help &lt;verb&gt;$ git &lt;verb&gt; --help$ man git-&lt;verb&gt;</code></pre><p>There levels: <code>--local</code> &gt; <code>--global</code> &gt; <code>--system</code></p><p>On Windows systems, Git looks for the <code>.gitconfig</code> file in the $HOME directory (C:\Users$USER for most people). It also still looks for <code>[path]/etc/gitconfig</code>, although it’s relative to the MSys root, which is wherever you decide to install Git on your Windows system when you run the installer. </p><h2 id="Basics"><a href="#Basics" class="headerlink" title="Basics"></a>Basics</h2><h3 id="initializing"><a href="#initializing" class="headerlink" title="initializing"></a>initializing</h3><pre><code class="bash">$ cd D:/my_project$ git init</code></pre><p>to control a repository with git and this will create a file named <code>.git</code></p><p>we can initialize a repository like this:</p><pre><code class="bash">$ git add *.c$ git add LICENSE$ git commit -m &#39;Initial project version&#39;</code></pre><h3 id="cloning"><a href="#cloning" class="headerlink" title="cloning"></a>cloning</h3><p>we can clone a repository like this:</p><pre><code class="bash">$ git clone https://github.com/</code></pre><p>if want a new name </p><pre><code class="bash">$ git clone &lt;url&gt; name</code></pre><p>and there are other protocols that can be chosen(SSH)</p><h3 id="recording-changes"><a href="#recording-changes" class="headerlink" title="recording changes"></a>recording changes</h3><p>two states : tracked or untracked. To CHECK this :</p><pre><code class="bash">$ git statusOn branch masterYour branch is up-to-date with &#39;origin/master&#39;.nothing to commit, working tree clean$ git status -sM READMEMM RakefileA lib/git.rbM lib/simplegit.rb?? LICENSE.txt</code></pre><p>There are two columns to the output — the left-hand column indicates the status of the staging area and the right-hand column indicates the status of the working tree. </p><h3 id="Ignoring-Files"><a href="#Ignoring-Files" class="headerlink" title="Ignoring Files"></a>Ignoring Files</h3><pre><code class="bash">- .gitignore$ cat .gitignore*.[oa]*~# ignore all .a files*.a# but do track lib.a, even though you&#39;re ignoring .a files above!lib.a# only ignore the TODO file in the current directory, not subdir/TODO/TODO# ignore all files in any directory named buildbuild/# ignore doc/notes.txt, but not doc/server/arch.txtdoc/*.txt# ignore all .pdf files in the doc/ directory and any of its subdirectoriesdoc/**/*.pdf</code></pre><h3 id="Viewing-Your-Staged-and-Unstaged-Changes"><a href="#Viewing-Your-Staged-and-Unstaged-Changes" class="headerlink" title="Viewing Your Staged and Unstaged Changes"></a>Viewing Your Staged and Unstaged Changes</h3><p><code>git diff</code> shows you the exact lines added and removed — the patch, as it were</p><h3 id="Commit-Your-Changes"><a href="#Commit-Your-Changes" class="headerlink" title="Commit Your Changes"></a>Commit Your Changes</h3><p><code>git commit</code> 这样需要打开编辑器输入</p><p><code>git commmit -m &quot;There is message&quot;</code></p><pre><code class="bash">$ git commit -m &quot;Story 182: fix benchmarks for speed&quot;[master 463dc4f] Story 182: fix benchmarks for speed2 files changed, 2 insertions(+)create mode 100644 README</code></pre><p><code>git commit -a</code> 可以跳过stage阶段</p><h3 id="Removing-Files"><a href="#Removing-Files" class="headerlink" title="Removing Files"></a>Removing Files</h3><p>remove it from your tracked files, and also removes the file from your working directory so you don’t see it as an untracked file the next time around</p><p><code>rm</code> 直接删除，但是不stage</p><p><code>git rm</code> 删除，但是已经stage</p><p>If you modified the file or had already added it to the staging area, you must force the removal with the <code>-f</code> option. </p><p>to keep the file in your working tree but remove it from your staging area.</p><p><code>git rm --cached README</code></p><h3 id="Moving-Files"><a href="#Moving-Files" class="headerlink" title="Moving Files"></a>Moving Files</h3><p>重命名</p><pre><code class="bash">$ git mv README.md README$ git statusOn branch masterYour branch is up-to-date with &#39;origin/master&#39;.Changes to be committed:(use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)renamed: README.md -&gt; README</code></pre><p>相当于</p><pre><code class="bash">$ mv README.md README$ git rm README.md$ git add README</code></pre><h3 id="Viewing-the-Commit-History"><a href="#Viewing-the-Commit-History" class="headerlink" title="Viewing the Commit History"></a>Viewing the Commit History</h3><p><code>git log</code> 查看commit history</p><p><code>git log -patch</code> 显示每次的commit的不同之处</p><p><code>git log -2</code> 只看最近两条</p>]]></content>
      
      
      
        <tags>
            
            <tag> Git notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Algorithm</title>
      <link href="/2022/06/Algorithm/"/>
      <url>/2022/06/Algorithm/</url>
      
        <content type="html"><![CDATA[<h1 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h1><h3 id="1dim-peak-finder"><a href="#1dim-peak-finder" class="headerlink" title="1dim peak finder"></a>1dim peak finder</h3><p>$$\Theta (n)  $$ </p><p>if we adopt <strong>divide &amp; conquer</strong> </p><p>the complexity will be </p><p>$$T(n) &#x3D; T(\frac n2)+ \Theta(1)$$</p><p>and there is the base case :</p><p>$$T(1)&#x3D;\Theta(1)$$</p><p>thus </p><p>$$<br>T(n)&#x3D; \Theta(1) +\Theta(1)+…+\Theta(1)<br>    &#x3D; \Theta(\log _{2} n)<br>$$</p>]]></content>
      
      
      
        <tags>
            
            <tag> algorithm notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>My Raspberry Pi</title>
      <link href="/2021/02/My-Raspberry-Pi/"/>
      <url>/2021/02/My-Raspberry-Pi/</url>
      
        <content type="html"><![CDATA[<h2 id="About-Raspberry-Pi"><a href="#About-Raspberry-Pi" class="headerlink" title="About Raspberry Pi"></a>About Raspberry Pi</h2><p>这里本来打算放张图片</p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><h3 id="最理想情况"><a href="#最理想情况" class="headerlink" title="最理想情况"></a>最理想情况</h3><p>官网下载Pi OS镜像，烧录SD卡，连接好键盘显示屏，启动</p><h3 id="无显示屏"><a href="#无显示屏" class="headerlink" title="无显示屏"></a>无显示屏</h3><ul><li>开启ssh访问，在boot目录新建<code>ssh</code>的不带后缀名的空文件。</li><li>用RJ45网线连接笔记本电脑和树莓派。</li><li>等待树莓派启动完毕，打开笔记本电脑的网络和共享中心，可以看到出现了一个未识别网络，连接方式是以太网。然后再查看分配给这个以太网的接口IP地址（如192.168.137.1）</li><li>手机开热点，通过它可以让树莓派联网。在网络和共享中心中，点击无线网络-&gt;属性-&gt;共享 ，给“允许其它网络用户通过此计算机的internet来连接”打勾，然后确定。</li><li>打开CMD，输入以下命令查看网络接口信息：<code>arp -a</code></li><li>在前面查到的接口：192.168.137.1 下方找到第一个连接的ip地址，即为树莓派的ip地址。</li><li>打开PuTTY<ul><li>host 填入: 开发板 ip 即可。</li><li>用户名、密码同串口登陆一致（默认：pi、raspberry）</li></ul></li></ul><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="更新软件源"><a href="#更新软件源" class="headerlink" title="更新软件源"></a>更新软件源</h3><p>首先查看自己树莓派系统版本，一般有jessie,stretch,buster,wheezy这4个版本。</p><pre><code>No LSB modules are available.Distributor ID:RaspbianDescription:Raspbain GNU/Linux 10 (buster)Release:10Codename: busterCopy</code></pre><p>开始换源</p><pre><code>sudo vim /etc/apt/sources.listCopy</code></pre><p>将默认的内容删掉或者用<code>#</code>号注释，改为</p><pre><code>deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/   buster main contrib non-free rpideb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main contrib non-free rpiCopy</code></pre><p>或者用以下地址代替上面的地址栏</p><p>中山大学<br><a href="https://link.zhihu.com/?target=http://mirror.sysu.edu.cn/raspbian/raspbian/">Raspbian http://mirror.sysu.edu.cn/raspbian/raspbian/</a></p><p>中国科学技术大学<br><a href="https://link.zhihu.com/?target=http://mirrors.ustc.edu.cn/raspbian/raspbian/">Raspbian http://mirrors.ustc.edu.cn/raspbian/raspbian/</a></p><p>清华大学<br><a href="https://link.zhihu.com/?target=http://mirrors.tuna.tsinghua.edu.cn/raspbian/">Raspbian </a><a href="https://link.zhihu.com/?target=http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/">http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/</a></p><p>华中科技大学<br><a href="https://link.zhihu.com/?target=http://mirrors.hustunique.com/raspbian/raspbian/">Raspbian http://mirrors.hustunique.com/raspbian/raspbian/</a></p><p><a href="https://link.zhihu.com/?target=http://mirrors.hustunique.com/archlinuxarm/">Arch Linux ARM http://mirrors.hustunique.com/archlinuxarm/</a></p><p>大连东软信息学院源（北方用户）</p><p><a href="https://link.zhihu.com/?target=http://mirrors.neusoft.edu.cn/raspbian/raspbian/">Raspbian http://mirrors.neusoft.edu.cn/raspbian/raspbian/</a></p><p>（可参考Ubuntu配置）</p><p>再更新</p><pre><code>sudo apt updateCopy</code></pre><p>更新系统软件</p><pre><code>sudo apt upgradeCopy</code></pre><h2 id="Web项目"><a href="#Web项目" class="headerlink" title="Web项目"></a>Web项目</h2><h3 id="LNSP"><a href="#LNSP" class="headerlink" title="LNSP"></a>LNSP</h3><p>Linux Nginx SQLite PHP</p><pre><code>sudo apt install nginxsudo apt install php7.3sudo apt install php7.3-fpmsudo apt install php7.3-sqlitesudo apt install php7.3-commonsudo apt install sqliteCopy</code></pre><ul><li>启动 nginx</li></ul><pre><code>sudo /etc/init.d/nginx startCopy</code></pre><ul><li>修改 nginx 的配置文件</li></ul><pre><code>sudo vim /etc/nginx/sites-available/defaultCopy</code></pre><ul><li>PHP 脚本支持</li></ul><p>找到 php 的定义段，将这些行的注释去掉 ，修改后内容如下</p><pre><code># Default server configuration#server &#123;        listen 80 default_server;        listen [::]:80 default_server;         root /var/www/html;         # Add index.php to the list if you are using PHP        index index.html index.htm index.nginx-debian.html index.php;         server_name _;         location / &#123;                 # First attempt to serve request as file, then                 # as directory, then fall back to displaying a 404.                 try_files $uri $uri/ =404;        &#125;         # pass PHP scripts to FastCGI server        #        location ~ \.php$ &#123;                 # include snippets/fastcgi-php.conf;                 #                 # # With php-fpm (or other unix sockets):                 fastcgi_pass unix:/run/php/php7.3-fpm.sock;                 # # With php-cgi (or other tcp sockets):                 # fastcgi_pass 127.0.0.1:9000;                 # 设置脚本文件请求的路径                 fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;                 # 引入fastcgi的配置文件                  include fastcgi_params;        &#125; &#125;Copy</code></pre><ul><li>重新加载 nginx 的配置</li></ul><pre><code>sudo /etc/init.d/nginx reloadCopy</code></pre><ul><li>测试 html</li></ul><p>通过主机的 IE 访问树莓派，可以看到主页 (表示 Web 服务器已正常启动)</p><ul><li>测试 php</li></ul><p>输入下列命令</p><pre><code>sudo chmod 777 /var/            #下面三行给文件授予权限sudo chmod 777 /var/wwwsudo chmod 777 /var/www/htmlCopy</code></pre><p>在树莓派中生成一<code>php</code>文件</p><pre><code>sudo vim /var/www/index.phpCopy</code></pre><p>在文件中输入以下内容</p><pre><code>&lt;?php    print &lt;&lt;&lt; EOT  &lt;!doctype html&gt;  &lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;Test successful&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;  &lt;h1&gt;Test successful&lt;/h1&gt;  &lt;p&gt;Congratulations.&lt;/p&gt;  &lt;p&gt;Your webserver and PHP are working.&lt;/p&gt;  &lt;/body&gt;  &lt;/html&gt;  EOT;  ?&gt;Copy</code></pre><p>到此为止，lnsp就安装完毕</p><h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><p>官方</p><pre><code>wget https://nodejs.org/dist/v12.16.1/node-v00.00.0-linux-armv7l.tar.xzCopy</code></pre><p>国内镜像</p><pre><code>wget https://npm.taobao.org/mirrors/node/latest/node-v00.00.0-linux-armv7l.tar.xzCopy</code></pre><p>解压：</p><pre><code>xz -d node-v12.13.1-linux-armv7l.tar.xztar -xavf node-v12.13.1-linux-armv7l.tarCopy</code></pre><p>将系统内原本存在的<code>/usr/bin.node</code>删除</p><pre><code>sudo rm -rf /usr/bin/node#如果不存在，忽略此步骤Copy</code></pre><p>解压后，将二进制包移动到<code>/usr/local/node</code>下</p><pre><code>sudo mv ./node-v10.0.0-linux-armv7l /usr/local/nodeCopy</code></pre><p>为<code>node</code>和<code>npm</code>建立软连接，在终端输入：</p><pre><code>sudo ln -s /usr/local/node/bin/node /usr/bin/nodesudo ln -s /usr/local/node/bin/npm /usr/bin/npm#这类似于Windows中的快捷方式Copy</code></pre><p>通过查看<code>node</code>和<code>npm</code>版本的方式来查看是否成功</p><pre><code>node -v &amp;&amp; npm -vCopy</code></pre><p>可以看到对应的版本号说明安装成功</p><p>由于国内网速问题<code>npm</code>包管理器的速度会较慢，利用<code>npm</code>安装<code>cnpm</code>某宝源</p><pre><code>npm install -g cnpm --registry=https://registry.npm.taobao.orgCopy</code></pre><p>为<code>cnpm</code>建立软连接</p><pre><code>sudo ln -s /usr/local/node/bin/cnpm /usr/bin/cnpmCopy</code></pre><blockquote><p>Windows cnpm</p><pre><code>$ npm install cnpm -gCopy</code></pre><p>If you’re in China, maybe you should install it from our <a href="https://npm.taobao.org/">China mirror</a>:</p><pre><code>$ npm install cnpm -g --registry=https://r.npm.taobao.orgCopy</code></pre></blockquote><h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h3><p>至于软件，暂时选用Hexo，虽然还有Typecho、WordPress备选，但是先尝试这个。</p><p>主题参考</p><ul><li><a href="https://github.com/fluid-dev/hexo-theme-fluid">fluid</a>（主要看上了打字机特效）</li><li><a href="https://linhong.me/2020/01/27/hexo-theme-aomori/">Aomori</a>（看上了右边栏特效）</li><li><a href="https://github.com/lixuetaoleo/hexo-theme-leo">Ieo</a>（封面）</li><li><a href="https://sharvaridesai.github.io/hexo-theme-edinburgh-demo/">Edinburgh</a>（看设计感）</li><li><a href="https://mrwillcom.github.io/">mrwill</a>（设计感）</li></ul><h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><p>在本地完成hexo渲染，部署public文件夹到树莓派，完整文件夹git到github仓库。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="Linux-常用命令"><a href="#Linux-常用命令" class="headerlink" title="Linux 常用命令"></a>Linux 常用命令</h3><p>文件改名 <code>sudo mv test.txt new.txt\</code></p><ul><li><strong>mkdir xxx</strong> 创建文件夹xxx</li><li><strong>mkdir a1 a2 a3</strong> 批量创建文件夹 a1、文件夹 a2、文件夹 a3</li><li><strong>mkdir -p b1&#x2F;b2&#x2F;b3</strong> 连续创建文件夹 b1、文件夹 b2、文件夹 b3</li></ul><h3 id="RPI串口电路"><a href="#RPI串口电路" class="headerlink" title="RPI串口电路"></a>RPI串口电路</h3>]]></content>
      
      
      
        <tags>
            
            <tag> Raspberry Pi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A Guide to rebuid the workplace</title>
      <link href="/2020/07/guide/"/>
      <url>/2020/07/guide/</url>
      
        <content type="html"><![CDATA[<h1 id="重新搭建现有工作环境的指南"><a href="#重新搭建现有工作环境的指南" class="headerlink" title="重新搭建现有工作环境的指南"></a>重新搭建现有工作环境的指南</h1><h2 id="电脑配置清单"><a href="#电脑配置清单" class="headerlink" title="电脑配置清单"></a>电脑配置清单</h2><ul><li>华硕(ASUS)PRIME Z390-A 主板 现价1749元 <a href="https://item.jd.com/100000542145.html">链接</a></li><li>英特尔(Intel)i7-9700KF 约价2799元 <a href="https://item.jd.com/100002106617.html#none">链接</a></li><li>英伟达(NVIDIA)GTX1660 约价1799元 <a href="https://item.jd.com/100003739778.html#none">链接</a>（不确定）</li><li>金士顿(Kingston)DDR4 2400 16GB 现价549元 <a href="https://item.jd.com/2551276.html">链接</a></li><li>三星(SAMSUNG)250GB SSD固态硬盘 M.2接口(NVMe协议) 现价499元 <a href="https://item.jd.com/100002183459.html">链接</a></li><li>西部数据(WD)蓝盘 1TB 现价299元 <a href="https://item.jd.com/675971.html">链接</a></li><li>罗技(Logitech)K310 键盘 现价149元 <a href="https://item.jd.com/712162.html#none">链接</a>（首选）<ul><li>罗技（G）G610机械键盘 现价479元 <a href="https://item.jd.com/3034311.html#none">链接</a>（备选）</li></ul></li><li>罗技（Logitech）M100r 鼠标 现价52.9元 <a href="https://item.jd.com/692919.html">链接</a>（首选）<ul><li>罗技（G）G502 HERO主宰者有线鼠标 现价379元 <a href="https://item.jd.com/100001691967.html#product-detail">链接</a>（备选）</li></ul></li><li>AOC I2490VXH5&#x2F;BS 23.8英寸 现价779元 <a href="https://item.jd.com/100002222528.html?dist=jd#none">链接</a></li><li>乔思伯（JONSBO）U5 银色 ATX机箱 现价499元 <a href="https://item.jd.com/8885801.html#crumb-wrap">链接</a>（不确定）</li><li>酷冷至尊（CoolerMaster） T20 CPU 散热器 现价49元 <a href="https://item.jd.com/19988002706.html#product-detail">链接</a></li><li>长城（GreatWall）额定500W HOPE-6000DS 电源 现价269元 <a href="https://item.jd.com/876229.html">链接</a></li><li>灵蛇（LINGSHE）鼠标垫 现价4.9元 <a href="https://item.jd.com/4062692.html">链接</a></li></ul><p>小计：9565.9元</p><h3 id="机械键盘品牌参考"><a href="#机械键盘品牌参考" class="headerlink" title="机械键盘品牌参考"></a>机械键盘品牌参考</h3><p>宁芝mini84</p><p>阿米洛sword</p><p>Filco</p><p>Leopold</p><p>杜伽</p><h2 id="应用列表"><a href="#应用列表" class="headerlink" title="应用列表"></a>应用列表</h2><h3 id="普通使用"><a href="#普通使用" class="headerlink" title="普通使用"></a>普通使用</h3><ul><li>chrome</li><li>Potplayer</li><li>Bandizip</li><li>Lantern</li><li>TranslucentTB</li><li>Xmind<ul><li>mindmaster</li><li>freemind</li></ul></li><li>坚果云</li><li>Joplin</li><li>Everything</li><li>Wox</li><li>网易云音乐</li><li>小黑盒</li><li>幕布</li><li>有道云笔记</li><li>Steam</li><li>Pokemmo</li><li>QuickLook</li></ul><h3 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h3><h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><ul><li>Git</li><li>Node.js</li><li>Hexo</li><li>Java JDk</li><li>Python</li><li>MinGW-64w</li><li>Tex Live</li><li>VMware Workstation<ul><li>ubuntu</li></ul></li><li>wsl子系统<ul><li>Ubuntu</li><li>VcXsrv</li></ul></li></ul><h4 id="编辑器-x2F-IDE"><a href="#编辑器-x2F-IDE" class="headerlink" title="编辑器&#x2F;IDE"></a>编辑器&#x2F;IDE</h4><ul><li><p>Visual Studio Code</p></li><li><p>Atom</p></li><li><p>Visual Studio</p></li><li><p>Codelite</p></li><li><p>Typora</p></li><li><p>Vim</p></li><li><p>Neovim</p></li><li><p>Eclipse</p></li><li><p>JetBrains系</p><ul><li>CLion(附破解)</li></ul></li></ul><h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><ul><li><p>Mockplus(做原型可选，主用XD)</p></li><li><p>达芬奇</p></li><li><p>Zeplin</p></li><li><p>Gimp</p></li><li><p>Adobe系</p><ul><li>Creative Cloud</li><li>Photoshop</li><li>Premiere Pro</li><li>Media ENcoder</li><li>Lightroom Classic</li><li>XD</li><li>Illustrator</li><li>Audition</li></ul></li></ul><h3 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h3><ul><li><p>FL Studio</p></li><li><p>guitar pro 7</p></li></ul><h3 id="字体资源列表"><a href="#字体资源列表" class="headerlink" title="字体资源列表"></a>字体资源列表</h3><p>文件在字体文件夹里</p><ul><li>Source Code Pro —adobe</li><li>思源黑体</li><li>思源宋体</li><li>禹卫书法行书简体</li></ul><h2 id="文件夹"><a href="#文件夹" class="headerlink" title="文件夹"></a>文件夹</h2><ul><li>Private</li><li>Material</li><li>Project</li></ul><h2 id="附各类应用配置"><a href="#附各类应用配置" class="headerlink" title="附各类应用配置"></a>附各类应用配置</h2><h4 id="Chrome"><a href="#Chrome" class="headerlink" title="Chrome"></a>Chrome</h4><p>&#x2F;&#x2F;不知道用户同步能不能用</p><p>扩展：gooreplacerv3.9（放在工具文件夹）</p><p>书签:</p><ul><li><p><a href="https://www.github.com/">Github</a></p></li><li><p><a href="https://translate.google.cn/?hl=zh-CN&tab=TT">Google 翻译</a></p></li><li><p><a href="https://www.zhihu.com/">知乎</a></p></li><li><p><a href="https://www.bilibili.com/">Bilibli</a></p></li><li><p><a href="https://www.jiumodiary.com/">鸠摩搜索</a></p></li><li><p><a href="https://bitbucket.org/product/">Bitbucket</a></p></li><li><p><a href="https://phys.org/">Phys.org</a></p></li><li><p><a href="https://www.feynmanlectures.caltech.edu/">The Feynman Lectures on Physics</a></p></li><li><p><a href="https://www.audiolibrary.com.co/">Audio Library</a></p></li><li><p><a href="http://www.doyoudo.com/">doyoudo</a></p></li><li><p><a href="http://pengzhihui.xyz/">稚晖的个人站</a></p></li><li><p><a href="https://xenwayne.top/">XenWayne‘s Blog</a></p></li><li><p><a href="https://rafaltomal.com/">Rafal Tomal</a></p></li><li><p><a href="https://esappear.github.io/clover/">Clover Tuan</a></p></li><li><p><a href="https://www.arduino.cc/">Arduino</a></p></li><li><p><a href="https://www.raspberrypi.org/">Raspberry Pi</a></p></li><li><p><a href="https://www.dandyweng.com/">翁天信 · Dandy Weng 的个人网站主页</a></p></li><li><p><a href="https://www.julydate.com/">七夏浅笑</a></p></li><li><p><a href="https://www.lhteam.top/">LHteam</a></p></li><li><p><a href="https://element.eleme.cn/#/zh-CN">Element</a></p></li><li><p><a href="https://crashcourse.club/">CrashCourse</a></p></li><li><p><a href="https://bigjpg.com/zh">Bigjpg</a></p></li><li><p><a href="https://dribbble.com/">Dribbble</a></p></li><li><p><a href="https://www.webdesignrankings.com/resources/lolcolors/">LOL Colors - Curated color palette inspiration</a></p></li><li><p><a href="https://www.bootcss.com/p/websafecolors/">Web安全色</a></p></li><li><p><a href="https://color.adobe.com/create/color-wheel/">adobeColor</a></p></li><li><p><a href="https://flatuicolors.com/">Palettes</a></p></li><li><p><a href="https://colorsupplyyy.com/app">Color Picker</a></p></li><li><p><a href="https://mycolor.space/">ColorSpace</a></p></li><li><p><a href="https://www.iconfont.cn/">iconfont</a></p></li><li><p><a href="https://www.freepik.com/">Free Vectors, Photos and PSD Downloads | Freepik</a></p></li><li><p><a href="https://unsplash.com/">Unsplash</a></p></li><li><p><a href="https://balsamiq.com/">Balsamiq</a></p></li><li><p><a href="https://www.easyicon.net/">Easyicon</a></p></li><li><p><a href="https://magdeleine.co/">Magdeleine</a></p></li><li><p><a href="https://www.splitshire.com/">SplitShire</a></p></li><li><p><a href="https://flaticons.net/">FlatIcons</a></p></li><li><p><a href="https://www.91sotu.com/">搜图导航</a></p></li><li><p><a href="https://huaban.com/">花瓣网</a></p></li><li><p><a href="https://acg.rip/">ACG.RIP</a></p></li><li><p><a href="http://www.xuanfengge.com/funny/html5/element/">HTML5元素周期表</a></p></li><li><p><a href="https://zigzagpack.com/">ZigZag Pack</a></p></li><li><p><a href="https://www.udemy.com/">Udemy</a></p></li><li><p><a href="https://www.yuque.com/guigumentor/guigu">鬼谷·全球 · 语雀</a></p></li><li><p><a href="https://liam.page/2014/09/08/latex-introduction/">一份其实很短的 LaTeX 入门文档 | 始终</a></p></li><li><p><a href="https://www.jianshu.com/p/b31ae75ab6df">好书整理-朗道十卷+费曼物理学讲义+中英文 - 简书</a></p></li><li><p><a href="https://apps.evozi.com/apk-sownloader/">Evozi Apps</a></p></li><li><p><a href="https://magi.com/">Magi</a></p></li><li><p><a href="https://www.geogebra.org/">GeoGebra</a></p></li></ul><h4 id="Visual-Studio-Code"><a href="#Visual-Studio-Code" class="headerlink" title="Visual Studio Code"></a>Visual Studio Code</h4><p>插件：</p><ul><li>Auto Rename Tag</li><li>Autoprefixer</li><li>beautify</li><li>Prettier - Code formatter(format on save 查找是否应用存文件时格式化)</li><li>Bracket Pair Colorizer 2</li><li>Chinese(Simplified)Language Pack for Visual Studio Code</li><li>Code Spell Checker</li><li>file-size</li><li>Guides</li><li>Highlight</li><li>Image preview</li><li>Latex Workshop(需额外配置，附配置文件)</li><li>Live Server</li><li>Markdown PDF</li><li>Markdown Preview Enhanced</li><li>Markdown Theme Kit</li><li>markdownlint</li><li>Material Theme</li><li>Community Material Theme</li><li>Material Theme Icons</li><li>Path intellisense</li><li>Settings Sync</li><li>SVG</li><li>C&#x2F;C++</li><li>Cobalt Next</li><li>Cobalt2 Theme Official</li><li>Code Runner</li><li>Marp for VS Code</li><li>Path Interllisense</li></ul><p>另附:</p><p>C语言环境设置<code>.vscode</code>在project的C文件夹里</p><p>VS Code 设置json文件</p><pre><code class="json">&#123;    &quot;workbench.iconTheme&quot;: &quot;material-icon-theme&quot;,    &quot;editor.renderIndentGuides&quot;: false,    &quot;workbench.colorTheme&quot;: &quot;Cobalt Next&quot;,    &quot;cSpell.userWords&quot;: [        &quot;Bandizip&quot;,        &quot;HWND&quot;,        &quot;Lightroom&quot;,        &quot;Minecraft&quot;,        &quot;Mockplus&quot;,        &quot;Mware&quot;,        &quot;Photoshop&quot;,        &quot;Potplayer&quot;,        &quot;Typora&quot;,        &quot;Xmind&quot;,        &quot;Zahlen&quot;,        &quot;Zeplin&quot;,        &quot;anchorjs&quot;,        &quot;cnzz&quot;,        &quot;doyoudo&quot;,        &quot;favicon&quot;,        &quot;hexo&quot;,        &quot;iconfont&quot;,        &quot;mware&quot;,        &quot;subseteq&quot;,        &quot;tencent&quot;,        &quot;v&quot;    ],    &quot;workbench.statusBar.visible&quot;: true,    &quot;editor.fontFamily&quot;: &quot;Source Code Pro,Consolas, &#39;Courier New&#39;, monospace&quot;,    &quot;workbench.startupEditor&quot;: &quot;newUntitledFile&quot;,    &quot;C_Cpp.updateChannel&quot;: &quot;Insiders&quot;,    // Latex workshop    &quot;latex-workshop.latex.tools&quot;: [        &#123;            // 编译工具和命令            &quot;name&quot;: &quot;latexmk&quot;,            &quot;command&quot;: &quot;latexmk&quot;,            &quot;args&quot;: [                &quot;-synctex=1&quot;,                &quot;-interaction=nonstopmode&quot;,                &quot;-file-line-error&quot;,                &quot;-pdf&quot;,                &quot;-outdir=%OUTDIR%&quot;,                &quot;%DOC%&quot;            ],            &quot;env&quot;: &#123;&#125;        &#125;,        &#123;            &quot;name&quot;: &quot;xelatex&quot;,            &quot;command&quot;: &quot;xelatex&quot;,            &quot;args&quot;: [                &quot;-synctex=1&quot;,                &quot;-interaction=nonstopmode&quot;,                &quot;-file-line-error&quot;,                &quot;-pdf&quot;,                &quot;-outdir=%OUTDIR%&quot;,                &quot;%DOC%&quot;            ]        &#125;,        &#123;            &quot;name&quot;: &quot;lualatexmk&quot;,            &quot;command&quot;: &quot;latexmk&quot;,            &quot;args&quot;: [                &quot;-synctex=1&quot;,                &quot;-interaction=nonstopmode&quot;,                &quot;-file-line-error&quot;,                &quot;-lualatex&quot;,                &quot;-outdir=%OUTDIR%&quot;,                &quot;%DOC%&quot;            ],            &quot;env&quot;: &#123;&#125;        &#125;,        &#123;            &quot;name&quot;: &quot;latexmk_rconly&quot;,            &quot;command&quot;: &quot;latexmk&quot;,            &quot;args&quot;: [                &quot;%DOC%&quot;            ],            &quot;env&quot;: &#123;&#125;        &#125;,        &#123;            &quot;name&quot;: &quot;pdflatex&quot;,            &quot;command&quot;: &quot;pdflatex&quot;,            &quot;args&quot;: [                &quot;-synctex=1&quot;,                &quot;-interaction=nonstopmode&quot;,                &quot;-file-line-error&quot;,                &quot;%DOC%&quot;            ],            &quot;env&quot;: &#123;&#125;        &#125;,        &#123;            &quot;name&quot;: &quot;bibtex&quot;,            &quot;command&quot;: &quot;bibtex&quot;,            &quot;args&quot;: [                &quot;%DOCFILE%&quot;            ],            &quot;env&quot;: &#123;&#125;        &#125;    ],    &quot;latex-workshop.latex.recipes&quot;: [        &#123;            &quot;name&quot;: &quot;xelatex&quot;,            &quot;tools&quot;: [                &quot;xelatex&quot;            ]        &#125;,        &#123;            &quot;name&quot;: &quot;latexmk 🔃&quot;,            &quot;tools&quot;: [                &quot;latexmk&quot;            ]        &#125;,        &#123;            &quot;name&quot;: &quot;xelatex ➞ xelatex&quot;,            &quot;tools&quot;: [                &quot;xelatex&quot;,                &quot;xelatex&quot;            ]        &#125;,        &#123;            &quot;name&quot;: &quot;xelatex ➞ bibtex ➞ xelatex × 2&quot;,            &quot;tools&quot;: [                &quot;xelatex&quot;,                &quot;bibtex&quot;,                &quot;xelatex&quot;,                &quot;xelatex&quot;            ]        &#125;,        &#123;            &quot;name&quot;: &quot;latexmk (latexmkrc)&quot;,            &quot;tools&quot;: [                &quot;latexmk_rconly&quot;            ]        &#125;,        &#123;            &quot;name&quot;: &quot;latexmk (lualatex)&quot;,            &quot;tools&quot;: [                &quot;lualatexmk&quot;            ]        &#125;,        &#123;            &quot;name&quot;: &quot;pdflatex ➞ bibtex ➞ pdflatex × 2&quot;,            &quot;tools&quot;: [                &quot;pdflatex&quot;,                &quot;bibtex&quot;,                &quot;pdflatex&quot;,                &quot;pdflatex&quot;            ]        &#125;    ],    &quot;latex-workshop.view.pdf.viewer&quot;: &quot;external&quot;,    &quot;latex-workshop.view.pdf.external.command&quot;: &#123;    &quot;command&quot;: &quot;D:/SumatraPDF/SumatraPDF.exe&quot;,    &quot;args&quot;: [        &quot;%PDF%&quot;    ]    &#125;,    &quot;latex-workshop.view.pdf.external.synctex&quot;: &#123;        //正向搜索        &quot;command&quot;: &quot;D:/SumatraPDF/SumatraPDF.exe&quot;,        &quot;args&quot;: [            &quot;-forward-search&quot;,            &quot;%TEX%&quot;,            &quot;%LINE%&quot;,            &quot;%PDF%&quot;        ]    &#125;,    &quot;latex-workshop.latex.clean.fileTypes&quot;: [        &quot;*.aux&quot;,        &quot;*.bbl&quot;,        &quot;*.blg&quot;,        &quot;*.idx&quot;,        &quot;*.ind&quot;,        &quot;*.lof&quot;,        &quot;*.lot&quot;,        &quot;*.out&quot;,        &quot;*.toc&quot;,        &quot;*.acn&quot;,        &quot;*.acr&quot;,        &quot;*.alg&quot;,        &quot;*.glg&quot;,        &quot;*.glo&quot;,        &quot;*.gls&quot;,        &quot;*.ist&quot;,        &quot;*.fls&quot;,        &quot;*.log&quot;,        &quot;*.fdb_latexmk&quot;    ],    &quot;latex-workshop.latex.autoBuild.run&quot;: &quot;never&quot;,    &quot;terminal.integrated.shell.windows&quot;: &quot;C:\\Windows\\System32\\cmd.exe&quot;,    &quot;sync.gist&quot;: &quot;ce4d87f82ed3f5648debe41732530e35&quot;,    &quot;cSpell.enableFiletypes&quot;: [        &quot;tex&quot;    ]    &#125;</code></pre><h4 id="Atom"><a href="#Atom" class="headerlink" title="Atom"></a>Atom</h4><p>插件：</p><ul><li>atom-beautify</li><li>atom-gpp-compiler</li><li>atom-live-server</li><li>atom-markdown-table-editor</li><li>atom-material-syntax</li><li>atom-material-syntax-dark</li><li>atom-material-syntax-light</li><li>atom-material-ui</li><li>atom-minimap-plus</li><li>atom-quick-highlight</li><li>atom-script</li><li>atom-simplified-chinese-menu</li><li>busy-signal</li><li>color-picker</li><li>emmet-atom</li><li>file-icons</li><li>intentions</li><li>linter</li><li>linter-gcc</li><li>linter-javac</li><li>linter-jshint</li><li>linter-markdown</li><li>linter-phpcs</li><li>linter-pylint</li><li>linter-ui-default</li><li>markdown-preview-enhanced</li><li>monoid-ui</li><li>monoid-syntax</li><li>seti-syntax</li><li>seti-ui</li></ul><h4 id="CLion"><a href="#CLion" class="headerlink" title="CLion"></a>CLion</h4><p>破解获取链接</p><pre><code>http://idea.medeming.com/jets/http://idea.medeming.com/jihuo/</code></pre><h4 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h4><p>主题</p><ul><li>Barfi</li><li>Cobalt</li><li>Github</li><li>Gitlab</li><li>Newsprint</li><li>Night</li><li>PixyII</li><li>Vue Dark</li><li>Vue</li><li>Whitey</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> guide </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Trip to Ubuntu</title>
      <link href="/2020/03/Trip-to-Ubuntu/"/>
      <url>/2020/03/Trip-to-Ubuntu/</url>
      
        <content type="html"><![CDATA[<h2 id="Trip-to-Ubuntu"><a href="#Trip-to-Ubuntu" class="headerlink" title="Trip to Ubuntu"></a>Trip to Ubuntu</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前几天我在Microsoft Store里发现了Ubuntu，它是运行在Windows上的子系统，第一时间我就开始了Ubuntu的配置探索之旅。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>我在Microsoft Store安装之后，发现它是装在C盘系统盘的，为了节省C盘空间，我采取了转移到非系统盘的方式</p><p>通过安装，我定位到了它的安装路径</p><pre><code>C:\Users\xxxx\AppData\Local\Packages\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc</code></pre><p>接着，我将它卸载，通过创建软链接来解决这个问题</p><p>先在想要安装的位置创建了Ubuntu文件夹</p><p>然后打开<code>cmd</code>终端，输入</p><pre><code class="bash">mklink /j C:\Users\XXXX\AppData\Local\Packages\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc  D:\Ubuntu\</code></pre><p>创建成功后，再重新在Microsoft Store中安装Ubuntu</p><p>安装过程中如果出现了安装失败的问题，可以运行</p><pre><code class="bash">icacls D:\Ubuntu /grant &quot;用户名:(OI)(CI)(F)&quot;</code></pre><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h4 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h4><p>清华源</p><ul><li>网址：<a href="https://link.zhihu.com/?target=https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/">https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/</a></li><li>源地址：<a href="https://link.zhihu.com/?target=https://mirrors.tuna.tsinghua.edu.cn/ubuntu/">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a></li></ul><pre><code># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse# 预发布软件源，不建议启用# deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</code></pre><p>阿里源</p><ul><li>网址：<a href="https://link.zhihu.com/?target=https://opsx.alibaba.com/guide?lang=zh-CN&document=69a2341e-801e-11e8-8b5a-00163e04cdbb">https://opsx.alibaba.com/guide?lang=zh-CN&document=69a2341e-801e-11e8-8b5a-00163e04cdbb</a></li><li>源地址：<a href="https://link.zhihu.com/?target=http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a></li></ul><pre><code># 默认注释了源码仓库，如有需要可自行取消注释deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse# deb-src https://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse# deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse# deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse# deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse# 预发布软件源，不建议启用# deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse# deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</code></pre><p>中科大源</p><ul><li>网址：<a href="https://link.zhihu.com/?target=http://mirrors.ustc.edu.cn/help/ubuntu.html">http://mirrors.ustc.edu.cn/help/ubuntu.html</a></li><li>源地址：<a href="https://link.zhihu.com/?target=https://mirrors.ustc.edu.cn/ubuntu/">https://mirrors.ustc.edu.cn/ubuntu/</a></li></ul><pre><code># 默认注释了源码仓库，如有需要可自行取消注释deb https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse# deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse# deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse# deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse# deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse# 预发布软件源，不建议启用# deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse# deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</code></pre><p>网易源</p><ul><li>网址：<a href="https://link.zhihu.com/?target=http://mirrors.163.com/.help/ubuntu.html">http://mirrors.163.com/.help/ubuntu.html</a></li><li>源地址：<a href="https://link.zhihu.com/?target=http://mirrors.163.com/">http://mirrors.163.com</a></li></ul><pre><code># 默认注释了源码仓库，如有需要可自行取消注释deb http://mirrors.163.com/ubuntu/ bionic main restricted universe multiverse# deb-src https://mirrors.163.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiverse# deb-src http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiverse# deb-src http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiverse# deb-src http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiverse# 预发布软件源，不建议启用# deb http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiverse# deb-src http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiverse</code></pre><p>先对系统给的镜像源进行备份，以防止出现问题</p><pre><code class="bash">$ sudo cp /etc/apt/sources.list /etc/apt/sources.list.backup </code></pre><p>然后，修改数据源配置文件</p><pre><code class="bash">$ sudo vim /etc/apt/sources.list</code></pre><p>选择一个源添加到文件最前面或直接将官方的源注释掉替换掉原文件</p><p>更新软件源中的所有软件列表：</p><pre><code class="bash">$ sudo apt-get update</code></pre><p>更新软件：</p><pre><code class="bash">$ sudo apt-get upgrade</code></pre><p>更新系统版本：</p><pre><code class="bash">$ sudo apt-get dist-upgrade</code></pre><p>下载中文语言包：</p><pre><code class="bash">$ sudo apt-get install language-pack-zh-han*</code></pre><h4 id="安装-C-x2F-C-开发环境"><a href="#安装-C-x2F-C-开发环境" class="headerlink" title="安装 C&#x2F;C++ 开发环境"></a>安装 C&#x2F;C++ 开发环境</h4><p>安装编译工具包：</p><pre><code class="bash">$ sudo apt-get install build-essential</code></pre><p>安装 nginx 依赖库：</p><pre><code class="bash">$ sudo apt-get install libpcre3 libpcre3-dev libpcrecpp0 libssl-dev zlib1g-dev</code></pre><h4 id="图形界面"><a href="#图形界面" class="headerlink" title="图形界面"></a>图形界面</h4><p>首先安装使用VcXsrv Windows X Server</p><p>启动Launcher，首次启动自动进入界面设置后，选择：“one large window”，Display number设置成0，其它默认即可：</p><p><strong>安装桌面环境</strong></p><pre><code class="bash">sudo apt-get install ubuntu-desktop unity compizconfig-settings-manager</code></pre><p>启动之前安装的X-Windows，在Bash中执行如下命令：</p><pre><code class="bash">export  DISPLAY=localhost:0ccsm</code></pre><p><strong>启动compiz (打开桌面)</strong></p><pre><code class="bash">compiz</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>first blog</title>
      <link href="/2020/02/first-blog/"/>
      <url>/2020/02/first-blog/</url>
      
        <content type="html"><![CDATA[<h2 id="这是我的第一条blog"><a href="#这是我的第一条blog" class="headerlink" title="这是我的第一条blog"></a>这是我的第一条blog</h2><p>今天我捣鼓着使用 hexo + Github 的方式搭建了自己的博客，从今天开始维护，希望自己能坚持下去。</p><p>加油鸭！！！</p>]]></content>
      
      
      
        <tags>
            
            <tag> first blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
