<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>When I learn C</title>
      <link href="/2023/01/25/When-I-learn-C/"/>
      <url>/2023/01/25/When-I-learn-C/</url>
      
        <content type="html"><![CDATA[<h1 id="HERE-IS-NOTE-FOR-Head-First-C-😃"><a href="#HERE-IS-NOTE-FOR-Head-First-C-😃" class="headerlink" title="HERE IS NOTE FOR Head First C 😃"></a>HERE IS NOTE FOR <em>Head First C</em> 😃</h1><p><strong>0 关于</strong></p><p>这里是符号说明，形如</p><ul><li>这是一条个人笔记</li></ul><blockquote><p>这是小拓展</p></blockquote><h2 id="1-入门"><a href="#1-入门" class="headerlink" title="1 入门"></a>1 入门</h2><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p><code>gcc -o</code> 设置文件名</p><p><code>./name</code> 类Unix操作系统中运行程序必须指定程序所在的目录，除非该程序目录已在PATH环境变量中</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>C不支持现成的字符串</p><p>定义字符串数组需额外加一个字符的空间来容纳<code>/0</code>（NULL字符），字符的索引值为偏移量</p><p>单引号通常用来表示单个字符，而双引号通常用来表示字符串。通常应该用双引号来定义字符串。用双引号定义的字符串叫字符串字面值（string literal），比起字符数组，它输入起来也更方便</p><p>总线错误（bus error）意味着程序无法更新那一块存储器空间</p><h3 id="等号"><a href="#等号" class="headerlink" title="等号"></a>等号</h3><p><code>num = 1</code> 等号用来赋值（assignment）</p><p><code>num == 1</code> 检查值是否相等</p><p><code>nunm += 2 or num -= 2</code> 加减2</p><p><code>num++ or num--</code> 加减1</p><h3 id="布尔运算"><a href="#布尔运算" class="headerlink" title="布尔运算"></a>布尔运算</h3><p><code>&amp;&amp; || !</code> 与或非</p><p><code>&amp;</code>和<code>|</code>操作符总是计算两个条件，而<code>&amp;&amp;</code>和<code>||</code>可以跳过第二个条件</p><p>位运算 <code>6 &amp; 4</code> 等于4</p><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>switch语句检查一个单独的值。计算机会在第一个匹配的case语句处开始执行代码。在遇到break或到达switch语句的末尾前，代码会一直运行。</p><pre><code class="c">switch(train) &#123;case 37:    winnings = winnings + 50;    break;case 65:    puts(&quot;头等奖!&quot;);    winnings = winnings + 80;//执行完这条接着再+20这条，直到breakcase 12:    winnings = winnings + 20;    break;default:    winnings = 0;&#125;</code></pre><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><pre><code class="c">int counter;for (counter = 1; counter &lt; 11; counter++) &#123;//(初始化循环变量；循环运行前检查；循环后执行)    printf(&quot;%i个枣\n&quot;, counter);&#125;</code></pre><p>可以用<code>break</code>在任意时刻退出循环</p><p>可以用<code>continue</code>随时跳到循环条件处</p><h3 id="链式赋值"><a href="#链式赋值" class="headerlink" title="链式赋值"></a>链式赋值</h3><p><code>x = y = 4;</code>给多个变量赋相同值</p><h2 id="2-指针"><a href="#2-指针" class="headerlink" title="2 指针"></a>2 指针</h2><p>使用指针的主要目的之一就是让函数共享存储器，指针只是一个保存存储器地址的变量，它们是进程存储器中真实编号的地址</p><h3 id="储存器"><a href="#储存器" class="headerlink" title="储存器"></a>储存器</h3><p>局部变量保存在栈（Stack），全局变量保存在全局量区（Globals）</p><p><code>&amp;x</code>指x的地址 <code>%p</code>来格式化输出</p><blockquote><p>栈<br>这是存储器用来保存局部变量的部分。每当调用函数，函数的所有局部变量都在栈上创建。它之所以叫栈是因为它看起来就像堆积而成的栈板：当进入函数时，变量会放到栈顶；离开函数时，把变量从栈顶拿走。奇怪的是，栈做起事来颠三倒四，它从存储器的顶部开始，向下增长。</p><p>堆<br>堆用于动态存储：程序在运行时创建一些数据，然后使用很长一段时间。</p><p>全局量<br>全局量位于所有函数之外，并对所有函数可见。程序一开始运行时就会创建全局量，可以修改它们，不像常量。</p><p>常量<br>常量也在程序一开始运行时创建，但它们保存在只读存储器中。常量是一些在程序中要用到的不变量，你不会想修改它们的值，例如字符串字面值。</p><p>代码<br>最后是代码段，很多操作系统都把代码放在存储器地址的低位。代码段也是只读的，它是存储器中用来加载机器代码的部分。</p></blockquote><h3 id="int"><a href="#int" class="headerlink" title="int *"></a>int *</h3><p><code>int *address_of_x = &amp;x;</code></p><p><code>*</code>来解引用，如<code>int value_stored = *address_of_x;</code> 、<code>*address_of_x = 99;</code></p><h3 id="sizeof（）"><a href="#sizeof（）" class="headerlink" title="sizeof（）"></a>sizeof（）</h3><p>这是个运算符</p><pre><code class="c">sizeof(int);sizeof(&quot;Turtles!&quot;);//返回9</code></pre><h3 id="数组变量"><a href="#数组变量" class="headerlink" title="数组变量"></a>数组变量</h3><p>数组变量可以被用作指针，指向数组中的第一个元素。函数参数声明如为数组，则其会被当作指针处理</p><p>计算机不会为数组变量分配任何空间，编译器仅在出现它的地方把它替换成数组的起始地址，所以不能把它指向任何其他地方</p><blockquote><p>指针退化</p><p>假如把数组赋给指针变量，指针变量只会包含数组的地址信息，而对数组的长度一无所知，相当于指针丢失了一些信息，也就是指针退化。</p><p>只要把数组传递给函数，数组免不了退化为指针，但需要记清楚代码中有哪些地方发生过数组退化，因为它们会引发一些不易察觉的错误。</p></blockquote><pre><code class="c">int drinks[] = &#123;4, 2, 3&#125;;//drinks[i] == *(drinks + i)doses[3] == *(doses + 3) == *(3 + doses) == 3[doses]</code></pre><h3 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h3><p>指针之所以有类型，是因为编译器在指针算术运算时需要知道加几</p><p>如<code>int nums[] = &#123;1, 2, 3&#125;;</code>中<code>nums</code>与<code>nums+1</code>的地址间隔4个字节（如果int通常占4个字节）</p><ul><li>这里的数组内的每一个值都是int类型，都占4字节</li></ul><h3 id="scanf-vs-fgets"><a href="#scanf-vs-fgets" class="headerlink" title="scanf() vs fgets()"></a>scanf() vs fgets()</h3><p><code>scanf()</code>会导致缓冲区溢出,引发段错误（abort trap）,应限制<code>scanf()</code>读取字符串的长度</p><p><code>scanf()</code>不但允许输入多个字段，而且允许输入结构化数据，可以指定两个字段之间以什么字符分割</p><p>当<code>scanf()</code>用<code>%s</code>读取字符串时，遇到空格就会停止。如果想要输入多个单词，需要多次调用<code>scanf()</code>，或使用一些复杂的正则表达式技巧</p><p><code>fgets(char指针，sizeof(char指针),stdin)</code> stdin表示数据来自键盘</p><p><code>fgets()</code>缓冲区大小把<code>\0</code>字符也算了进去，所以不必像<code>scanf()</code>那样把长度减1</p><p>如果要向<code>fgets()</code>函数传递数组变量，就用<code>sizeof</code>，如果只是传指针，就应该输入想要的长度。</p><p><code>fgets()</code>只允许向缓冲区中输入一个字符串，而且只能是字符串，不能是其他数据类型，只能有一个缓冲区</p><p><code>fgets()</code>总能读取整个字符串</p><p><strong>Conclusion</strong>:如果需要输入由多个字段构成的结构化数据，可以使用<code>scanf()</code>；而如果想要输入一个非结构化的字符串，<code>fgets()</code>将是不二之选</p><h3 id="cards-还是-cards"><a href="#cards-还是-cards" class="headerlink" title="cards[ ]还是*cards"></a>cards[ ]还是*cards</h3><p>字符串字面值保存在只读存储器中。如果想要修改字符串，需要在新的数组中创建副本。可以将char指针声明成为<code>const char *</code>，以防代码用它修改字符串</p><h2 id="2-5-字符串原理"><a href="#2-5-字符串原理" class="headerlink" title="2.5 字符串原理"></a>2.5 字符串原理</h2><h3 id="创建数组的数组"><a href="#创建数组的数组" class="headerlink" title="创建数组的数组"></a>创建数组的数组</h3><pre><code class="c">char tracks[][80] = &#123;//第一对方括号用来访问由所有字符串组成的数组                              //第二对方括号用来访问每个单独的字符串    &quot;I left my heart in Harvard Med School&quot;,    &quot;Newark, Newark - a wonderful town&quot;,    &quot;Dancing with a Dork&quot;,    &quot;From here to maternity&quot;,    &quot;The girl from Iwo Jima&quot;,&#125;;</code></pre><p>可以用<code>char strings[...][...]</code>来创建数组的数组。<br>第一组方括号用来访问外层数组<br>第二组方括号用来访问每个内层数组中的元素</p><h3 id="使用string-h"><a href="#使用string-h" class="headerlink" title="使用string.h"></a>使用string.h</h3><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;string.h&gt;strcmp()可以比较字符串strchr()用来在字符串中找到某个字符的位置strlen()可以得到字符串的长度strcpy()可以复制字符串</code></pre><p>使用以上代码引用头文件</p><h3 id="使用strstr（）"><a href="#使用strstr（）" class="headerlink" title="使用strstr（）"></a>使用strstr（）</h3><pre><code class="c">char s0[] = &quot;dysfunctional&quot;;char s1[] = &quot;fun&quot;;if (strstr(s0, s1))    puts(&quot;我在dysfunctional中找到fun了!&quot;);</code></pre><blockquote><p>全局变量位于任何函数之外，所有函数都可以调用它们。</p></blockquote><h3 id="指针的数组"><a href="#指针的数组" class="headerlink" title="指针的数组"></a>指针的数组</h3><pre><code class="c">char *names_for_dog[] = &#123;&quot;Bowser&quot;, &quot;Bonza&quot;, &quot;Snodgrass&quot;&#125;;//可以像访问数组的数组那样访问指针的数组,一个字符串字面值配一个指针</code></pre><h2 id="3-小工具"><a href="#3-小工具" class="headerlink" title="3 小工具"></a>3 小工具</h2><p>小工具设计遵循以下原则：</p><ul><li>从标准输入读取数据</li><li>在标准输出显示数据</li><li>处理文本数据，而不是难以阅读的二进制格式</li><li>只做一件简单的事</li><li>如果想完成一个不同的任务，应该另外写一个小工具</li><li>小工具通常读写文本数据</li></ul><h3 id="过滤器（filter）"><a href="#过滤器（filter）" class="headerlink" title="过滤器（filter）"></a>过滤器（filter）</h3><p>这是一种小工具，它逐行读取数据，对数据进行处理，再把数据写到某个地方。如果你的计算机是Unix，或你在Windows上安装了Cygwin，就已经拥有很多过滤器工具了。</p><blockquote><p>head：显示文件前几行的内容<br>tail：显示文件最后几行的内容<br>sed：流编辑器（stream editor），用来搜索和替换文本</p></blockquote><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>可以重定向标准输入、标准输出，让程序从键盘以外的地方读数据、往显示器以外的地方写数据，如文件。可用命令</p><pre><code class="bash">$ ./geo2json &lt; gpsdata.csv &gt; output.json</code></pre><h3 id="错误状态码"><a href="#错误状态码" class="headerlink" title="错误状态码"></a>错误状态码</h3><p>程序在数据中发现错误就会退出，并把退出状态置为2。怎么在程序结束后检查错误状态呢？</p><p>要看操作系统</p><p>如果你的计算机是Mac、Linux、其他UNIX，或你在Windows上使用Cygwin，可以用以下命令显示错误状态：</p><pre><code class="bash">$ echo $?</code></pre><p>如果用的是Windows的命令提示符，则可以输入：</p><pre><code class="bash">C:\&gt; echo %ERRORLEVEL%</code></pre><p>这两条命令做了相同的事：显示程序结束时返回的那个数字。</p><h3 id="标准错误"><a href="#标准错误" class="headerlink" title="标准错误"></a>标准错误</h3><p>标准错误——一个用来发送错误消息的二号输出</p><p>人有两只耳朵和一张嘴，但进程有一只耳朵（标准输入）和两张嘴（标准输出和标准错误）</p><h3 id="fprintf-打印到数据流"><a href="#fprintf-打印到数据流" class="headerlink" title="fprintf()打印到数据流"></a>fprintf()打印到数据流</h3><p>printf()函数可以将数据发送到标准输出，但printf()只是fprintf()一个的特例</p><p>scanf()  fscanf(stdin, …)</p><pre><code class="c">printf(&quot;我喜欢乌龟！&quot;);fprintf(stdout, &quot;我喜欢乌龟！&quot;);//以上命令等价</code></pre><p>stdout 标准输出</p><p>stderr  标准错误</p><p>stdin 标准输入</p><p><code>&gt;</code>重定向标准输出<code>&lt;</code>重定向标准输入<code>2&gt;</code>重定向标准错误</p><h3 id="用管道连接输入与输出"><a href="#用管道连接输入与输出" class="headerlink" title="用管道连接输入与输出"></a>用管道连接输入与输出</h3><p>符号 | 表示管道（pipe），它能连接一个进程的标准输出与另一个进程的标准输入</p><p><code>bermuda | geo2json</code></p><pre><code class="bash">&gt; (./bermuda | ./geo2json) &lt; spooky.csv &gt; output.json</code></pre><p>只要在每个程序前加上一个<code>|</code>就可以连接多个程序，一连串相连的进程就叫流水线（pipeline），这时<code>&lt;</code>会把文件内容发送到流水线中第一个进程的标准输入，<code>&gt;</code>会捕获流水线中最后一个进程的标准输出</p><p>外面的括号是必需的,这对括号保证了数据文件由bermuda程序的标准输入来读取</p><h3 id="创建自己的数据流"><a href="#创建自己的数据流" class="headerlink" title="创建自己的数据流"></a>创建自己的数据流</h3><p>每条数据流用一个指向文件的指针来表示，可以用<code>fopen()</code>函数创建新数据流</p><pre><code class="c">FILE *in_file = fopen(&quot;input.txt&quot;, &quot;r&quot;);//将创建一条数据流，从文件中读取数据FILE *out_file = fopen(&quot;output.txt&quot;, &quot;w&quot;);//将创建一条数据流，向文件写数据</code></pre><p>fopen()函数接收两个参数：文件名和模式。共有三种模式</p><p>“w”&#x3D; 写（write）写文件<br>“r”&#x3D; 读（read）读文件<br>“a”&#x3D; 追加（append）在文件末尾追加数据</p><p>创建数据流后，可以用fprintf()往数据流中打印数据<br>可以用fscanf()函数从文件中读取数据</p><pre><code class="c">fprintf(out_file, &quot;%s 和 %s &quot;, &quot;红 &quot;, &quot;绿&quot;);fscanf(in_file, &quot;%79[^\n]\n&quot;, sentence);</code></pre><p>最当用完数据流，别忘了关闭它。虽然所有的数据流在程序结束后都会自动关闭，但你仍应该自己关闭它们</p><pre><code class="c">fclose(in_file);fclose(out_file);</code></pre><p>通常情况下，一个进程最多可以有256条数据流。但数据流的数量是有限的，用完后应该关闭它们。</p><p>最早FILE是用宏定义的，而宏的名字通常都要大写。</p><h3 id="首选项"><a href="#首选项" class="headerlink" title="首选项"></a>首选项</h3><p>对GUI程序来说，可以修改程序的首选项；而对于categorize这样的命令行程序，可以传给它命令行参数</p><pre><code class="c">int main(int argc, char *argv[])&#123;.... 做事情....&#125;</code></pre><p>main()函数有两个版本，一个有命令行参数，一个没有。命令行参数通过两个变量传递给main()函数，一个是参数的计数（argc），另一个是指针（指向参数字符串）数组</p><p>用户运行程序时，命令行中第一个参数是程序名。也就是说，第一个命令行参数其实是argv[1]</p><pre><code class="bash">&gt;./categorize mermaid mermaid.csv Elvis elvises.csv the_rest.csv   argv[0] argv[1]...argv[5]</code></pre><p>在程序中打开文件准备读写时，最好检查一下有没有错误发生。好在如果数据流打开失败，fopen()函数会返回0，也就是说如果想检查错误，可以将下面这段代码：</p><pre><code class="c">FILE *in = fopen(&quot;我不存在.txt&quot;, &quot;r&quot;);</code></pre><p>改成这样：</p><pre><code class="c">FILE *in;if (!(in = fopen(&quot;我不存在.txt&quot;, &quot;r&quot;))) &#123;    fprintf(stderr, &quot;无法打开文件.\n&quot;);    return 1;&#125;</code></pre><h3 id="使用库-getopt"><a href="#使用库-getopt" class="headerlink" title="使用库 getopt()"></a>使用库 getopt()</h3><p>unistd.h头文件不属于C标准库，而是POSIX库中的一员。POSIX的目标是创建一套能够在所有主流操作系统上使用的函数。</p><p>getop()使用范例</p><pre><code class="bash">&gt; rocket_to -e 4 -a Brasilia Tokyo London</code></pre><pre><code class="c">#include &lt;unistd.h&gt;...while ((ch = getopt(argc, argv, &quot;ae:&quot;)) != EOF)//ae:告诉getopt()函数“a和e是有效选项”，e后面的冒号表示“-e后面需要再跟一个参数”，getopt()会用optarg变量指向这个参数    switch(ch) &#123;    ...    case &#39;e&#39;:        engine_count = optarg;    ...    &#125;argc -= optind;//最后这两行用来跳过已读取的选项argv += optind;//optind保存了“getopt()函数从命令行读取了几个选项”</code></pre><p>经过一番处理，0号参数不再是程序名了。argv[0]会指向选项后的第一个命令行参数。循环结束以后，为了让程序读取命令行参数，需要调整一下argv和argc变量，跳过所有选项。</p><pre><code class="bash">&gt; rocket_to -e 4 -a Brasilia  Tokyo   London                    argv[0]  argv[1]  argv[2]</code></pre><p>Tips：</p><ul><li>可以多个选项<code>abc:d</code></li><li>可以合并命令行里的选项，如：<code>-td now</code> 与 <code>-d now -t</code></li><li>可以改变选项之间顺序，因为我们用循环读取选项，所以 <code>-d now -t</code>、<code>-t -d now</code>、<code>-td now</code>都一样(</li><li>只要程序在命令行看到一个前缀为－值，就会把它当成选项处理，前提是它必须在命令行参数之前出现</li><li>为了避免歧义，可以用<code>--</code>隔开参数和选项，比如<code>set_temper-ature -c -- -4</code>。getopt()看到<code>--</code>就会停止读取选项，程序会把后面的内容当成普通的命令行参数读取</li></ul><h2 id="4-使用多个源文件"><a href="#4-使用多个源文件" class="headerlink" title="4 使用多个源文件"></a>4 使用多个源文件</h2><h3 id="简明数据类型指南"><a href="#简明数据类型指南" class="headerlink" title="简明数据类型指南"></a>简明数据类型指南</h3><ul><li>char<br>字符在计算机的存储器中以字符编码的形式保存，字符编码是一个数字，因此在计算机看来，A与数字65完全一样（ASCII码）</li><li>int<br>如果你要保存一个整数，通常可以使用int。不同计算机中int的大小不同，但至少应该有16位。一般而言，int可以保存几万以内的数字</li><li>long<br>但如果想保存一个很大的计数呢？long数据类型就是为此而生的。在某些计算机中，long的大小是int的两倍，所以可以保存几十亿以内的数字；但大部分计算机的long和int一样大，因为在这些计算机中int本身就很大。long至少应该有32位</li><li>float<br>float是保存浮点数的基本数据类型。平时你会碰到很多浮点数，比如一杯香橙摩卡冰乐有多少毫升，就可以用float保存</li><li>double<br>但如果想表示很精确的浮点数呢？如果想让计算结果精确到小数点以后很多位，可以使用double。double比float多占一倍空间，可以保存更大、更精确的数字</li></ul><blockquote><p>为什么把一个很大的数保存到short中会变成负数？</p><p>数字以二进制保存，二进制的100 000看起来像这样：<br>x &lt;- 0001 1000 0110 1010 0000<br>当计算机想把这个值保存到short时，发现只能保存2个字节，所以只保存了数字右半边：<br>y &lt;- 1000 0110 1010 0000<br>最高位是1的二进制有符号数会被当成负数处理，它等价于下面的十进制数：<br>-31072</p></blockquote><h3 id="使用类型转换临时转换数值的类型"><a href="#使用类型转换临时转换数值的类型" class="headerlink" title="使用类型转换临时转换数值的类型"></a>使用类型转换临时转换数值的类型</h3><pre><code class="c">int x = 7;int y = 2;//float z = (float)x / (float)y;float z = (float)x / y//如果编译器发现有整数在加、减、乘、除浮点数，会自动完成转换，因此可以减少代码中显式类型转换的次数：printf(&quot;z = %f\n&quot;, z);</code></pre><h3 id="两个关键字"><a href="#两个关键字" class="headerlink" title="两个关键字"></a>两个关键字</h3><p>unsigned<br>用unsigned修饰的数值只能是非负数。由于无需记录负数，无符号数有更多的位可以使用，因此它可以保存更大的数。unsigned int可以保存0到最大值的数。这个最大值是int可以保存最大值的两倍左右。还有signed关键字，但你几乎从没见过，因为所有数据类型默认都是有符号的。<br><code>unsigned char c;</code></p><p>long<br>没错，你可以在数据类型前加long，让它变长。longint是加长版的int；long int可以保存范围更广的数字；long long比long更长；还可以对浮点数用long。(c99和c11支持long long)<br><code>long double d;</code></p><blockquote><p>%.2f把浮点数格式化为小数点后两位</p><p>%hi用来格式化short</p></blockquote><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;limits.h&gt; //含有表示整型（比如int和char）大小的值#include &lt;float.h&gt; //含有表示float和double类型大小的值int main()&#123;printf(&quot;The value of INT_MAX is %i\n&quot;, INT_MAX);printf(&quot;The value of INT_MIN is %i\n&quot;, INT_MIN);printf(&quot;An int takes %z bytes\n&quot;, sizeof(int));printf(&quot;The value of FLT_MAX is %f\n&quot;, FLT_MAX);printf(&quot;The value of FLT_MIN is %.50f\n&quot;, FLT_MIN);printf(&quot;A float takes %z bytes\n&quot;, sizeof(float));    //可把INT和FLT替换成CHAR（char）、DBL（double）、SHRT（short）或LNG（long）return 0;&#125;</code></pre><blockquote><p>位数是计算机能够处理的数值长度</p></blockquote><h3 id="声明与定义分离"><a href="#声明与定义分离" class="headerlink" title="声明与定义分离"></a>声明与定义分离</h3><p><code>float add_with_tax()(float f);</code></p><p>声明只是一个函数签名：一条包含函数名、形参类型与返回类型的记录</p><h3 id="创建头文件"><a href="#创建头文件" class="headerlink" title="创建头文件"></a>创建头文件</h3><p>两步</p><ol><li>创建一个扩展名为.h的文件，把你的声明写在里面，不用在头文件中包含main()函数，反正也没有函数会调用它</li><li>在主代码中包含头文件，应该在代码的顶部加一句include</li></ol><p><code>#include &#39;asdf.h&#39;</code> <code>#include &lt;stdio.h&gt;</code></p><p>通常情况下，引号表示以相对路径查找头文件，如果不加目录名，只包含一个文件名，编译器就会在当前目录下查找头文件；如果用了尖括号，编译器就会以绝对路径查找头文件</p><p>当编译器看到尖括号，就会到标准库代码所在目录查找头文件，但现在你的头文件和.c文件在同一目录下，用引号把文件名括起来，编译器就会在本地查找文件。本地头文件也可以带目录名，但通常会把它和C文件放在相同目录中。</p><p>当编译器在代码中读到#include，就会读取头文件中的内容，仿佛它们本来就在代码中。</p><blockquote><p>如果编译器发现你调用了一个它没见过的函数，就会假设这个函数返回int</p></blockquote><h3 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h3><table><thead><tr><th align="center">1</th><th align="center">2</th><th align="center">3</th></tr></thead><tbody><tr><td align="center">auto</td><td align="center">if</td><td align="center">break</td></tr><tr><td align="center">int</td><td align="center">case</td><td align="center">long</td></tr><tr><td align="center">char</td><td align="center">register</td><td align="center">continue</td></tr><tr><td align="center">return</td><td align="center">default</td><td align="center">short</td></tr><tr><td align="center">do</td><td align="center">sizeof</td><td align="center">double</td></tr><tr><td align="center">static</td><td align="center">else</td><td align="center">struct</td></tr><tr><td align="center">entry</td><td align="center">switch</td><td align="center">extern</td></tr><tr><td align="center">typeof</td><td align="center">float</td><td align="center">union</td></tr><tr><td align="center">for</td><td align="center">unsigned</td><td align="center">goto</td></tr><tr><td align="center">while</td><td align="center">enum</td><td align="center">void</td></tr><tr><td align="center">const</td><td align="center">signed</td><td align="center">volatile</td></tr></tbody></table><h3 id="共享代码"><a href="#共享代码" class="headerlink" title="共享代码"></a>共享代码</h3><p>为了共享代码，可以把代码放到一个单独的C文件中。<br>需要把函数声明放到一个单独的.h头文件中。<br>在所有需要使用共享代码的C文件中包含这个头文件。<br>在编译的命令中列出所有C文件。</p><pre><code class="c">//encrypt.hvoid encrypt(char *message);</code></pre><pre><code class="c">//encrypt.c#include &quot;encrypt.h&quot;void encrypt(char *message)&#123;    char c;    while (*message) &#123;    *message = *message ^ 31;    message++;    &#125;&#125;</code></pre><pre><code class="c">//mainprog.c#include &lt;stdio.h&gt;#include &quot;encrypt.h&quot;int main()&#123;    char msg[80];    while (fgets(msg, 80, stdin)) &#123;    encrypt(msg);    printf(&quot;%s&quot;, msg);    &#125;&#125;</code></pre><pre><code class="bash">./ gcc message_hider.c encrypt.c -o message_hider</code></pre><blockquote><p>共享变量<br>为了防止两个源文件中的同名变量相互干扰，变量的作用域仅限于某个文件内。如果你想共享变量，就应该在头文件中声明，并在变量名前加上extern关键字：<br><code>extern int passcode;</code></p></blockquote><h3 id="gccの编译"><a href="#gccの编译" class="headerlink" title="gccの编译"></a>gccの编译</h3><p>gcc -c会编译代码，但不会链接目标文件</p><pre><code class="bash">./ gcc -c *.c</code></pre><p>gcc -o 链接，在例子中把目标文件链接为一个叫launch的可执行程序</p><pre><code class="bash">./ gcc *.o -o launch</code></pre><h3 id="Make"><a href="#Make" class="headerlink" title="Make"></a>Make</h3><p>如果你掌握了某样东西的简单规则，别多想，自动化它</p><p>make编译的文件叫目标（target）。目标可以是任何用其他文件生成的文件，也就是说目标可以是一批文件压缩而成的压缩文档</p><p>make需要知道：依赖项、生成方法。依赖项和生成方法合在一起构成了一条规则。有了规则，make就知道如何生成目标</p><blockquote><p>versions :</p><p>UNIX make</p><p>MinGW mingw32-make</p><p>Microsoft  NMAKE</p></blockquote><p>makefile文件书写</p><pre><code class="makefile">launch.o: launch.c launch.h thruster.h//目标：依赖项    gcc -c launch.c//生成方法（必须以tab开头）                                            //这是规则thruster.o: thruster.h thruster.c    gcc -c thruster.claunch: launch.o thruster.o    gcc launch.o thruster.o -o launch</code></pre><p>之后直接</p><pre><code class="bash">./ make launch</code></pre><blockquote><p>更自动化的工具：autoconf</p></blockquote><p>-&gt; <a href="http://tinyurl.com/yczmjx">GUN Make Manual</a></p><h2 id="5-结构、联合与位字段"><a href="#5-结构、联合与位字段" class="headerlink" title="5 结构、联合与位字段"></a>5 结构、联合与位字段</h2><h3 id="结构-Struct"><a href="#结构-Struct" class="headerlink" title="结构 Struct"></a>结构 Struct</h3><p>结构化数据结构 structured data type</p><p>结构是一种由一系列其他数据类型组成的数据类型。</p><pre><code class="c">struct fish &#123;    const char *name;    const char *species;    int teeth;    int age;&#125;;</code></pre><p>创建一个新自定义的数据类型，由其它一批数据组成。</p><ul><li>结构的大小固定</li><li>结构中的数据都有名字</li></ul><p>创建数据：</p><pre><code class="c">struct fish snappy = &#123;&quot;Snappy&quot;, &quot;Piranha&quot;, 69, 4&#125;</code></pre><p>把参数封装在结构中，代码会更稳定</p><p>结构变量是结构本身的名字</p><p>读取时只能按名访问，使用“.”运算符读取结构字段：&lt;结构&gt;.&lt;字段名&gt;语法（也叫“点表示法”）</p><pre><code class="c">struct fish snappy = &#123;&quot;Snappy&quot;, &quot;piranha&quot;, 69, 4&#125;;printf(&quot;Name = %s\n&quot;, snappy.name);</code></pre><p>为结构变量赋值相当于叫计算机复制数据</p><h3 id="结构中的结构"><a href="#结构中的结构" class="headerlink" title="结构中的结构"></a>结构中的结构</h3><p>为什么要嵌套定义结构？</p><p>之所以要这么做是为了对抗复杂性 。通过使用结构，我们可以建立更大的数据块。通过把结构组合在一起，我们可以创建更大的数据结构。本来你只能用int、short，但有了结构以后，就可以描述十分复杂的东西，比如网络流和视频图像。</p><pre><code class="c">struct preferences &#123;    const char *food;    float exercise_hours;&#125;;struct fish &#123;    const char *name;    const char *species;    int teeth;    int age;    struct preferences care; //nesting 嵌套   struct fish snappy = &#123;&quot;Snappy&quot;, &quot;Piranha&quot;, 69, 4, &#123;&quot;Meat&quot;, 7.5&#125;&#125;;   printf(&quot;Snappy 喜欢吃 %s&quot;, snappy.care.food);    printf(&quot;Snappy 喜欢锻炼 %f hours&quot;, snappy.care.exercise_hours); //访问&#125;;</code></pre><h3 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h3><p>在C语言中可以为结构创建别名，你只要在struct关键字前加上typedef，并在右花括号后写上类型名，就可以在任何地方使用这种新类型。</p><pre><code class="c">typedef struct cell_phone &#123;    int cell_no;    const char *wallpaper;    float minutes_of_charge;&#125; phone;</code></pre><p>当你用typedef为结构创建别名，需要决定别名叫什么。别名其实就是类型名，也就是说结构有两个名字：一个是结构名（struct cell_phone），另一个是类型名（phone）。为什么要有两个名字？一般一个就够了。如果只写类型名而不写结构名，编译器也没意见：</p><pre><code class="c">typedef struct &#123;    int cell_no;    const char *wallpaper;    float minutes_of_charge;&#125; phone;phone p = &#123;5557879, &quot;s.png&quot;, 1.35&#125;;</code></pre><p>这样的结构称为匿名结构。</p><h3 id="更新结构"><a href="#更新结构" class="headerlink" title="更新结构"></a>更新结构</h3><pre><code class="c">fish snappy = &#123;&quot;Snappy&quot;, &quot;piranha&quot;, 69, 4&#125;;printf(&quot;Hello %s\n&quot;, snappy.name);snappy.teeth = 68;</code></pre><p>计算机通过把值赋给函数形参的方式向函数传值，所有赋值都会复制</p><p>如果想让函数更新结构变量，就不能把结构作为参数传递，因为这样做仅仅是将数据的副本复制给<br>了函数。取而代之，可以传递结构的地址</p><p>还有一种表示结构指针的方法，它更易于阅读。</p><p><code>(*t).age</code> 和 <code>t-&gt;age</code> 等价</p><p>“指针-&gt;字段”等于“(*指针).字段”“-&gt;”表示法省掉了括号，代码更易阅读。</p><h3 id="联合？"><a href="#联合？" class="headerlink" title="联合？"></a>联合？</h3><p>每次创建结构实例，计算机都会在存储器中相继摆放字段</p><p>联合则不同。当定义联合时，计算机只为其中一个字段分配空间，并且计算机会为其中最大的字段分配空间，然后由你决定里面保存什么值</p><blockquote><p>计算机需要保证联合的大小固定。唯一的办法就是让它足够大，任何一个字段都能装得下</p></blockquote><pre><code class="c">typedef union &#123;//这里的关键字是union    short count;    float weight;    float volume;&#125; quantity;</code></pre><h3 id="使用联合"><a href="#使用联合" class="headerlink" title="使用联合"></a>使用联合</h3><ul><li><p>C89 方式</p><p>把值赋给联合中第一个字段</p><pre><code class="c">quantity q = &#123;4&#125;;</code></pre></li><li><p>指定初始化器（designated initializer）</p><pre><code class="c">quantity q = &#123; .weight = 1.5 &#125;;</code></pre></li><li><p>点 表示法</p><p>在第一行创建变量，然后在第二行设置字段的值</p><pre><code class="c">quantity q;q.volume = 3.7;</code></pre></li></ul><p>无论用哪种方法设置联合的值，都只会保存一条数据。联合只是提供了一种创建支持不同数据类型的变量的方法</p><p>“指定初始化器”也可以用来设置结构字段的初值，并提高代码的可读性</p><pre><code class="c">typedef struct &#123;    const char *color;    int gears;    int height;&#125; bike;bike b = &#123;.height=17, .gears=21&#125;;</code></pre><h3 id="联合与结构"><a href="#联合与结构" class="headerlink" title="联合与结构"></a>联合与结构</h3><pre><code class="c">typedef struct &#123;    const char *name ;    const char *country;    quantity amount;&#125; fruit_order;fruit_order apples = &#123;&quot;apples&quot;,&quot;English&quot;,.amount.weight = 4.2&#125;printf(&quot;This order contains %2.2f lbs of %s\n&quot;,apples.amount.weight, apples.name);</code></pre><h3 id="枚举变量保存符号"><a href="#枚举变量保存符号" class="headerlink" title="枚举变量保存符号"></a>枚举变量保存符号</h3><p>你需要某种方法记录我们在联合中保存了什么值。</p><p>结构与联合用分号（;）来分割数据项，而枚举用逗号。</p><pre><code class="c">enum colors &#123;RED, GREEN, PUCE&#125;;//可以用typedef为类型起个名字enum colors favorite = PUCE;</code></pre><p><em><strong>so？枚举好处？？？</strong></em> 限制我能给的值？ 实例感受下：</p><pre><code class="c">typedef enum &#123;    COUNT,    POUNDS,    PINTS&#125;unit_of_measure;typedef struct &#123;    const char *name;    const char *country;    quantity amount;    unit_of_measure units;&#125;fruit_order;void display(fruit_order order) &#123;    printf(&quot;This order contains &quot;);    if (order.units==PINTS) printf(&quot;%2.2f pints of %s\n&quot;, order.amount.volume, order.name);    else if (order.units==POUNDS) printf(&quot;%2.2f lbs of %s\n&quot;, order.amount.weight, order.name);    else printf(&quot;%i %s\n&quot;, order.amount.count, order.name);&#125;int main() &#123;    fruit_order strawberries= &#123;        &quot;strawberries&quot;,        &quot;Spain&quot;,        .amount.weight=17.6,        POUNDS    &#125;;    display(strawberries);    return 0;&#125;</code></pre><h3 id="位字段（bitfield）"><a href="#位字段（bitfield）" class="headerlink" title="位字段（bitfield）"></a>位字段（bitfield）</h3><p>C语言不支持二进制字面值，不过它支持十六进制字面值。每当C语言看到0x开头的数字，就认为它是以16为基数的数字（0x54）</p><p>可以用位字段指定一个字段有多少位</p><pre><code class="c">typedef struct &#123;    unsigned int low_pass_vcf:1;//位字段应当声明为unsigned int    unsigned int filter_coupler:1;//表示该字段只使用1位存储空间    unsigned int reverb:1;    unsigned int sequential:4;    ...&#125; synth;</code></pre><p>如果你有一连串的位字段，计算机会放在一起，以节省空间，也就是说如果有8个1位的位字段，计算机就会把它们保存在一个字节中</p><p>如果编译器发现结构中只有一个位字段，还是会把它填充成一个字，这就是为什么位字段总是组合在一起</p><h2 id="6-数据结构与动态存储"><a href="#6-数据结构与动态存储" class="headerlink" title="6 数据结构与动态存储"></a>6 数据结构与动态存储</h2><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>保存可变数量的数据，插入数据非常快</p><p>链表是一种抽象数据结构。链表是通用的，可以用来保存很多不同类型的数据</p><p>链表保存了一条数据和一个链向另一条数据的链接</p><p>如果一个结构包含一个链向同种结构的链接，那么这个结构就被称为递归结构</p><p>只要在结构中保存指针，island数据就含有下一个我们将游览的island的地址。只要我们的代码能访问一个island，就能够跳到下一个island。</p><p>在递归结构中，需要包含一个相同类型的指针， C语言的语法不允许用typedef别名来声明它，因此必须为结构起一个名字</p><pre><code class="c">typedef struct island &#123;char *name;char *opens;char *closes;struct island *next;&#125; island;island amity = &#123;&quot;Amity&quot;, &quot;09:00&quot;, &quot;17:00&quot;, NULL&#125;;island craggy = &#123;&quot;Craggy&quot;, &quot;09:00&quot;, &quot;17:00&quot;, NULL&#125;;island isla_nublar = &#123;&quot;Isla Nublar&quot;, &quot;09:00&quot;, &quot;17:00&quot;, NULL&#125;;island shutter = &#123;&quot;Shutter&quot;, &quot;09:00&quot;, &quot;17:00&quot;, NULL&#125;;amity.next = &amp;craggy;craggy.next = &amp;isla_nublar;isla_nublar.next = &amp;shutter;\\插入数据island skull = &#123;&quot;Skull&quot;, &quot;09:00&quot;, &quot;17:00&quot;, NULL&#125;;isla_nublar.next = &amp;skull;skull.next = &amp;shutter;void display(island *start)&#123;    island *i = start;    for(; i != NULL; i = i-&gt;next)&#123;    printf(&quot;Name:%s\n open:%s-%s\n&quot;,i-&gt;name,i-&gt;open,i-&gt;closes);            &#125;&#125;</code></pre><p>在C语言中，NULL的值实际上为0，NULL专门用来把某个指针设为0。</p><p>想快速地插入数据，就需要<strong>链表</strong>。想直接访问元素，就应该用<strong>数组</strong></p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>栈是存储器用来保存局部变量的区域。数据保存在局部变量中，一旦离开函数，变量就会消失。堆是程序中用来保存长期使用数据的地方。堆上的数据不会自动清除，因此堆是保存数据结构的绝佳场所</p><h3 id="malloc-与-free"><a href="#malloc-与-free" class="headerlink" title="malloc() 与 free()"></a>malloc() 与 free()</h3><p><code>malloc()</code>，memory allocation 申请储存器。接收一个参数：所需要的字节数。常与<code>sizeof</code>一起使用。<code>sizeof</code>告知某种数据类型在系统中占了多少字节。这种数据类型可以是结构，也可以是int或double这样的基本数据类型。返回一个指针，指针中保存了存储器块的起始地址。<code>free()</code>需要接收<code>malloc()</code>创建的存储器的地址。只要告诉C标准库存储器块从哪里开始，它就能查阅记录，知道要释放多少存储器。</p><pre><code class="c"># include &lt;stdlib.h&gt;//使用malloc()和free()需要包含这个头文件malloc(sizeof(island));island *p = malloc(sizeof(island));//返回的通用指针，即void*类型free(p);</code></pre><p>虽然程序结束以后，所有堆空间会自动释放，但用free()显式释放创建的所有动态存储器是一种好的做法</p><h3 id="字符串复制"><a href="#字符串复制" class="headerlink" title="字符串复制"></a>字符串复制</h3><p><code>string.h</code>的头文件中有一个函数<code>strdup()</code>。它可以把字符串复制到堆上</p><pre><code class="c">char *s = &quot;MONA LISA&quot;char *copy = strdup(s);</code></pre><p>作用机理为： 计算出字符串的长度，然后调用malloc()函数在堆上分配相应的空间。再把所有字符复制到堆上的新空间。</p><p>strdup()总是在堆上创建空间，而不是在栈上，因为栈用来保存局部变量，而局部变量很快就会被清除。</p><p>并且因为strdup()把新字符串放在堆上，所以千万记得要用free()函数释放空间。</p><p>有了动态分配存储器，就能在运行时创建需要的存储器。使用malloc()与free()，可以访问动态堆存储器。</p><h3 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h3><p>一些语言会跟踪程序在堆上分配的数据，当程序不再使用这些数据时，就会释放它们。</p><p>C语言非常古老，发明它的时候，绝大多数语言都没有自动 “垃圾回收”机制。</p><p>操作系统会在程序结束时清除所有存储器。不过，还是应该显式释放你创建的每样东西，这是一种好的习惯。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>一些举例：</p><ul><li>关联数组（也叫映射）<ul><li>连接“键”（key）信息与“值”（value）信息。可以用来连接两种不同类型的数据。</li></ul></li><li>双向链表<ul><li>和普通链表很像，但双向连接，可以双向处理。</li></ul></li><li>链表<ul><li>可以用来保存一串数据项，并使插入新数据项变得简单，但只能沿着一个方向处理。</li></ul></li><li>二叉树<ul><li>每一项都与其他两项相连，可以用来保存层次信息。</li></ul></li></ul><h3 id="valgrind"><a href="#valgrind" class="headerlink" title="valgrind"></a>valgrind</h3><p>valgrind通过伪造malloc()可以监控分配在堆上的数据。当程序想分配堆存储器时，valgrind将会拦截对malloc()和free()的调用，然后运行自己的malloc()和free()。valgrind<br>的malloc()会记录调用它的是哪段代码和分配了哪段存储器。程序结束时，valgrind会汇报堆上有哪些数据，并告诉这些数据是由哪段代码创建的。</p><p>调试信息是编译时打包到可执行文件中的附加数据，比如某段代码在源文件中的行号。只要有调试信息，valgrind就能提供更多有助于发现存储器泄漏的信息。</p><p>为了在可执行文件中加入调试信息，需要加上-g开关，并重新编译源代码。</p><pre><code class="bash">$ gcc -g spies.c -o spies// -g 开关告诉编译器要记录要编译代码的行号</code></pre><p>存储器泄漏是C程序中最难发现的错误。</p><p>valgrind工具可以发现泄漏、定位泄漏、检验泄漏是否修复</p><h2 id="7-高级函数"><a href="#7-高级函数" class="headerlink" title="7 高级函数"></a>7 高级函数</h2><h3 id="向函数传递函数"><a href="#向函数传递函数" class="headerlink" title="向函数传递函数"></a>向函数传递函数</h3><pre><code class="c">int sports_no_bieber(char *s)&#123;    return strstr(s, &quot;sports&quot;) &amp;&amp; !strstr(s, &quot;bieber&quot;);&#125;void find(int(*match)(char*))&#123;    int i;    puts(&quot;Search results:&quot;);    puts(&quot;------------------------------------&quot;);    for (i = 0; i &lt; NUM_ADS; i++) &#123;        if (match(ADS[i])) &#123;            printf(&quot;%s\n&quot;, ADS[i]);        &#125;    &#125;    puts(&quot;------------------------------------&quot;);&#125;find(sports_no_bieber);</code></pre><p>函数名是指向函数的指针，创建函数的同时也创建了一个同名函数指针，指针中保存了函数的地址，当调用函数时，你在使用函数指针。</p><blockquote><p>两者并不完全相同，函数名是L-value，而指针变量是R-value，因此函数名不能像指针变量那样自加或自减。</p></blockquote><p>函数有不同的返回类型和形参，所以它有许多不同的类型，没有<code>function*</code>的说法。</p><h3 id="创建函数指针"><a href="#创建函数指针" class="headerlink" title="创建函数指针"></a>创建函数指针</h3><p>需要把函数的返回类型和接收参数类型告诉C编译器。</p><pre><code class="c">int (*warp_fn)(int);warp_fn = go_to_warp_speed;//创建一个叫warp_fn的变量，用来保存go_to_warp_speed()函数的地址。相当于调go_to_warp_speed(4)warp_fn(4);char** (*names_fn)(char*,int);names_fn = album_names;//创建一个叫names_fn的变量，用来保存album_names()函数的地址。char** results = names_fn(&quot;Sacha Distel&quot;, 1972);</code></pre><p>一旦声明了函数指针变量，就可以像其他变量一样使用它，可以对它赋值，也可以把它加到数组中，还可以把它传给函数</p><blockquote><p>char**是一个指针，通常用来指向字符串数组</p></blockquote><p>函数指针是C语言最强大的特性之一</p><pre><code class="c">char** (*names_fn)(char*,int)返回类型       指针变量    参数类型            在这里声明形参的名称</code></pre><blockquote><p><code>match(ADS[i])</code>可以换成<code>(*match)(ADS[i])</code></p><p><code>find(sports_or_workout)</code>可以写成<code>find(&amp;sports_or_workout)</code></p><p>即使省略*和&amp;，C编译器也能识别它们，这样代码更好读</p></blockquote><h3 id="排序qsort"><a href="#排序qsort" class="headerlink" title="排序qsort()"></a>排序qsort()</h3><blockquote><p>void指针(void *)可以保存任何类型数据的地址，但使用前必须把它转换为具体类型</p></blockquote><pre><code class="c">qsort(void *array, size_t length, size_t item_size, int (*compar)(const void *, const void *));//qsort(数组指针，数组长度，数组中每个元素长度，比较器函数指针（参数）)</code></pre><p>比较器会返回给qsort()三种值</p><p>如果第一个值比第二个值大，就返回正数；如果第一个值比第二个值小，就返回负数；如果两个值相等，就返回0</p><pre><code class="c">int compare_scores(const void* score_a, const void* score_b)&#123;    int a = *(int*)score_a;    int b = *(int*)score_b;//这样将void指针转换为整型指针        ...&#125;</code></pre><p>字符串是字符指针，指向字符串的指针是指针的指针（绕口令哈哈哈）</p><pre><code class="c">int compare_names(const void* a, const void* b)&#123;    char** sa = (char**)a;    char** sb = (char**)b;    return strcmp(*sa, *sb); //需要用*来取得字符串&#125;</code></pre><h3 id="创建函数指针数组"><a href="#创建函数指针数组" class="headerlink" title="创建函数指针数组"></a>创建函数指针数组</h3><p>如果想在数组中保存函数，就必须告诉编译器函数的具体特征：函数返回什么类型以及接收什么参数</p><pre><code class="c">void (*replies[])(response) = &#123;dump, second_chance, marriage&#125;;//返回类型（*指针变量）（参数类型）</code></pre><blockquote><p>C语言在创建枚举时会给每个符号分配一个从0开始的数字</p></blockquote><p>函数指针数组让代码易于管理，它们让代码变得更短、更易于扩展，从而可以伸缩</p><h3 id="可变参数函数"><a href="#可变参数函数" class="headerlink" title="可变参数函数"></a>可变参数函数</h3><p>参数数量可变的函数被称为可变参数函数。C标准库<code>stdarg.h</code>中有一组宏（macro）可以帮助建立可变参数函数</p><blockquote><p>可以把宏想象成一种特殊类型的函数，它可以修改源代码</p></blockquote><pre><code class="c">\\打印一连串int函数#include &lt;stdarg.h&gt;void print_ints(int args, ...)&#123;\\在C语言中，函数参数后的省略号“…”表示还有更多参数    va_list ap;\\保存传给函数的其他参数    va_start(ap, args);    \\需要把最后一个普通参数写明(至少需要一个普通参数)    int i;    for (i = 0; i &lt; args; i++) &#123;        printf(&quot;argument: %i\n&quot;, va_arg(ap, int));\\用va_arg读取保存在va_list中的参数    &#125;    va_end(ap);   \\当读完了所有参数，要用va_end宏来让C结束&#125;</code></pre><blockquote><p>va_arg接收两个值：va_list和要读取参数的类型。本例中所有参数都是int</p><p>宏用来在编译前重写代码，这里的几个宏<code>va_start</code>、<code>va_arg</code>和<code>va_end</code>看起来很像函数，但实际上隐藏在它们背后的是一些神秘的指令。在编译前，预处理器会根据这些指令在程序中插入巧妙的代码</p></blockquote><ul><li>va_arg 会返回下一个额外参数，那么一定要搭配循环遍历吗？🤔</li></ul><h2 id="8-静态库与动态库"><a href="#8-静态库与动态库" class="headerlink" title="8 静态库与动态库"></a>8 静态库与动态库</h2><h3 id="库文件引用"><a href="#库文件引用" class="headerlink" title="库文件引用"></a>库文件引用</h3><p>&lt;stdio.h&gt;尖括号代表标准头文件，编译器就会在标准头文件目录中查找文件</p><p>“encrypt.h”引号代表本地头文件，与程序在同一目录中</p><blockquote><p>通常类UNIX操作系统（如Mac或Linux）中，编译器会在以下目录查找头文件：<br>&#x2F;usr&#x2F;local&#x2F;include<br>&#x2F;usr&#x2F;include</p><p>如果是MinGW版的gcc，编译器会在\MinGW\include中查找</p></blockquote><h3 id="共享代码-1"><a href="#共享代码-1" class="headerlink" title="共享代码"></a>共享代码</h3><p>会希望在程序之间共享两类代码：.h头文件和.o目标文件</p><h4 id="h头文件"><a href="#h头文件" class="headerlink" title=".h头文件"></a>.h头文件</h4><ol><li><p>把头文件保存在标准目录中</p><p>可以在源代码中用尖括号包含它们</p></li><li><p>在include语句中使用完整路径名</p><pre><code class="c"># include &quot;/my_header_files/encrypt.h&quot;</code></pre></li><li><p>告诉编译器去哪找头文件</p><p>可以使用gcc的<code>-I</code>选项</p><pre><code class="bash">$ gcc -I/my_header_files test_code.c  ...   -o test_code</code></pre></li></ol><p>编译器会先检查<code>-I</code>选项中的目录，然后像往常一样检查所有标准目录</p><h4 id="o目标文件"><a href="#o目标文件" class="headerlink" title=".o目标文件"></a>.o目标文件</h4><p>可以把.o目标文件放在一个类似共享目录的地方，用完整路径名共享</p><pre><code class="bash">$ gcc -I/my_header_files test_code.c       /my_object_files/encrypt.o       /my_object_files/checksum.o -o test_code</code></pre><h4 id="存档"><a href="#存档" class="headerlink" title="存档"></a>存档</h4><p>把一批目标文件打包在一起就成了存档文件。只要创建目标文件存档，就可以一次告诉编译器一<br>批目标文件</p><p>可以使用<code>nm</code>命令查看存档中的内容，列出存档中保存文件的名字</p><p>可以使用<code>ar</code>命令来存档</p><pre><code class="bash">$ ar -rcs libhfsecurity.a encrypt.o checksum.o</code></pre><p>参数r表示如果.a文件存在就更新它，参数c表示创建存档时不显示反馈信息，参数s表示需要ar在.a文件开头建立索引。接着是.a文件的文件名，以及需要存档的文件</p><p>所有.a文件名都是libXXX.a的形式。这是命名存档的标准方式，存档是静态库（static library），所以要以lib开头，否则编译器找不到它们</p><p>接着可以把存档保存在库目录中，并不同情况下进行编译</p><ol><li><p>把.a文件保存在标准目录中，如&#x2F;usr&#x2F;local&#x2F;lib</p><p>确保代码能正确运行之后会把存档安装在标准目录，这个目录专门用来放本地自定义库</p><p>用-I开关编译代码</p><pre><code class="bash">$ gcc test_code.c -lhfsecurity -o test_code</code></pre></li><li><p>把.a文件放在其他目录中</p><p>如果还处于开发阶段，或者在系统目录中安装代码不合适，也可以创建自己的库目录<code>/my_lib</code></p><p>用-L选项告诉编译器去哪找存档</p><pre><code class="bash">$ gcc test_code.c -L/my_lib -lhfsecurity -o test_code</code></pre></li></ol><p>如果要使用多个存档，可以设置多个-l选项，<code>hfsecurity</code>叫编译器去找一个叫<code>libhfsecurity.a</code>的存档，-l选<br>项后的名字必须与存档名的一部分匹配，如果存档叫libawesome.a，可以用-lawesome开关编译程序</p><blockquote><p>不同机器库目录的内容可以相差很多。因为不同操作系统提供了不同的服务。每个.a文件都是一个独立的库，有的库用来连接网络，有的用来创建GUI程序</p><p>找几个.a文件来试用一下nm命令。每个模块都列出了很多名字，它们是一些已经编译好了的函数，可以在程序中使用它们：0000000000000000 T _yywrap，T代表文本(Text)，说明这是一个函数，函数名为yywrap</p><p>nm命令会告诉你每个.o目标文件的名字，然后列出所有目标文件中的名字，如果某个名字前出现了T，就说明它是目标文件中某个函数的名字</p></blockquote><h3 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h3><p>带有元信息的可重定位目标文件，由一个或多个.o文件创建，核心是一段目标代码</p><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>首先创建目标文件</p><pre><code class="bash">$ gcc -I/includes -fPIC -c hfcal.c -o hfcal.o</code></pre><p><code>-fPIC</code>表示创建位置无关代码。有的操作系统和处理器要用位置无关代码创建库，这样它们才能在运行时决定把代码加载到存储器的哪个位置，事实上在大多数操作系统中都不需要加这个选择</p><blockquote><p><strong>位置无关代码</strong></p><p>位置无关代码就是无论计算机把它加载到存储器的哪个位置都可以运行的代码。想象你有一个动态库，它要使用加载点500个字节以外的某个全局变量的值，那么如果操作系统把库加载到其他地方就会出错。只要让编译器创建位置无关的代码，就可以避免这种问题。<br>包括Windows在内的一些操作系统在加载动态库时会使用一种叫存储器映射的技术，也就是说所有代码其实都是位置无关的。若你在Windows上用刚刚那条命令编译代码，gcc可能会给出一条警告，告诉你不需要-fPIC选项。你既可以奉命删除它，也可以当作没看见。</p></blockquote><p>然后生成动态库</p><p>绝大部分操作系统都支持动态库，它们的工作方式也大抵相同，但称呼却大相径庭</p><p>Windows 动态链接库；Linux和Unix 共享目标文件；Mac 动态库</p><pre><code class="bash">$ gcc -shared hfcal.o -oC:\libs\hfcal.dll//Windows 上的MinGW                       /libs/libhfcal.dll.a   //Windows上的Cygwin                       /libs/libhfcal.so      //Linux或Unix                       /libs/libhfcal.dylib  //Mac</code></pre><p>-shared选项告诉gcc你想把.o目标文件转化为动态库</p><p>编译器创建动态库时会把库的名字保存在文件中，假设你在Linux中创建了一个叫libhfcal.so的库，那么libhfcal.so文件就会记住它的库名叫hfcal。也就是说，一旦你用某个名字编译了库，就不能再修改文件名了。若想重命名库，就必须用新的名字重新编译一次</p><blockquote><p>在一些古老的Mac系统中没有-shared 选项，但是可以用-dynamiclib代替</p></blockquote><p>最后编译程序</p><p>一旦创建了动态库，你就可以像静态库那样使用它</p><pre><code class="bash">$ gcc -I/include -c elliptical.c -o elliptical.o$ gcc elliptical.o -L/libs -lhfcal -o elliptical</code></pre><blockquote><p>在MinGW和Cygwin上，库名的格式有很多种，hfcal的库名可以是: libhfcal.dll.a、libhfcal.dll、hfcal.dll</p></blockquote><p>尽管使用的命令和静态存档一模一样，但两者编译的方式不同。因为库是动态的，所以编译器不会在可执行文件中包含库代码，而是插入一段用来查找库的“占位符”代码，并在运行时链接库</p><p>可以运行程序了</p><p>Mac可以直接运行当你在Mac中编译程序时，文件的完整路径&#x2F;libs&#x2F;libhfcal.dylib保存在可执行文件中，程序启动时知道去哪里找它</p><p>在Linux和大部分Unix中，编译器只会记录libhfcal.so库的文件名，而不会包含路径名。也就是说如果不把hfcal库保存到标准目录（如&#x2F;usr&#x2F;lib），程序就找不到它。为了解决这个问题，Linux会检查保存在LD_LIBRARY_PATH变量中的附加目录。只要把库目录添加到LD_LIBRARY_PATH中，并export它，elliptical就能找到libhfcal.so</p><pre><code class="bash">&gt; export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/libs</code></pre><p>Windows同Linux一样，它的可执行文件也只保存hfcal库的名字，不保存目录名。不过Windows没有用LD_LIBRARY_PATH变量去找hfcal库。Windows程序会先在当前目录下查找，如果没找到就去查找保存在PATH变量中的目录</p><pre><code class="bash">//CygwinPATH=&quot;$PATH:/libs&quot;//MinGWPATH=&quot;%PATH%:C:\libs&quot;</code></pre><p>在Linux和Mac中，动态库通常保存在&#x2F;usr&#x2F;lib或&#x2F;usr&#x2F;local&#x2F;lib中；而在Windows中，程序员通常把.DLL和可执行文件保存在同一个目录下</p><ul><li>动态库在修改库文件后不用再重新编译项目文件</li></ul><p>有了动态库，就能在运行时替换代码。不用重新编译程序，你就能修改它。如果你有很多程序，它们共享一段相同的代码，通过建立动态库，就可以同时更新所有程序</p><h2 id="9-进程与系统调用"><a href="#9-进程与系统调用" class="headerlink" title="9 进程与系统调用"></a>9 进程与系统调用</h2><p>C程序无论做什么事都要靠操作系统。如果它想与硬件打交道，就要进行系统调用。系统调用是操作系统内核中的函数，C标准库中大部分代码都依赖于它们</p><h3 id="system"><a href="#system" class="headerlink" title="system()"></a>system()</h3><p>接收一个字符串参数，并把它当作命令执行</p><pre><code class="c">system(&quot;dir D:&quot;);//打印D盘内容system(&quot;gedit&quot;);       //在Linux中启动编辑器system(&quot;say &#39;End of Line&#39; &quot;);//在Mac上朗读文本</code></pre><p>在一些操作系统中，系统调用的代码位于操作系统内核。而对其他操作系统而言，系统调用可能保存在动态库中</p><blockquote><p><strong>内核</strong>？</p><p>在大部分计算机上，系统调用就是操作系统内核中的函数。什么是内核？虽然你从来没在屏幕上看到过它，但内核其实一直都在那里控制计算机。内核是计算机中最重要的程序，它主管三样东西：<br>    进程<br>只有当内核把程序加载到存储器时程序才能运行。内核创建进程，并确保它们得到了所需资源。内核同时也会留意那些变得贪得无厌或者已经崩溃的进程。<br>    存储器<br>计算机所能提供的存储器资源是有限的，因此内核必须小心翼翼地分配每个进程所能使用的存储器大小。内核还能把部分存储器交换到磁盘从而增加虚拟存储器空间。<br>    硬件<br>内核利用设备驱动与连接到计算机上的设备交互。你的程序在不了解键盘、屏幕和图形处理器的情况下就能使用它们，因为内核会代表你与它们交涉。系统调用是程序用来与内核对话的函数。</p></blockquote><h3 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h3><p>进程是存储器中运行的程序。操作系统用一个数字来标识进程，它叫进程标识符（process identifier，简称PID）</p><p>exec()函数通过运行其他程序来替换当前进程。你可以告诉exec()函数要使用哪些命令行参数和环境变量。新程序启动后PID和老程序一样。</p><p>exec()函数在unistd.h中，它版本众多，但可以分为列表函数和数组函数。</p><h4 id="列表函数"><a href="#列表函数" class="headerlink" title="列表函数"></a>列表函数</h4><p>execl()、execlp()、execle()</p><p>列表函数以参数列表的形式接收命令行参数：</p><ol><li><p>程序</p><p>告诉exec()函数将运行什么程序。对execl()或execle()来说，它是程序的完整路径名；对execlp()来讲就是命令的名字，execlp()会根据它去查找程序</p></li><li><p>命令行参数</p><p>需要依次列出想使用的命令行参数。别忘了，第一个命令行参数必须是程序名，也就是说列表版exec()的前两个参数是相同字符串</p><blockquote><p><strong>命令行参数之间的空格会把MinGW弄糊涂</strong></p><p>如果把“I like”和“turles”这两个参数传给exec()，MinGW程序可能会发送三个参数：“I”、“like”和“turtle”。</p></blockquote></li><li><p>NULL</p><p>需要在最后一个命令行参数后加上NULL，告诉函数没有其他参数了</p></li><li><p>环境变量（如果有的话）</p><p>如果调用了以 …e() 结尾的 exec() 函数，还可以传递环境变量数组，像”POWER&#x3D;4”,”PORT&#x3D;OPEN”……那样的字符数组</p></li></ol><pre><code class="c">execl(&quot;/home/flynn/clu&quot;, &quot;/home/flynn/clu&quot;, &quot;paranoids&quot;, &quot;contract&quot;, NULL)//execL = 参数列表(List)execlp(&quot;clu&quot;, &quot;clu&quot;, &quot;paranoids&quot;, &quot;contract&quot;, NULL)//execLP = 参数列表（List） + 在PATH中查找程序execle(&quot;/home/flynn/clu&quot;, &quot;/home/flynn/clu&quot;, &quot;paranoids&quot;, &quot;contract&quot;, NULL, env_vars)//execLE = 参数列表（List） + 环境变量（Environment）</code></pre><h4 id="数组函数"><a href="#数组函数" class="headerlink" title="数组函数"></a>数组函数</h4><p>execv()、execvp()、execve()</p><p>如果已经把命令行参数保存在了数组中，就会发现这两个版本用起来更容易</p><pre><code class="c">execv(&quot;/home/flynn/clu&quot;, my_args);//execV=参数数组或参数向量（Vector）execvp(&quot;clu&quot;, my_args);//execVP = 参数数组/向量（Vector） + 在PATH中查找//参数需要保存在字符串数组my_args中//以上两函数唯一区别是execvp会用PATH变量查找程序</code></pre><table><thead><tr><th>使用</th><th>字符</th></tr></thead><tbody><tr><td>参数列表</td><td>l</td></tr><tr><td>参数数组&#x2F;向量</td><td>v</td></tr><tr><td>根据PATH查找</td><td>p</td></tr><tr><td>环境变量</td><td>e</td></tr></tbody></table><p>l、v总是在p、e之前出现；p、e是可选的</p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>每个进程都有一组环境变量。你可以在命令行中输入set或env查看它们的值，它们一般会告诉进程一些有用的信息，比如用户主目录的位置，或去哪里找命令。C程序可以用getenv()系统调用读取环境变量</p><p>可以用字符串指针数组的形式创建一组环境变量。环境变量的格式是“变量名&#x3D;值”。数组最后一项必须是NULL</p><pre><code class="c">char *my_env[] = &#123;&quot;JUICE=peach and apple&quot;, NULL&#125;;execle(&quot;diner_info&quot;, &quot;diner_info&quot;, &quot;4&quot;, NULL, my_env);</code></pre><blockquote><p><strong>在Cygwin中传递环境变量时一定要包含PATH变量</strong></p><p>在Cygwin中，加载程序时需要用PATH变量，因此在Cygwin上传递环境变量时一定要包含PATH&#x3D;&#x2F;usr&#x2F;bin</p></blockquote><h3 id="系统调用错误"><a href="#系统调用错误" class="headerlink" title="系统调用错误"></a>系统调用错误</h3><p>如果在调用程序时发生错误，当前进程会继续运行，于是可以向用户报告错误信息</p><pre><code class="c">execle(&quot;diner_info&quot;, &quot;diner_info&quot;, &quot;4&quot;, NULL, my_env);puts(&quot;哥们，diner_info程序肯定发生了什么问题&quot;);</code></pre><p>所有的系统调用都遵循“失败黄金法则”</p><ol><li>尽可能收拾残局</li><li>把errno变量设为错误码</li><li>返回-1</li></ol><p>errno变量是定义在errno.h中的全局变量，还一并定义了许多标准错误码</p><table><thead><tr><th>标准错误码</th><th>错误消息</th></tr></thead><tbody><tr><td>EPERM&#x3D;1</td><td>不允许操作</td></tr><tr><td>ENOENT&#x3D;2</td><td>没有该文件或目录</td></tr><tr><td>ESRCH&#x3D;3</td><td>没有该进程</td></tr></tbody></table><p>可以拿errno和这些值比较，也可以用string.h中的<code>strerror()</code>的函数查询标准错误消息</p><pre><code class="c">puts(strerror(errno));//strerror()将错误码转换为一条消息</code></pre><h3 id="用fork-克隆进程"><a href="#用fork-克隆进程" class="headerlink" title="用fork()克隆进程"></a>用fork()克隆进程</h3><p>exec() 是程序中最后一行代码</p><p>fork()会克隆当前进程。新建副本将从同一行开始运行相同程序，变量和变量中的值完全一样，只有进程标识符（PID）和原进程不同。原进程叫父进程，而新建副本叫子进程</p><blockquote><p>注意！与Unix和Mac不同，**Windows天生不支持fork()**，如果想在Windows中使用fork()，必须先要安装Cygwin</p><p>Windows有一个<code>Create-Process()</code>函数。它是一个加强版的system()</p><p>此处<a href="https://learn.microsoft.com/en-us/windows/win32/procthread/creating-processes">官方文档</a></p></blockquote><p>用fork()+exec()运行子进程，在子进程中调用exec()函数，这样原来的父进程就能继续运行了</p><p>复制进程后，为区分父子进程，fork()函数向子进程返回0，向父进程返回非零值</p><blockquote><p><strong>fork()</strong></p><p>你可以像这样调用fork()：<code>pid_t pid = fork();</code><br>fork()会返回一个整型值：为子进程返回0，为父进程返回一个正数。父进程将接收到子进程的进程标识符<br>什么是pid_t？不同操作系统用不同的整数类型保存进程ID，有的用short，有的用int，操作系统使用哪种类型，pid_t就设为哪个</p></blockquote><ul><li><p>这样的设计中一般现在要考虑可能出现错误了，可以这样写</p></li><li><p>&#96;&#96;&#96;c<br>pid_t pid &#x3D; fork();<br>if (pid &#x3D;&#x3D; -1) {<br>fprintf(stderr, “Can’t fork process: %s\n”, strerror(errno));<br>return 1;<br>}<br>if (!pid) {<br>  …<br>}</p></li></ul><blockquote><p>在用exec()替换子进程前可以不用等fork()复制完整个进程，操作系统会采用写时复制（copy-on-write）技术等技巧。比如操作系统不会真的复制父进程的数据，而是让父子进程共享数据。如果操作系统发现子进程要修改存储器，就会为它复制一份</p></blockquote><h2 id="10-进程间通信"><a href="#10-进程间通信" class="headerlink" title="10 进程间通信"></a>10 进程间通信</h2><p>在命令行中，重定向是非常有用的命令，也可以让进程重定向自己</p><h3 id="进程内部"><a href="#进程内部" class="headerlink" title="进程内部"></a>进程内部</h3><p>进程含有它正在运行的程序，还有栈和堆数据空间。进程还需要记录数据流的连向，它用文件描述符表示数据流，所谓的描述符其实就是一个数字。进程会把文件描述符和对应的数据流保存在描述符表中（下表仅为示意）描述符表的一列是文件描述符号，另一列是它们对应的数据流</p><table><thead><tr><th>#</th><th>数据流</th></tr></thead><tbody><tr><td>0</td><td>键盘</td></tr><tr><td>1</td><td>屏幕</td></tr><tr><td>2</td><td>屏幕</td></tr><tr><td>3</td><td>数据库连接</td></tr></tbody></table><p>描述符表的前三项万年不变：0号标准输入，1号标准输出，2号标准错误。其他项要么为空，要么连接进程打开的数据流。比如程序在打开文件进行读写时，就会占用其中一项</p><h2 id="11-网络与套接字"><a href="#11-网络与套接字" class="headerlink" title="11 网络与套接字"></a>11 网络与套接字</h2><h2 id="12-线程"><a href="#12-线程" class="headerlink" title="12 线程"></a>12 线程</h2><h2 id="十大遗漏知识点"><a href="#十大遗漏知识点" class="headerlink" title="十大遗漏知识点"></a>十大遗漏知识点</h2><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul><li><p>递增与递减</p><p>++和–的位置决定了表达式返回i的原始值还是新值，前新后旧</p></li><li><p>三目运算符</p><pre><code class="c">if (x == 1)    return 2;else    return 3;return (x == 1) ? 2 : 3;//这里上下等价</code></pre></li><li><p>位运算</p><p>C语言可以用来编写底层代码，为此它提供了一组位运算符：</p><table><thead><tr><th align="center">运算符</th><th>说明</th></tr></thead><tbody><tr><td align="center">~a</td><td>a中所有位都取反</td></tr><tr><td align="center">a &amp; b</td><td>a中的位“与”b中的位</td></tr><tr><td align="center">a | b</td><td>a中的位“或”b中的位</td></tr><tr><td align="center">a ^ b</td><td>a中的位“异或”b中的位</td></tr><tr><td align="center">&lt;&lt;</td><td>位左移（值增加）</td></tr><tr><td align="center">&gt;&gt;</td><td>位右移（值减小）</td></tr></tbody></table><p>&lt;&lt;运算符可以用来快速地将某个整型值乘以2的幂，但小心千万别溢出</p></li><li><p>用逗号分割表达式<br>for循环在每次循环的末尾都会出现递增操作。<br>但如果你想在循环末尾执行多个运算怎么办？可以使用逗号运算符：<br><code>for (i = 0; i &lt; 10; i++, j++)</code> 递增i和j。<br>之所以要有逗号运算符是因为有时你不想用分号来分割表达式</p></li></ul><h3 id="预处理指令"><a href="#预处理指令" class="headerlink" title="预处理指令"></a>预处理指令</h3>]]></content>
      
      
      
        <tags>
            
            <tag> C notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一封新年的信</title>
      <link href="/2023/01/01/LetterToYYY/"/>
      <url>/2023/01/01/LetterToYYY/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Sorry, you aren't her." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="34d310f3dea690e604a6b9079b2dc27dff2567dff8dd41f08c1810ce183acdbf">cb1516b36de741a2b3bbe43b3982941151bd781dfac26e1ae42cb0a497475ef30d0317d3bb0df941088886f08b53b9739d45ce49a4458d97508c1032876a0744d017d3e202ff507c726851df781b127b6dcdc75097a5df6a00936e9b60e2f843d6f6440d2f0b84958da61c485b3a64cf6a309f1a100cdb646d609ae902dd1634a7d0a4ecdd175af4f6f253cb8d3160595a8d3f1e74d3d93ec665bb616353a4d63054fd4b8405c4014afb27c3f01973898dcc1652b2e6fe5e9501ba91ae049737c657ddbb7864e077041bf1dd2e154861eb12abf57f8c34206794bc10ea0ae18c395ed05f89efa74c9788fede833c5923ca7a2c07536d61a6ab7b34da59eb6fea2e34cee4339968a33c1e6ab79a9163f9c7d02e456b3a0d721e4dca2ba8d1fe678c68b66d66b673f0788ab10d15891788f6bc860167153785b527db0fbdf9161b5c54ec06f006fc53fb5b6e8fbae5e384398aca79abd2d6c203f7ce0e2a761cb07fd93c8cd60de42e010cc27aec3a6ad4458af084438a9ff86f3bf887190ff21a63232e494561a72db409e9b20f1e38ffba5a38f5c914cafa20d3a009fcb623eb2d468f1e14318a033acc572aadb003006b0b13b9073c97a1751428b309b0237e5d682d548ba16219ece4cb8a35a79d42a376037769aa2baba78bb5cd607ec9af42cbe32d03963df5682977c9ed70739d59de182dbfd3dc50ae7d5493500e7f8aaa9ebfa629d0e34878e9ddb6a572eb7aebcffda9e1419f2c55fd334f8c66e644e3c431cea4999ebdde4c2f68071f9467e0531fd99104e22cc09f5059c90ca095050f4a679a45dc411b9eb298c3486fe7b9e095c0a5f9d5b202c3718471f40869901d75a69652f88b3dcf244d3cec928df686b7e569c0630224d2f2126d1d29ce3d706fdb4d8a8bd671d496fbc47b1030c3d8aed93a1bcb3ee4aab5b292320e6103c03989876a29194b9fb5e075872aa7b961043d3f0d2505f30ab5e0e515d2b79961340d31cf393ecbc93f315c0448a17b43f82402e6fcdc986307dcdd1b8f463fbca355a8dc0781b5a7db0fe107f8422ea461ada853167697e54824d8b0f7ed502cf1adfba1c86c26f8ffef3bc5f272df19faad434c087126822c85f6be9079e8bc3f983643edf24a60048b7006f0fd69151a8f10398494aed5408fd7f8ace568e76b8c2472d8a79b07e4f3a3bdb1493d303c030695fcd833bdc352fe93ec450f72e90c9268ea47b561ee9a73b54c5e4faa509bb97021128fc3100ebbc711d6f4ae8e6662772739b9edb5dc5f595111f0202fa134bfa26427dc4337b7f2033751094aadc0302e1e1542e0e86abb01213c1ab05b366f6d278ceb88159181193ec139da28defb639f4133632dd3b0413e30d3c04992c70e7f0e99fe4a815b52342cde15f22e857fddc1a77fbb9b436244b198632d759c3308e6c0e181681f9a99600094bed490bfd70412fb17d77664e6eb5343377822d0819ef3e8d364d21e63808e9ec30daad571707b795727eae50f079b238086cf4cdbbdc49a841b41f55592d5e6b22b27b2f36dd770a77d786687a260ac50b3552b9d155d2e7772f46c44a16d38b2ed5418193221a42962acef4302359a966cfda35d001b3a4fb39164cc484776fabefe2899e3108570d7de237c3aa2ba33c0032a3c9ed932fcb12cc22a783b7e25b85d318f5be8134e60a4fb181c89c5c65fa537dd6093d93dcf96ce29004b470b03f01bcb317ade72b599c0a6147175aec970f95e39f7a68bf44c4a14fc719a7e7342d83c147c53ccaf212a86b90f485683b5a3869b45f4678b434914e1cb0475b3f47d63a92f960507c42e52d3966ac15e81e9461f8bf03b262be7848c295ff6929c725465c6928a89018c72f8d4a50945e2850cfe37d252314a185222e62ddc70f5b823012a3d7490950117f37223ffe06ce38ceb7a32d435d49942048fb9dc8616dce7af416d1c6d03f895bd4732f91f19d0bfe1c7d389bd44621a65c6ca9aeabb57547e7d719030ed68b60401fb07e2be257b9292c3b59b4a4187ec0ec495a06426997965eed01e2dc2bf7a16287df48f1f87de7ddb4585c02f12dbd6c332dc345d543a2469e595eaab2fd46b9b58551ec5b3a75a415ad884da46749a8a097bddbe75f5bdc95853b25cb0b407da2fcfc2e3821fad0873c10783e2794bd77f550ecef2010513d940087f49cc284933f003621de13601978ff3a0014a59826ae28a9617adef933bccd571f0ff4f1596e13e533c63640809fce96b67fed464088d37fe092e27809e6f4514dc6507ecb3b5e0e93243af7a1eb76af848f528ee54ccec264aa4b00a0da28cc7c8ec7264143dc97ba5bfe321efd1adb9e8bd9d87d342e3a4cdbf922c2dab3fadf6b0ef2439b18403862a7669e580430d40767651e7a1f3f095e0465ba027f99d9e5aed9f05f5532c770649fedaa42ccbb2fa7e6b3305fc6682d7099bb3f1239bcdc881625b679192e3703477a43d4dd15d5a55741150ffa44f43247dcc2ec2c1d3e5ac05c6941569fe7d7d6fbf1cbb37bd11c287cbb237e239943ba1d63b7fed94a15d07ebb26f373b1218078af2c208d3ee4ac2bdf699b54a3584f1fa9328f66c2ba0d42503f80b01c71b255955ef749ad8a599cbfed7b5495a697df1905ec7c72e2c31c851e5614d921e715b6508fbf5500a62a8a9496ea42c28ea646e9b503201478d889abfda39a956f3eaefd88dcad260d76b3474f43987fd0b333dc072db1492b453e999d77ad38f4c8245f8278b02aea81d853f690c92c5c843240958ca2d9adbf1467673bcd2f85c065b36c6f4927e5200bca291ac3f57621c9cc39c78a445f6df09dbdf11823e97c13f61a1589d66b349d254f73424da278d35b22da5b7bfb7556a6d505f9b360aabb8307b1a6e803f7ead149acec77c42b071ce50a1e57f5c67d6d127cacb0c99716b4c65fcfe99b56ee850f94214d22b108a1bf7c8a8ad01a0a1db731273c11301a973b0a1eb6010236fe289051458bc3669a689235279eda9411940cbe838ed40b1d5aed213f0f4c99d255661a52b5795b9a24d272b4aa9268ef9b6cc41a62ac6498515a8bb68717c7bbc1be17ef73f3b1be1cb4810fc21878410fef8ace37184aceb2c4d9e3212bedd7098fd46451967bbd3005045d09c9dc53240e3a63d6db3c1ad4967eb706beafac5089b654fe6c822718438662a602c91dcbb05f739987bd97c778ee46f53abaab81314e4b3db389cf7fd0bb86f3bd1023f865b12e91a990ee9d2655f730c463256fb1b929e3ff85c52e0c1672442053018df5ef1a552ae997ccd2abe748850069391a6c3683a6aadeb83e336217e6c3d0c4ad819e9eeaead16b2636852a8f5d7aabcef6e9b7dd5c9a037697c901eabfaebcb6b7ccec9293b012b8c6c92a6acfcbe9e69e13c032efa5da6ed130b34fb8405ab1b6a34d2eb99720a4fd15fc7a012c64abe3f70b825368a6ceb89a622d3b653b7bffa4c58d8bbf492d37ebc6516419b112c30f4693a138b7054f5ecaa7680007f0fb55ca5e9cb951210ab240422da5311dc110188123bb0079aabe85726e3e5dba96c0d3955133f83a6e38315584e5cea57df4f7c493c3f887f88f5edb714b620e2e6e7eebe39b3e247ce4bc51fb7015d3593d9815b9c4766e9a98852c126b26ccdc1adf955ad1b1b4a3ca54bfab5aaf17e650f655e83b1cf820c87674e95a632806d99ecc5202b10157411cb18e5a3f6e771b2b2ae176b6ea35311f3f17f0eba2d2e2702d5fb0775cc4d6a0fd28c44c364e6a0eb7a8fbf1ba20127a60f83c9540907ab42cd347517a0ed0249a03d3c9792f747c3db729e4a6405f279fe9d89d848bd15311cef09e6a4d889b265771a7cb0f70f90698a18760b71931f3d18a272f00228cc04ddcae844427fc417a8ae058cac9ab85491b019b286e900c99c031879f311cedb914a7d8b18bee972e246bda51487b919b19a152f9cfed03a904f144aac93847a6e1e10aaea5b3210892431180c0cae7ea362482a78d4d03ba676ee9d3a3bc9ee1bb596808f78b78384df5fa6cfe1b5b9bea2f2e033e0085dbb796a1ca18fcae7108823b73c50b5e4611031fc4cd373f56f1b1ced4efa8070acd053a762b409d19070724367aa4faf3816e677b4af0f818660d9a668bffb0b7314baff12f8d2a408d2d642c4007da4b9ef46b14211050065cbe5a37859c6459e59b659996d3ad2e51c58b6a1b727dc7892dd6b41dc4f32b09fefa2cdabdb2f0c1150d3faedc08fe4e1c447aae15c74c2cda234f32cc21f4243833089d531dd1d36670bc3a8023ba6a7ff9a5a096a1e5033e0061ab49e0c0a3c077960b9ce11f650847989cbdd10af1736ecd1fb080ae77af73201d6d09ed93fbcdb4a6751efd63c830c641650ded40c52f3412e7aefc45a6ea96c2b090aceb535fa3f14f2b2c4e9e11787e47a49480d498acd8494d7ff0dec8c96116b01f8dc59b6111e602f56451bb45def7c39ecc79b13418d4cf09da3123a02d7f8ed366347dfee1876a3f73d0875e8874d2bab31cad79109f58b8b4dda78c7972431da9d511d6e92dcab5a118cd5675d7b2e95fcd842f4c25530131f2200c6749c5ca7ff6c2fc40daff4802a521d112698396cd3ad33a1e117565703cf5b00af83c9957ca68a22bc551676acfa4d7f9f139c1d737efa3bf3908e9648ce2473a9992947bd6879a1046a9932b4dcfabd850e91bd82f707586b99ccf9f0d8f0d28462f4b72471063bea8520b312310ede60461e988268d7317bc1c4d7d90398ffaed91808c2350968b1bc789161eb2956295bffb057fb5f4b89abe161ced5240a20b005dde587212e9d18157860a2742f06bc153c1c393d2efbf1be753ed56a39db4be09281899ef50410e99b158f7bbe03b636fca9dd7713da4635a5a74a41946df00ec450449dd9e0102b696aa871ea67212334d6ef3c033b53005e29ead454873b87eda5de19d7b105cdf4ff2425e8dde28530a4a3cb499dc6805a5ac276ab3c4f7bb6ecff37572f4ac7d62d84a04ebbb97eade6e62a43249b3e664edbe8d77e11102280065bd046bfe2207f52524b231a4d64fc7cbd0c28b7f5a9c1b162d41a35785a1f1635129eec3a0810f7dfafd3d0c8f4e55e728d63ff1f7c4841b4bfc28a2ef8dc44d893aab10602c86138f7ad60f84555455a96cfe729610f63a5f4b00b49afbcd7e98b9b02624955c74c9381604318f16b14b25328510117a52be73a118362d5851d6aad5684ab3a64b1aea469db769cf936fc959099b4f048e72daf9816b5944a380efa248b36e9c5fe4d68f77476c70ca8a52c3584a2302554fc93a1baaacab5a92275249a135c1486b3f5a5a924eacfa8633328e75aaf63c5e7c4e874475e26b64b519962dbfc2fe4adbbe9301fd7e1dc7cd8724f6307b7475cb7c25dfd7e6ec59b395119eee643ff47f0ad14c4381a239f51081ae998f4eb4c0fd255e08ffd7048899bfe512700579c5576a4a5866e58f5f9c7f78883dd0a185297d7969a4de875095cc305e5296e66781473ded683ce9eca315df7c097c4e4ef31ef6a43c0320fcf52fab82cfd6d80426563e484ae546ccb6e677b25aa58f13019b649c8e0130af9669c5b271a0edadf49173d6a90f34fe68de01a0a76e6186d43958f9b1b494b70b7928762453edaa38b8ac8b98d26530a7cce331423018f8dc6b6ed3a82daaa5f8037a1c15f8ac566203979c7171ebfe4a7168f6c4fe0aac11b83b94e61fdd926e6c8a236aa31e079b0c7b6cf9db0768a1377716edf42f0b55b22418e705d38c87b328ce5fb7891f178a642b6b4850fca2c207780803e10ab0dca10af88f72fdc26aa9b1e15591d54c7b74308b7d038ebdc66bac77f1f4919b6dd84c330d577542192bed910bab1ae0d0fbdbad4f47c88436e441c9d163cc3e8541b9a3731f45b00885a6599109653a32cdb73354683a5ed9fd18da60d9cdef335cbaf3d1ebca282159e8412a6ccb066d701adb8e78dd0dca9602e1bc8285c339cd9fa025ad5779d5eae4c95f7738262a142445532d9cb0930ed55f75603bdd79ca13b058e55a69140175b00464db21d5532f770ff5cf2f98b8b7326d25fbfe0240d2e76fda3383f6503ecfd92ec456f29e010ee420c8d8ac4d0525ec66ae240b92538315bafc3722c5f4da4f1b4ec78227d1c953f84783f586877321b13aa97d6017205e857569c6a0ab84a8c79c45539290ca87e1fbdecc22596cc6cb9fa7795acdff296892e86ac8b8ae2db50d34eb8d3535930a89b0bb4853e979d62fdc985c4a07f19e13326772602a3e0b9c02cf7ace224a2b7000ae4bbccfafad028908a3d88e354791308ff5fab47a70946b5896ae37594a3963d0fe1aa7c5b0b71d4062de28f7f74dda51725c289df4038c3becefaf20256971ccf253f7d163cf61b1bd967f35c2822055547a53a10d61546b3e7b0b1288c8bde7da95160fc4810e71d3169895d0e1891473d00c1a409d3b89fb795b6ef668d71e51fd1530b35d16d8232bb9e41afc8066d51668d86d6005550fe0e4583b796bdaecdd52413c24c48bcbdb170467b20e4f938d5ce42643e0332ff004adeae8a48aae3c683050d30605a56a9bf52f04cbff7cffa4248aaf0e9a3031fefb13a81365b10f555fe60ae531694b1bb40ba37f75e33c38c04a960b18580e1ae73d0e23bfabc824e17ceaf642509e862c7eae1ad3e1004bd77fa84bdc72af4965ca72d1ecc9c5fbc2a69a7278da8c0ef57f3d5128deaa628d6fe76fa6c0910526a9b22075d55fa681c4d04bd879088f845c122af0e25fc305e243ef841bddf518bf0bb0e5e33be3a7ce6ba2e60a2fd42b907e177c4d301d91743301fb337db008279a396fd7a37e80a18f0835980e6981bd4982a8ef3c30760deda4c0f533a2245ad5bcf24a8add58a0362f042e875c68056038574029d362bf4fb79221ed48e23cb96231d21e7a90885e52edb7342d62056dc7fb3e91ead0bd233bac919f93291fa4c252a423d34004a034b3b81b64dd45c505df4aae841881d549eb5fdc8015ecd52479375807e9440df75498603d047f1958b6bccb2670cccfb0b3013606aa48bf40caebde7d5bc1f04e0db96cfbb4ea771d5732d77274c305152f246d774522854343077d9996003eba2df0c7149a7fab10e3273f327189bc86c3887813edaf7643be4ffa2be7717e8088d029c3247f6fcd99b230f4303b3bc58f2fb276c9fe193ba2ac8ac2e22c0330f57022f565ac122a04adaf894bf243f4a48c32d2bf183aad77a7eecc7a2e6e39ab42fedea51af20031e78949e414e91e0b0562e23cf9e66e13ae27745084920b9207ed3cb415f76c8a6c35501f78cfc8b9421c1ba3f00f811f1422cdf91cb91ca2dbe4696ba67519d3b7e1aa9ac004a3dd6a9e6ab354716434987b79fa02f85e225e7c27e8b36bd523b7725848e4ff1d7a0921b7525ad7cfa93c0fc7d15a6d7fe2d2f768c44ea16c8df9d6bcd64495cf4a84cd75b800bf3abc1de745efdd53d8abc402225685a99df348087612388bd2f0881c2d11d07c0e8e93ac150d1c87ab88740c1251d66a65e1513f3fe0620aace0346e96b2f9acdc62e9699cd702be08df9c780289e8119bd24c93f78960ad4a17789cd85ebb51206c0b0db5452f92a853e6e9f9f7cc89328eb42f93fd8cf527a1495ba2a0e767d0a7dc7d7a54dce9354dc61e64f19a85e0880a8291c0512a2d658b672071dcaada7fc8b2e23913a406969dc52e4a69ea48b8cd7460fef5e7efc004eb951fa9054f808db2dca00b84ae7fd6b3331ba410e330ad3ef1988ed4f36848e36813660a7144b20dddd6b0ef87fae3d535ab607cefac82992de617210fc1fc08c4db08205395eae6ac0c0572b19da3272404e3318cda8dd2b9d38043e341a5cf59083cca04f16c0ce9f330d473ff539f064f560d80304fd8789dbcd9ee7e7d3020066768d812f1d0eef12341dd2a404be711dc04d4b9f471445cad4444ee7fd09903c554bbe1e41f4d17b0751b8068261d5a061c441644a8018fc2a41efed28a4f45d08c056081b0dae59531800b7407941d4c21713dafec55426c8a8062e44ffa3d4af0925fa1c4d1e0f1d41ec5f62c00566e7d4f91f12550aa01d652cc6eff0acf2612384672f43ad09cf651f5ff14f91f0f130d7b5dc93c2e94a85068b6f8784b7fb9038bf07dfa687aa00bccc331fdf35096e506ae73646a021769888bb9409e3bade61e66811d9f6de42b886e53c1cb9fa98c0693c67dcfc071d81f9b3f10220efb1f34d4378aeb46783d11f3e91d2bf2d91cd8fd45ad3bf646aa21f16adf1504d6548a94cffd25aca29b5a76b598a9c56c02141ba904570004268310bb4e050d81e8418d95b32e8d6e52512aabd6ab4cdea68748b122808b11a061b9a3e6cf2c907201a109870efd5a4500baf1c1b455d7d9585e1c4535fa98b0d2cdd5e055e637203a13b97610c2ef42d26e8b5fed3d2781c5b53baf6e400c63124e53279c8871fd0966556153b29df4c4d5e9db5aa0819ffe38f8670aa19d4554f653497ebdf543d9a319102a7b623f3fe1e65703bf90bfd516636051a0e5cba98eef8f1a2ca5fa8d2607e3db00f32cb00d862be6afbcedf91bfda05b2f06da008dd0929dff59a0771724d671fcd7dc8033ae51865411668cf2634b0d7635261ae554db5731005da309e76b53c0c6c48a6ee0fc8d48509b78db7b13b90f0916f679f3a276737e506a5bc2815367d87232ed761a469b64dc9e503ebf0d189422cf8fa09ba84bc5f3be17390b038930f92fb7e6dac26d86b54060421af6a850cb07258e0219e7b3dd6c2c5e987b9ace70207024cce3a1edb2f38943f1e2e6ae5a1e4f1205775b05650cf6eb80872c2330d3aeed4b7c85d9a73150ff36ea36a55429983103842a9de18cbefef567c8fdc5406cde853853a9d31b7fbc0b7e4dae61a5a10ccb072e717eeec4a15accd5ab92640311753e93a45fb85f700ebd5d2e8155f4344a699cff3d8505427d1ce49927243ef3aae02c333a5dcdf42a82afbee684670216c3754f84fa535e47029ceddbf4b0b3cd6d8e229439756139106c0184c11e7ecd9f70e6873f842196247b52ebc0e7b77b70569505ad33660e05c9373b75186418ef1d79b03a9fc071c2c207d5e4e4486472b400baa01adb0d8afc69633742921cdd3258d5aa4ab1d56d2f6dcecd56ec366dc2a71471ac41cd47d91b19bc75aac9ecff97e7ecf18b0a335767c59bae64dae25fbe9d3e1c075100455644a0f9793083b51e4cbd976fd8aae125f153b64904a33d25567b1168a58e3164343116fc104058408e653d633759745af1a0f489975a7077870ab381be04d36ff8249667069cf64e1a1fd15388ff4928b2a65638cdc37202d9ffc45e72cebe46a32562cd21315078f3dbd5546837375521ef6087610622419265d0eceedfe2c38a12b422cd24c7e95c814e37d53961ba6274699636c3d23c84dbe2b5299192e5b6a06b876d13838a85e0d88f1089b8d29aae915c08fc54e0dd44952f0d480eedc75968967f8bec8a67716c15c131b924fe15f319fcc3fe4754cb2ba3c09090195a3cdb5cfc397d6388787a6ae28c692fcef03162a62845b3a6510f393362b628f614fa56cdfa0fc067c5fc1ebfe7c563494d2b5f7c1d60c78d83dca6092a87fde0d1fc258309cb4affdd602ebba9e39cbb762db6577b233b5735aa505a1e73b71508fec36b611ff53968fb4ef000a1b77f627cc4684fb08f0fd14b96c93517ef31e79ee484119be4a715d56401b069cd1c5d48c25a2cca37b12f1dc2881415db28a7c90adaee7683926fb40e853fdfad16492697f9764de4f535cc8e23dd871833441188ef84b77686caef14d19b8efa0c9d939c899215c1f425c0533c3c32be3c969732726e5d550664203fab5d080e9191488a640f50b417e89b7372ce5fccff07b2c90cbe2c03015eaabc06cbc994f898d1d906cc8a2189806805ce8919d550f40c2b6ca676343ee369ba979701cd76f011b4ddbffe73a39339adf495a3e3b4202a909df4d4ca398c0ad03c8f0efa9611c7485d6a06c8b5efcb2eb7dc9b81796cf20e416f6c5e600273191329252f5c5d1855f404de1492a572e9d23c1489d73b7cd22a71541bd8f2418189ad024895f9fb7afbd0e3559ece172fec515ace0e94d29e50631a5e2e7234f727a945d57b7304585db44cbab4c5ceac6a391e4f7f89fe4af2114e6e654d7396836407ba61cf6dea85cc568655f4832fe11e4581596e00ccf6f8a17c894c53a35b58f3d0a0538e636aa90753e5d6f373a2248dc88ff0d05b2a139acc181c1df63bb81121d0df33de18aefac6ee6a4b62db45e35119ec07698f56ef5e3e9e5046945a49024ee31b67b08e7bbe1e1342365a97c1293a5e4faf6ebaae6187236356dfe51b62d7fdca8ca0e91717ec7103f9b7bd36758f2c7fd09d2fed1efb7a4d78b352f97039f1298a2fa001d787a59d7bd37c426e824e604e947b2cd7ef8ebfb5b708412c2ee6c1cdd3970efd8a9bd73015cd5e8b28e3699ac98d91122f4e286ab871190943961956438e62fa57de504c623be3bfb22789a8595822f13d69351c28b9f60d07b4fa4e33d0265df691eaf214417840bc9bff95ad87f249b51ac624722092e66084f47a3055ab30adb076b7ff82bbcf0beeca816befea133fe5410968652bfe441814b37ee20ab62a1e0282e14a5d3965cf9d996479291d1c936bc012720800ede19ffdc984d9a78f600986ecd76ad7d665707674d1e38c6dc15e1d60753968a1fad1cbb1ec3858e0bf50ed9239c08adc9c24f089abd7f4837cb53cb451e0f421635eac764de34d3b8fee7971f6b0f39d710846a1db30d3cd44a5ace8164f45cb7ab686997efa7436ae50bcf7ec9ebd543756731e35075e9f6144568b57d6441097899fe777de7352d0b132ce23ae8b594426b79c3e7e450e3980fe10bda9ba064f928d17f029f03ba0839cbad56d6e1380c3a04373a62a88ba2e91716dc8d65bd7898b69da00d719d52cb8005ad46c44c34058bb8efb4447edfc65aee610d28c92e6cd29e29</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">You know what this means.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> letter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂记录</title>
      <link href="/2022/11/24/issues/"/>
      <url>/2022/11/24/issues/</url>
      
        <content type="html"><![CDATA[<h1 id="常见小问题"><a href="#常见小问题" class="headerlink" title="常见小问题"></a>常见小问题</h1><h2 id="终端无法运行脚本"><a href="#终端无法运行脚本" class="headerlink" title="终端无法运行脚本"></a>终端无法运行脚本</h2><p>参考<a href="https://go.microsoft.com/fwlink/?LinkID=135170">Microsoft文档</a> 中about_Execution_Policies</p><h2 id="备份博客源文件"><a href="#备份博客源文件" class="headerlink" title="备份博客源文件"></a>备份博客源文件</h2><p>有时候我们想换一台电脑继续写博客，这时候就可以将博客目录下的所有源文件都上传到github上面。</p><h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><p>首先在github博客仓库下新建一个分支<code>hexo_src</code>，然后<code>git clone</code>到本地，把<code>.git</code>文件夹拿出来，放在博客根目录下。</p><p>然后<code>git checkout -b hexo_src</code>切换到<code>hexo_src</code>分支，然后<code>git add .</code>，然后<code>git commit -m &quot;xxx&quot;</code>，最后<code>git push origin hexo_src</code>提交就行了。</p><h3 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h3><p>首先在指定文件夹clone下来hexo_src分支</p><pre><code class="bash">$ git clone -b hexo_src [仓库地址]</code></pre><p>在该clone下来的文件夹里去安装hexo</p><pre><code class="bash">$ cnpm install hexo$ cnpm install//这一句不知道和上面这一句有何区别</code></pre><blockquote><p>特别注意，hexo_src中的theme文件夹在上传分支后为空，需要再次从原主题仓库clone下来处理</p></blockquote><h2 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h2><p>hexo+github+vercel+godaddy+dnspod</p><p>框架+GitHub存储 +网站托管服务 +域名注册+域名服务器DNS</p><p>先用着</p><p>上面已经备份之后，再继续进行操作就只需在hexo_src分支下进行</p><p>hexo的操作，以及git操作</p><p>批处理</p><pre><code class="bash">hexo clean;hexo g;hexo d;git status ;git add . ;git commit -m &#39;new push&#39;;git push origin hexo_src</code></pre><p>挺方便</p><h2 id="添加404页面"><a href="#添加404页面" class="headerlink" title="添加404页面"></a>添加404页面</h2><p>(这里为暂时收录的参考)</p><p>原来的主题没有404页面，加一个也不是什么难事。首先在&#x2F;source&#x2F;目录下新建一个404.md，内容如下：</p><pre><code>title: 404date: 2019-07-19 16:41:10type: &quot;404&quot;layout: &quot;404&quot;description: &quot;你来到了没有知识的荒原 :(&quot;</code></pre><p>然后在&#x2F;themes&#x2F;matery&#x2F;layout&#x2F;目录下新建一个404.ejs文件，内容如下：</p><pre><code class="ejs">&lt;style type=&quot;text/css&quot;&gt;    /* don&#39;t remove. */    .about-cover &#123;        height: 75vh;    &#125;&lt;/style&gt;&lt;div class=&quot;bg-cover pd-header about-cover&quot;&gt;    &lt;div class=&quot;container&quot;&gt;        &lt;div class=&quot;row&quot;&gt;            &lt;div class=&quot;col s10 offset-s1 m8 offset-m2 l8 offset-l2&quot;&gt;                &lt;div class=&quot;brand&quot;&gt;                    &lt;div class=&quot;title center-align&quot;&gt;                        404                    &lt;/div&gt;                    &lt;div class=&quot;description center-align&quot;&gt;                        &lt;%= page.description %&gt;                    &lt;/div&gt;                &lt;/div&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;</code></pre><h2 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h2><p>采用</p><p> jsdelivr (cdn) + github 存储 + PicGo </p><p>方案</p><p>&#x2F;&#x2F; load any GitHub release, commit, or branch</p><p>&#x2F;&#x2F; note: we recommend using npm for projects that support it</p><p><a href="https://cdn.jsdelivr.net/gh/user/repo@version/filecdn+">https://cdn.jsdelivr.net/gh/user/repo@version/filecdn+</a></p><h2 id="遇到的一些问题"><a href="#遇到的一些问题" class="headerlink" title="遇到的一些问题"></a>遇到的一些问题</h2><p>1 Q&amp;E</p><pre><code class="bash">platform unsupported hexo-deployer-git@3.0.0 › hexo-fs@3.1.0 › chokidar@3.5.3 › fsevents@~2.3.2 Package require os(darwin) not compatible with your platform(win32)[fsevents@~2.3.2] optional install error: Package require os(darwin) not compatible with your platform(win32)</code></pre><p>A 这是一个可以忽略的错误，fsevents是可选的依赖，只能应用于maxOS系统，不适合Windows或者Linux，也就是忽略即可</p>]]></content>
      
      
      
        <tags>
            
            <tag> record&amp;reference </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游玩LaTeX</title>
      <link href="/2022/11/23/LaTeX/"/>
      <url>/2022/11/23/LaTeX/</url>
      
        <content type="html"><![CDATA[<h1 id="LaTeX笔记"><a href="#LaTeX笔记" class="headerlink" title="LaTeX笔记"></a>LaTeX笔记</h1><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><pre><code class="latex">//English\documentclass&#123;article&#125;\begin&#123;document&#125;&quot;Hello world!&quot; from \LaTeX\end&#123;document&#125;//中文\documentclass&#123;ctexart&#125;\begin&#123;document&#125;“你好，世界！” 来自 \LaTeX&#123;&#125; 的问候  //怀疑这里新版本不需要&#123;&#125;占空格了\end&#123;document&#125;</code></pre><h2 id="相关概念辨析"><a href="#相关概念辨析" class="headerlink" title="相关概念辨析"></a>相关概念辨析</h2><h3 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h3><p>排版引擎是编译源代码并生成文档的程序，如pdfLaTeX、XeLaTeX等。有时也称为编译器</p><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>是定义了一组命令的代码集。如LaTeX。高纳德本人也编写了一个简单的plain TeX格式，但仍不便于使用</p><h3 id="编译命令"><a href="#编译命令" class="headerlink" title="编译命令"></a>编译命令</h3><p>是实际调用的、结合了引擎和格式的命令。如<code>xelatex</code>命令是结合了XeTeX引擎和LaTeX格式的一个编译命令</p>]]></content>
      
      
      
        <tags>
            
            <tag> LaTeX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chem-E-Car 小车动力控制电路部分记录</title>
      <link href="/2022/10/13/Car_Doc/"/>
      <url>/2022/10/13/Car_Doc/</url>
      
        <content type="html"><![CDATA[<h2 id="材料选用"><a href="#材料选用" class="headerlink" title="材料选用"></a>材料选用</h2><p>主板：ARDUINO UNO R3</p><p>拓展板：ARDUINO MOTOR SHIELD REV3</p>]]></content>
      
      
      
        <tags>
            
            <tag> Chem-E-Car </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ToDo</title>
      <link href="/2022/08/13/Todo/"/>
      <url>/2022/08/13/Todo/</url>
      
        <content type="html"><![CDATA[<h1 id="接下来的任务"><a href="#接下来的任务" class="headerlink" title="接下来的任务"></a>接下来的任务</h1><ul><li>hexo更深度自定义主题</li><li>favicon自定义</li><li>404页面</li><li>图床建设</li><li>图片模式选用</li><li>用户名重新选择</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> todo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Notes For Git</title>
      <link href="/2022/07/14/Notes-For-Git/"/>
      <url>/2022/07/14/Notes-For-Git/</url>
      
        <content type="html"><![CDATA[<h1 id="Notes-For-Git"><a href="#Notes-For-Git" class="headerlink" title="Notes For Git"></a>Notes For Git</h1><h2 id="Settings"><a href="#Settings" class="headerlink" title="Settings"></a>Settings</h2><pre><code class="bash">$ git config --list --show-originfile:D:/Git/etc/gitconfig       diff.astextplain.textconv=astextplainfile:D:/Git/etc/gitconfig       filter.lfs.clean=git-lfs clean -- %ffile:D:/Git/etc/gitconfig       filter.lfs.smudge=git-lfs smudge -- %ffile:D:/Git/etc/gitconfig       filter.lfs.process=git-lfs filter-processfile:D:/Git/etc/gitconfig       filter.lfs.required=truefile:D:/Git/etc/gitconfig       http.sslbackend=opensslfile:D:/Git/etc/gitconfig       http.sslcainfo=D:/Git/mingw64/ssl/certs/ca-bundle.crtfile:D:/Git/etc/gitconfig       core.autocrlf=truefile:D:/Git/etc/gitconfig       core.fscache=truefile:D:/Git/etc/gitconfig       core.symlinks=falsefile:D:/Git/etc/gitconfig       pull.rebase=falsefile:D:/Git/etc/gitconfig       credential.helper=managerfile:C:/Users/[]/.gitconfig        user.name=[]file:C:/Users/[]/.gitconfig        user.email=[]@[]$ git config --global user.name &quot;a&quot;$ git config --global user.email &quot;@&quot;$ git config --global core.editor &quot;code --wait&quot;$ git config --global core.editor &quot;code --wait&quot;$ git config --list$ git config user.name$ git config --global init.defaultBranch main$ git help &lt;verb&gt;$ git &lt;verb&gt; --help$ man git-&lt;verb&gt;</code></pre><p>There levels: <code>--local</code> &gt; <code>--global</code> &gt; <code>--system</code></p><p>On Windows systems, Git looks for the <code>.gitconfig</code> file in the $HOME directory (C:\Users$USER for most people). It also still looks for <code>[path]/etc/gitconfig</code>, although it’s relative to the MSys root, which is wherever you decide to install Git on your Windows system when you run the installer. </p><h2 id="Basics"><a href="#Basics" class="headerlink" title="Basics"></a>Basics</h2><h3 id="initializing"><a href="#initializing" class="headerlink" title="initializing"></a>initializing</h3><pre><code class="bash">$ cd D:/my_project$ git init</code></pre><p>to control a repository with git and this will create a file named <code>.git</code></p><p>we can initialize a repository like this:</p><pre><code class="bash">$ git add *.c$ git add LICENSE$ git commit -m &#39;Initial project version&#39;</code></pre><h3 id="cloning"><a href="#cloning" class="headerlink" title="cloning"></a>cloning</h3><p>we can clone a repository like this:</p><pre><code class="bash">$ git clone https://github.com/</code></pre><p>if want a new name </p><pre><code class="bash">$ git clone &lt;url&gt; name</code></pre><p>and there are other protocols that can be chosen(SSH)</p><h3 id="recording-changes"><a href="#recording-changes" class="headerlink" title="recording changes"></a>recording changes</h3><p>two states : tracked or untracked. To CHECK this :</p><pre><code class="bash">$ git statusOn branch masterYour branch is up-to-date with &#39;origin/master&#39;.nothing to commit, working tree clean$ git status -sM READMEMM RakefileA lib/git.rbM lib/simplegit.rb?? LICENSE.txt</code></pre><p>There are two columns to the output — the left-hand column indicates the status of the staging area and the right-hand column indicates the status of the working tree. </p><h3 id="Ignoring-Files"><a href="#Ignoring-Files" class="headerlink" title="Ignoring Files"></a>Ignoring Files</h3><pre><code class="bash">- .gitignore$ cat .gitignore*.[oa]*~# ignore all .a files*.a# but do track lib.a, even though you&#39;re ignoring .a files above!lib.a# only ignore the TODO file in the current directory, not subdir/TODO/TODO# ignore all files in any directory named buildbuild/# ignore doc/notes.txt, but not doc/server/arch.txtdoc/*.txt# ignore all .pdf files in the doc/ directory and any of its subdirectoriesdoc/**/*.pdf</code></pre><h3 id="Viewing-Your-Staged-and-Unstaged-Changes"><a href="#Viewing-Your-Staged-and-Unstaged-Changes" class="headerlink" title="Viewing Your Staged and Unstaged Changes"></a>Viewing Your Staged and Unstaged Changes</h3><p><code>git diff</code> shows you the exact lines added and removed — the patch, as it were</p><h3 id="Commit-Your-Changes"><a href="#Commit-Your-Changes" class="headerlink" title="Commit Your Changes"></a>Commit Your Changes</h3><p><code>git commit</code> 这样需要打开编辑器输入</p><p><code>git commmit -m &quot;There is message&quot;</code></p><pre><code class="bash">$ git commit -m &quot;Story 182: fix benchmarks for speed&quot;[master 463dc4f] Story 182: fix benchmarks for speed2 files changed, 2 insertions(+)create mode 100644 README</code></pre><p><code>git commit -a</code> 可以跳过stage阶段</p><h3 id="Removing-Files"><a href="#Removing-Files" class="headerlink" title="Removing Files"></a>Removing Files</h3><p>remove it from your tracked files, and also removes the file from your working directory so you don’t see it as an untracked file the next time around</p><p><code>rm</code> 直接删除，但是不stage</p><p><code>git rm</code> 删除，但是已经stage</p><p>If you modified the file or had already added it to the staging area, you must force the removal with the <code>-f</code> option. </p><p>to keep the file in your working tree but remove it from your staging area.</p><p><code>git rm --cached README</code></p><h3 id="Moving-Files"><a href="#Moving-Files" class="headerlink" title="Moving Files"></a>Moving Files</h3><p>重命名</p><pre><code class="bash">$ git mv README.md README$ git statusOn branch masterYour branch is up-to-date with &#39;origin/master&#39;.Changes to be committed:(use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)renamed: README.md -&gt; README</code></pre><p>相当于</p><pre><code class="bash">$ mv README.md README$ git rm README.md$ git add README</code></pre><h3 id="Viewing-the-Commit-History"><a href="#Viewing-the-Commit-History" class="headerlink" title="Viewing the Commit History"></a>Viewing the Commit History</h3><p><code>git log</code> 查看commit history</p><p><code>git log -patch</code> 显示每次的commit的不同之处</p><p><code>git log -2</code> 只看最近两条</p>]]></content>
      
      
      
        <tags>
            
            <tag> Git notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Algorithm</title>
      <link href="/2022/06/28/Algorithm/"/>
      <url>/2022/06/28/Algorithm/</url>
      
        <content type="html"><![CDATA[<h1 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h1><h3 id="1dim-peak-finder"><a href="#1dim-peak-finder" class="headerlink" title="1dim peak finder"></a>1dim peak finder</h3><p>$$\Theta (n)  $$ </p><p>if we adopt <strong>divide &amp; conquer</strong> </p><p>the complexity will be </p><p>$$T(n) &#x3D; T(\frac n2)+ \Theta(1)$$</p><p>and there is the base case :</p><p>$$T(1)&#x3D;\Theta(1)$$</p><p>thus </p><p>$$<br>T(n)&#x3D; \Theta(1) +\Theta(1)+…+\Theta(1)<br>    &#x3D; \Theta(\log _{2} n)<br>$$</p>]]></content>
      
      
      
        <tags>
            
            <tag> algorithm notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>My Raspberry Pi</title>
      <link href="/2021/02/13/My-Raspberry-Pi/"/>
      <url>/2021/02/13/My-Raspberry-Pi/</url>
      
        <content type="html"><![CDATA[<h2 id="About-Raspberry-Pi"><a href="#About-Raspberry-Pi" class="headerlink" title="About Raspberry Pi"></a>About Raspberry Pi</h2><p>这里本来打算放张图片</p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><h3 id="最理想情况"><a href="#最理想情况" class="headerlink" title="最理想情况"></a>最理想情况</h3><p>官网下载Pi OS镜像，烧录SD卡，连接好键盘显示屏，启动</p><h3 id="无显示屏"><a href="#无显示屏" class="headerlink" title="无显示屏"></a>无显示屏</h3><ul><li>开启ssh访问，在boot目录新建<code>ssh</code>的不带后缀名的空文件。</li><li>用RJ45网线连接笔记本电脑和树莓派。</li><li>等待树莓派启动完毕，打开笔记本电脑的网络和共享中心，可以看到出现了一个未识别网络，连接方式是以太网。然后再查看分配给这个以太网的接口IP地址（如192.168.137.1）</li><li>手机开热点，通过它可以让树莓派联网。在网络和共享中心中，点击无线网络-&gt;属性-&gt;共享 ，给“允许其它网络用户通过此计算机的internet来连接”打勾，然后确定。</li><li>打开CMD，输入以下命令查看网络接口信息：<code>arp -a</code></li><li>在前面查到的接口：192.168.137.1 下方找到第一个连接的ip地址，即为树莓派的ip地址。</li><li>打开PuTTY<ul><li>host 填入: 开发板 ip 即可。</li><li>用户名、密码同串口登陆一致（默认：pi、raspberry）</li></ul></li></ul><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="更新软件源"><a href="#更新软件源" class="headerlink" title="更新软件源"></a>更新软件源</h3><p>首先查看自己树莓派系统版本，一般有jessie,stretch,buster,wheezy这4个版本。</p><pre><code>No LSB modules are available.Distributor ID:RaspbianDescription:Raspbain GNU/Linux 10 (buster)Release:10Codename: busterCopy</code></pre><p>开始换源</p><pre><code>sudo vim /etc/apt/sources.listCopy</code></pre><p>将默认的内容删掉或者用<code>#</code>号注释，改为</p><pre><code>deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/   buster main contrib non-free rpideb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main contrib non-free rpiCopy</code></pre><p>或者用以下地址代替上面的地址栏</p><p>中山大学<br><a href="https://link.zhihu.com/?target=http://mirror.sysu.edu.cn/raspbian/raspbian/">Raspbian http://mirror.sysu.edu.cn/raspbian/raspbian/</a></p><p>中国科学技术大学<br><a href="https://link.zhihu.com/?target=http://mirrors.ustc.edu.cn/raspbian/raspbian/">Raspbian http://mirrors.ustc.edu.cn/raspbian/raspbian/</a></p><p>清华大学<br><a href="https://link.zhihu.com/?target=http://mirrors.tuna.tsinghua.edu.cn/raspbian/">Raspbian </a><a href="https://link.zhihu.com/?target=http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/">http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/</a></p><p>华中科技大学<br><a href="https://link.zhihu.com/?target=http://mirrors.hustunique.com/raspbian/raspbian/">Raspbian http://mirrors.hustunique.com/raspbian/raspbian/</a></p><p><a href="https://link.zhihu.com/?target=http://mirrors.hustunique.com/archlinuxarm/">Arch Linux ARM http://mirrors.hustunique.com/archlinuxarm/</a></p><p>大连东软信息学院源（北方用户）</p><p><a href="https://link.zhihu.com/?target=http://mirrors.neusoft.edu.cn/raspbian/raspbian/">Raspbian http://mirrors.neusoft.edu.cn/raspbian/raspbian/</a></p><p>（可参考Ubuntu配置）</p><p>再更新</p><pre><code>sudo apt updateCopy</code></pre><p>更新系统软件</p><pre><code>sudo apt upgradeCopy</code></pre><h2 id="Web项目"><a href="#Web项目" class="headerlink" title="Web项目"></a>Web项目</h2><h3 id="LNSP"><a href="#LNSP" class="headerlink" title="LNSP"></a>LNSP</h3><p>Linux Nginx SQLite PHP</p><pre><code>sudo apt install nginxsudo apt install php7.3sudo apt install php7.3-fpmsudo apt install php7.3-sqlitesudo apt install php7.3-commonsudo apt install sqliteCopy</code></pre><ul><li>启动 nginx</li></ul><pre><code>sudo /etc/init.d/nginx startCopy</code></pre><ul><li>修改 nginx 的配置文件</li></ul><pre><code>sudo vim /etc/nginx/sites-available/defaultCopy</code></pre><ul><li>PHP 脚本支持</li></ul><p>找到 php 的定义段，将这些行的注释去掉 ，修改后内容如下</p><pre><code># Default server configuration#server &#123;        listen 80 default_server;        listen [::]:80 default_server;         root /var/www/html;         # Add index.php to the list if you are using PHP        index index.html index.htm index.nginx-debian.html index.php;         server_name _;         location / &#123;                 # First attempt to serve request as file, then                 # as directory, then fall back to displaying a 404.                 try_files $uri $uri/ =404;        &#125;         # pass PHP scripts to FastCGI server        #        location ~ \.php$ &#123;                 # include snippets/fastcgi-php.conf;                 #                 # # With php-fpm (or other unix sockets):                 fastcgi_pass unix:/run/php/php7.3-fpm.sock;                 # # With php-cgi (or other tcp sockets):                 # fastcgi_pass 127.0.0.1:9000;                 # 设置脚本文件请求的路径                 fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;                 # 引入fastcgi的配置文件                  include fastcgi_params;        &#125; &#125;Copy</code></pre><ul><li>重新加载 nginx 的配置</li></ul><pre><code>sudo /etc/init.d/nginx reloadCopy</code></pre><ul><li>测试 html</li></ul><p>通过主机的 IE 访问树莓派，可以看到主页 (表示 Web 服务器已正常启动)</p><ul><li>测试 php</li></ul><p>输入下列命令</p><pre><code>sudo chmod 777 /var/            #下面三行给文件授予权限sudo chmod 777 /var/wwwsudo chmod 777 /var/www/htmlCopy</code></pre><p>在树莓派中生成一<code>php</code>文件</p><pre><code>sudo vim /var/www/index.phpCopy</code></pre><p>在文件中输入以下内容</p><pre><code>&lt;?php    print &lt;&lt;&lt; EOT  &lt;!doctype html&gt;  &lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;Test successful&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;  &lt;h1&gt;Test successful&lt;/h1&gt;  &lt;p&gt;Congratulations.&lt;/p&gt;  &lt;p&gt;Your webserver and PHP are working.&lt;/p&gt;  &lt;/body&gt;  &lt;/html&gt;  EOT;  ?&gt;Copy</code></pre><p>到此为止，lnsp就安装完毕</p><h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><p>官方</p><pre><code>wget https://nodejs.org/dist/v12.16.1/node-v00.00.0-linux-armv7l.tar.xzCopy</code></pre><p>国内镜像</p><pre><code>wget https://npm.taobao.org/mirrors/node/latest/node-v00.00.0-linux-armv7l.tar.xzCopy</code></pre><p>解压：</p><pre><code>xz -d node-v12.13.1-linux-armv7l.tar.xztar -xavf node-v12.13.1-linux-armv7l.tarCopy</code></pre><p>将系统内原本存在的<code>/usr/bin.node</code>删除</p><pre><code>sudo rm -rf /usr/bin/node#如果不存在，忽略此步骤Copy</code></pre><p>解压后，将二进制包移动到<code>/usr/local/node</code>下</p><pre><code>sudo mv ./node-v10.0.0-linux-armv7l /usr/local/nodeCopy</code></pre><p>为<code>node</code>和<code>npm</code>建立软连接，在终端输入：</p><pre><code>sudo ln -s /usr/local/node/bin/node /usr/bin/nodesudo ln -s /usr/local/node/bin/npm /usr/bin/npm#这类似于Windows中的快捷方式Copy</code></pre><p>通过查看<code>node</code>和<code>npm</code>版本的方式来查看是否成功</p><pre><code>node -v &amp;&amp; npm -vCopy</code></pre><p>可以看到对应的版本号说明安装成功</p><p>由于国内网速问题<code>npm</code>包管理器的速度会较慢，利用<code>npm</code>安装<code>cnpm</code>某宝源</p><pre><code>npm install -g cnpm --registry=https://registry.npm.taobao.orgCopy</code></pre><p>为<code>cnpm</code>建立软连接</p><pre><code>sudo ln -s /usr/local/node/bin/cnpm /usr/bin/cnpmCopy</code></pre><blockquote><p>Windows cnpm</p><pre><code>$ npm install cnpm -gCopy</code></pre><p>If you’re in China, maybe you should install it from our <a href="https://npm.taobao.org/">China mirror</a>:</p><pre><code>$ npm install cnpm -g --registry=https://r.npm.taobao.orgCopy</code></pre></blockquote><h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h3><p>至于软件，暂时选用Hexo，虽然还有Typecho、WordPress备选，但是先尝试这个。</p><p>主题参考</p><ul><li><a href="https://github.com/fluid-dev/hexo-theme-fluid">fluid</a>（主要看上了打字机特效）</li><li><a href="https://linhong.me/2020/01/27/hexo-theme-aomori/">Aomori</a>（看上了右边栏特效）</li><li><a href="https://github.com/lixuetaoleo/hexo-theme-leo">Ieo</a>（封面）</li><li><a href="https://sharvaridesai.github.io/hexo-theme-edinburgh-demo/">Edinburgh</a>（看设计感）</li><li><a href="https://mrwillcom.github.io/">mrwill</a>（设计感）</li></ul><h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><p>在本地完成hexo渲染，部署public文件夹到树莓派，完整文件夹git到github仓库。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="Linux-常用命令"><a href="#Linux-常用命令" class="headerlink" title="Linux 常用命令"></a>Linux 常用命令</h3><p>文件改名 <code>sudo mv test.txt new.txt\</code></p><ul><li><strong>mkdir xxx</strong> 创建文件夹xxx</li><li><strong>mkdir a1 a2 a3</strong> 批量创建文件夹 a1、文件夹 a2、文件夹 a3</li><li><strong>mkdir -p b1&#x2F;b2&#x2F;b3</strong> 连续创建文件夹 b1、文件夹 b2、文件夹 b3</li></ul><h3 id="RPI串口电路"><a href="#RPI串口电路" class="headerlink" title="RPI串口电路"></a>RPI串口电路</h3>]]></content>
      
      
      
        <tags>
            
            <tag> Raspberry Pi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A Guide to rebuid the workplace</title>
      <link href="/2020/07/04/guide/"/>
      <url>/2020/07/04/guide/</url>
      
        <content type="html"><![CDATA[<h1 id="重新搭建现有工作环境的指南"><a href="#重新搭建现有工作环境的指南" class="headerlink" title="重新搭建现有工作环境的指南"></a>重新搭建现有工作环境的指南</h1><h2 id="电脑配置清单"><a href="#电脑配置清单" class="headerlink" title="电脑配置清单"></a>电脑配置清单</h2><ul><li>华硕(ASUS)PRIME Z390-A 主板 现价1749元 <a href="https://item.jd.com/100000542145.html">链接</a></li><li>英特尔(Intel)i7-9700KF 约价2799元 <a href="https://item.jd.com/100002106617.html#none">链接</a></li><li>英伟达(NVIDIA)GTX1660 约价1799元 <a href="https://item.jd.com/100003739778.html#none">链接</a>（不确定）</li><li>金士顿(Kingston)DDR4 2400 16GB 现价549元 <a href="https://item.jd.com/2551276.html">链接</a></li><li>三星(SAMSUNG)250GB SSD固态硬盘 M.2接口(NVMe协议) 现价499元 <a href="https://item.jd.com/100002183459.html">链接</a></li><li>西部数据(WD)蓝盘 1TB 现价299元 <a href="https://item.jd.com/675971.html">链接</a></li><li>罗技(Logitech)K310 键盘 现价149元 <a href="https://item.jd.com/712162.html#none">链接</a>（首选）<ul><li>罗技（G）G610机械键盘 现价479元 <a href="https://item.jd.com/3034311.html#none">链接</a>（备选）</li></ul></li><li>罗技（Logitech）M100r 鼠标 现价52.9元 <a href="https://item.jd.com/692919.html">链接</a>（首选）<ul><li>罗技（G）G502 HERO主宰者有线鼠标 现价379元 <a href="https://item.jd.com/100001691967.html#product-detail">链接</a>（备选）</li></ul></li><li>AOC I2490VXH5&#x2F;BS 23.8英寸 现价779元 <a href="https://item.jd.com/100002222528.html?dist=jd#none">链接</a></li><li>乔思伯（JONSBO）U5 银色 ATX机箱 现价499元 <a href="https://item.jd.com/8885801.html#crumb-wrap">链接</a>（不确定）</li><li>酷冷至尊（CoolerMaster） T20 CPU 散热器 现价49元 <a href="https://item.jd.com/19988002706.html#product-detail">链接</a></li><li>长城（GreatWall）额定500W HOPE-6000DS 电源 现价269元 <a href="https://item.jd.com/876229.html">链接</a></li><li>灵蛇（LINGSHE）鼠标垫 现价4.9元 <a href="https://item.jd.com/4062692.html">链接</a></li></ul><p>小计：9565.9元</p><h3 id="机械键盘品牌参考"><a href="#机械键盘品牌参考" class="headerlink" title="机械键盘品牌参考"></a>机械键盘品牌参考</h3><p>宁芝mini84</p><p>阿米洛sword</p><p>Filco</p><p>Leopold</p><p>杜伽</p><h2 id="应用列表"><a href="#应用列表" class="headerlink" title="应用列表"></a>应用列表</h2><h3 id="普通使用"><a href="#普通使用" class="headerlink" title="普通使用"></a>普通使用</h3><ul><li>chrome</li><li>Potplayer</li><li>Bandizip</li><li>Lantern</li><li>TranslucentTB</li><li>Xmind<ul><li>mindmaster</li><li>freemind</li></ul></li><li>坚果云</li><li>Joplin</li><li>Everything</li><li>Wox</li><li>网易云音乐</li><li>小黑盒</li><li>幕布</li><li>有道云笔记</li><li>Steam</li><li>Pokemmo</li><li>QuickLook</li></ul><h3 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h3><h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><ul><li>Git</li><li>Node.js</li><li>Hexo</li><li>Java JDk</li><li>Python</li><li>MinGW-64w</li><li>Tex Live</li><li>VMware Workstation<ul><li>ubuntu</li></ul></li><li>wsl子系统<ul><li>Ubuntu</li><li>VcXsrv</li></ul></li></ul><h4 id="编辑器-x2F-IDE"><a href="#编辑器-x2F-IDE" class="headerlink" title="编辑器&#x2F;IDE"></a>编辑器&#x2F;IDE</h4><ul><li><p>Visual Studio Code</p></li><li><p>Atom</p></li><li><p>Visual Studio</p></li><li><p>Codelite</p></li><li><p>Typora</p></li><li><p>Vim</p></li><li><p>Neovim</p></li><li><p>Eclipse</p></li><li><p>JetBrains系</p><ul><li>CLion(附破解)</li></ul></li></ul><h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><ul><li><p>Mockplus(做原型可选，主用XD)</p></li><li><p>达芬奇</p></li><li><p>Zeplin</p></li><li><p>Gimp</p></li><li><p>Adobe系</p><ul><li>Creative Cloud</li><li>Photoshop</li><li>Premiere Pro</li><li>Media ENcoder</li><li>Lightroom Classic</li><li>XD</li><li>Illustrator</li><li>Audition</li></ul></li></ul><h3 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h3><ul><li><p>FL Studio</p></li><li><p>guitar pro 7</p></li></ul><h3 id="字体资源列表"><a href="#字体资源列表" class="headerlink" title="字体资源列表"></a>字体资源列表</h3><p>文件在字体文件夹里</p><ul><li>Source Code Pro —adobe</li><li>思源黑体</li><li>思源宋体</li><li>禹卫书法行书简体</li></ul><h2 id="文件夹"><a href="#文件夹" class="headerlink" title="文件夹"></a>文件夹</h2><ul><li>Private</li><li>Material</li><li>Project</li></ul><h2 id="附各类应用配置"><a href="#附各类应用配置" class="headerlink" title="附各类应用配置"></a>附各类应用配置</h2><h4 id="Chrome"><a href="#Chrome" class="headerlink" title="Chrome"></a>Chrome</h4><p>&#x2F;&#x2F;不知道用户同步能不能用</p><p>扩展：gooreplacerv3.9（放在工具文件夹）</p><p>书签:</p><ul><li><p><a href="https://www.github.com/">Github</a></p></li><li><p><a href="https://translate.google.cn/?hl=zh-CN&tab=TT">Google 翻译</a></p></li><li><p><a href="https://www.zhihu.com/">知乎</a></p></li><li><p><a href="https://www.bilibili.com/">Bilibli</a></p></li><li><p><a href="https://www.jiumodiary.com/">鸠摩搜索</a></p></li><li><p><a href="https://bitbucket.org/product/">Bitbucket</a></p></li><li><p><a href="https://phys.org/">Phys.org</a></p></li><li><p><a href="https://www.feynmanlectures.caltech.edu/">The Feynman Lectures on Physics</a></p></li><li><p><a href="https://www.audiolibrary.com.co/">Audio Library</a></p></li><li><p><a href="http://www.doyoudo.com/">doyoudo</a></p></li><li><p><a href="http://pengzhihui.xyz/">稚晖的个人站</a></p></li><li><p><a href="https://xenwayne.top/">XenWayne‘s Blog</a></p></li><li><p><a href="https://rafaltomal.com/">Rafal Tomal</a></p></li><li><p><a href="https://esappear.github.io/clover/">Clover Tuan</a></p></li><li><p><a href="https://www.arduino.cc/">Arduino</a></p></li><li><p><a href="https://www.raspberrypi.org/">Raspberry Pi</a></p></li><li><p><a href="https://www.dandyweng.com/">翁天信 · Dandy Weng 的个人网站主页</a></p></li><li><p><a href="https://www.julydate.com/">七夏浅笑</a></p></li><li><p><a href="https://www.lhteam.top/">LHteam</a></p></li><li><p><a href="https://element.eleme.cn/#/zh-CN">Element</a></p></li><li><p><a href="https://crashcourse.club/">CrashCourse</a></p></li><li><p><a href="https://bigjpg.com/zh">Bigjpg</a></p></li><li><p><a href="https://dribbble.com/">Dribbble</a></p></li><li><p><a href="https://www.webdesignrankings.com/resources/lolcolors/">LOL Colors - Curated color palette inspiration</a></p></li><li><p><a href="https://www.bootcss.com/p/websafecolors/">Web安全色</a></p></li><li><p><a href="https://color.adobe.com/create/color-wheel/">adobeColor</a></p></li><li><p><a href="https://flatuicolors.com/">Palettes</a></p></li><li><p><a href="https://colorsupplyyy.com/app">Color Picker</a></p></li><li><p><a href="https://mycolor.space/">ColorSpace</a></p></li><li><p><a href="https://www.iconfont.cn/">iconfont</a></p></li><li><p><a href="https://www.freepik.com/">Free Vectors, Photos and PSD Downloads | Freepik</a></p></li><li><p><a href="https://unsplash.com/">Unsplash</a></p></li><li><p><a href="https://balsamiq.com/">Balsamiq</a></p></li><li><p><a href="https://www.easyicon.net/">Easyicon</a></p></li><li><p><a href="https://magdeleine.co/">Magdeleine</a></p></li><li><p><a href="https://www.splitshire.com/">SplitShire</a></p></li><li><p><a href="https://flaticons.net/">FlatIcons</a></p></li><li><p><a href="https://www.91sotu.com/">搜图导航</a></p></li><li><p><a href="https://huaban.com/">花瓣网</a></p></li><li><p><a href="https://acg.rip/">ACG.RIP</a></p></li><li><p><a href="http://www.xuanfengge.com/funny/html5/element/">HTML5元素周期表</a></p></li><li><p><a href="https://zigzagpack.com/">ZigZag Pack</a></p></li><li><p><a href="https://www.udemy.com/">Udemy</a></p></li><li><p><a href="https://www.yuque.com/guigumentor/guigu">鬼谷·全球 · 语雀</a></p></li><li><p><a href="https://liam.page/2014/09/08/latex-introduction/">一份其实很短的 LaTeX 入门文档 | 始终</a></p></li><li><p><a href="https://www.jianshu.com/p/b31ae75ab6df">好书整理-朗道十卷+费曼物理学讲义+中英文 - 简书</a></p></li><li><p><a href="https://apps.evozi.com/apk-sownloader/">Evozi Apps</a></p></li><li><p><a href="https://magi.com/">Magi</a></p></li><li><p><a href="https://www.geogebra.org/">GeoGebra</a></p></li></ul><h4 id="Visual-Studio-Code"><a href="#Visual-Studio-Code" class="headerlink" title="Visual Studio Code"></a>Visual Studio Code</h4><p>插件：</p><ul><li>Auto Rename Tag</li><li>Autoprefixer</li><li>beautify</li><li>Prettier - Code formatter(format on save 查找是否应用存文件时格式化)</li><li>Bracket Pair Colorizer 2</li><li>Chinese(Simplified)Language Pack for Visual Studio Code</li><li>Code Spell Checker</li><li>file-size</li><li>Guides</li><li>Highlight</li><li>Image preview</li><li>Latex Workshop(需额外配置，附配置文件)</li><li>Live Server</li><li>Markdown PDF</li><li>Markdown Preview Enhanced</li><li>Markdown Theme Kit</li><li>markdownlint</li><li>Material Theme</li><li>Community Material Theme</li><li>Material Theme Icons</li><li>Path intellisense</li><li>Settings Sync</li><li>SVG</li><li>C&#x2F;C++</li><li>Cobalt Next</li><li>Cobalt2 Theme Official</li><li>Code Runner</li><li>Marp for VS Code</li><li>Path Interllisense</li></ul><p>另附:</p><p>C语言环境设置<code>.vscode</code>在project的C文件夹里</p><p>VS Code 设置json文件</p><pre><code class="json">&#123;    &quot;workbench.iconTheme&quot;: &quot;material-icon-theme&quot;,    &quot;editor.renderIndentGuides&quot;: false,    &quot;workbench.colorTheme&quot;: &quot;Cobalt Next&quot;,    &quot;cSpell.userWords&quot;: [        &quot;Bandizip&quot;,        &quot;HWND&quot;,        &quot;Lightroom&quot;,        &quot;Minecraft&quot;,        &quot;Mockplus&quot;,        &quot;Mware&quot;,        &quot;Photoshop&quot;,        &quot;Potplayer&quot;,        &quot;Typora&quot;,        &quot;Xmind&quot;,        &quot;Zahlen&quot;,        &quot;Zeplin&quot;,        &quot;anchorjs&quot;,        &quot;cnzz&quot;,        &quot;doyoudo&quot;,        &quot;favicon&quot;,        &quot;hexo&quot;,        &quot;iconfont&quot;,        &quot;mware&quot;,        &quot;subseteq&quot;,        &quot;tencent&quot;,        &quot;v&quot;    ],    &quot;workbench.statusBar.visible&quot;: true,    &quot;editor.fontFamily&quot;: &quot;Source Code Pro,Consolas, &#39;Courier New&#39;, monospace&quot;,    &quot;workbench.startupEditor&quot;: &quot;newUntitledFile&quot;,    &quot;C_Cpp.updateChannel&quot;: &quot;Insiders&quot;,    // Latex workshop    &quot;latex-workshop.latex.tools&quot;: [        &#123;            // 编译工具和命令            &quot;name&quot;: &quot;latexmk&quot;,            &quot;command&quot;: &quot;latexmk&quot;,            &quot;args&quot;: [                &quot;-synctex=1&quot;,                &quot;-interaction=nonstopmode&quot;,                &quot;-file-line-error&quot;,                &quot;-pdf&quot;,                &quot;-outdir=%OUTDIR%&quot;,                &quot;%DOC%&quot;            ],            &quot;env&quot;: &#123;&#125;        &#125;,        &#123;            &quot;name&quot;: &quot;xelatex&quot;,            &quot;command&quot;: &quot;xelatex&quot;,            &quot;args&quot;: [                &quot;-synctex=1&quot;,                &quot;-interaction=nonstopmode&quot;,                &quot;-file-line-error&quot;,                &quot;-pdf&quot;,                &quot;-outdir=%OUTDIR%&quot;,                &quot;%DOC%&quot;            ]        &#125;,        &#123;            &quot;name&quot;: &quot;lualatexmk&quot;,            &quot;command&quot;: &quot;latexmk&quot;,            &quot;args&quot;: [                &quot;-synctex=1&quot;,                &quot;-interaction=nonstopmode&quot;,                &quot;-file-line-error&quot;,                &quot;-lualatex&quot;,                &quot;-outdir=%OUTDIR%&quot;,                &quot;%DOC%&quot;            ],            &quot;env&quot;: &#123;&#125;        &#125;,        &#123;            &quot;name&quot;: &quot;latexmk_rconly&quot;,            &quot;command&quot;: &quot;latexmk&quot;,            &quot;args&quot;: [                &quot;%DOC%&quot;            ],            &quot;env&quot;: &#123;&#125;        &#125;,        &#123;            &quot;name&quot;: &quot;pdflatex&quot;,            &quot;command&quot;: &quot;pdflatex&quot;,            &quot;args&quot;: [                &quot;-synctex=1&quot;,                &quot;-interaction=nonstopmode&quot;,                &quot;-file-line-error&quot;,                &quot;%DOC%&quot;            ],            &quot;env&quot;: &#123;&#125;        &#125;,        &#123;            &quot;name&quot;: &quot;bibtex&quot;,            &quot;command&quot;: &quot;bibtex&quot;,            &quot;args&quot;: [                &quot;%DOCFILE%&quot;            ],            &quot;env&quot;: &#123;&#125;        &#125;    ],    &quot;latex-workshop.latex.recipes&quot;: [        &#123;            &quot;name&quot;: &quot;xelatex&quot;,            &quot;tools&quot;: [                &quot;xelatex&quot;            ]        &#125;,        &#123;            &quot;name&quot;: &quot;latexmk 🔃&quot;,            &quot;tools&quot;: [                &quot;latexmk&quot;            ]        &#125;,        &#123;            &quot;name&quot;: &quot;xelatex ➞ xelatex&quot;,            &quot;tools&quot;: [                &quot;xelatex&quot;,                &quot;xelatex&quot;            ]        &#125;,        &#123;            &quot;name&quot;: &quot;xelatex ➞ bibtex ➞ xelatex × 2&quot;,            &quot;tools&quot;: [                &quot;xelatex&quot;,                &quot;bibtex&quot;,                &quot;xelatex&quot;,                &quot;xelatex&quot;            ]        &#125;,        &#123;            &quot;name&quot;: &quot;latexmk (latexmkrc)&quot;,            &quot;tools&quot;: [                &quot;latexmk_rconly&quot;            ]        &#125;,        &#123;            &quot;name&quot;: &quot;latexmk (lualatex)&quot;,            &quot;tools&quot;: [                &quot;lualatexmk&quot;            ]        &#125;,        &#123;            &quot;name&quot;: &quot;pdflatex ➞ bibtex ➞ pdflatex × 2&quot;,            &quot;tools&quot;: [                &quot;pdflatex&quot;,                &quot;bibtex&quot;,                &quot;pdflatex&quot;,                &quot;pdflatex&quot;            ]        &#125;    ],    &quot;latex-workshop.view.pdf.viewer&quot;: &quot;external&quot;,    &quot;latex-workshop.view.pdf.external.command&quot;: &#123;    &quot;command&quot;: &quot;D:/SumatraPDF/SumatraPDF.exe&quot;,    &quot;args&quot;: [        &quot;%PDF%&quot;    ]    &#125;,    &quot;latex-workshop.view.pdf.external.synctex&quot;: &#123;        //正向搜索        &quot;command&quot;: &quot;D:/SumatraPDF/SumatraPDF.exe&quot;,        &quot;args&quot;: [            &quot;-forward-search&quot;,            &quot;%TEX%&quot;,            &quot;%LINE%&quot;,            &quot;%PDF%&quot;        ]    &#125;,    &quot;latex-workshop.latex.clean.fileTypes&quot;: [        &quot;*.aux&quot;,        &quot;*.bbl&quot;,        &quot;*.blg&quot;,        &quot;*.idx&quot;,        &quot;*.ind&quot;,        &quot;*.lof&quot;,        &quot;*.lot&quot;,        &quot;*.out&quot;,        &quot;*.toc&quot;,        &quot;*.acn&quot;,        &quot;*.acr&quot;,        &quot;*.alg&quot;,        &quot;*.glg&quot;,        &quot;*.glo&quot;,        &quot;*.gls&quot;,        &quot;*.ist&quot;,        &quot;*.fls&quot;,        &quot;*.log&quot;,        &quot;*.fdb_latexmk&quot;    ],    &quot;latex-workshop.latex.autoBuild.run&quot;: &quot;never&quot;,    &quot;terminal.integrated.shell.windows&quot;: &quot;C:\\Windows\\System32\\cmd.exe&quot;,    &quot;sync.gist&quot;: &quot;ce4d87f82ed3f5648debe41732530e35&quot;,    &quot;cSpell.enableFiletypes&quot;: [        &quot;tex&quot;    ]    &#125;</code></pre><h4 id="Atom"><a href="#Atom" class="headerlink" title="Atom"></a>Atom</h4><p>插件：</p><ul><li>atom-beautify</li><li>atom-gpp-compiler</li><li>atom-live-server</li><li>atom-markdown-table-editor</li><li>atom-material-syntax</li><li>atom-material-syntax-dark</li><li>atom-material-syntax-light</li><li>atom-material-ui</li><li>atom-minimap-plus</li><li>atom-quick-highlight</li><li>atom-script</li><li>atom-simplified-chinese-menu</li><li>busy-signal</li><li>color-picker</li><li>emmet-atom</li><li>file-icons</li><li>intentions</li><li>linter</li><li>linter-gcc</li><li>linter-javac</li><li>linter-jshint</li><li>linter-markdown</li><li>linter-phpcs</li><li>linter-pylint</li><li>linter-ui-default</li><li>markdown-preview-enhanced</li><li>monoid-ui</li><li>monoid-syntax</li><li>seti-syntax</li><li>seti-ui</li></ul><h4 id="CLion"><a href="#CLion" class="headerlink" title="CLion"></a>CLion</h4><p>破解获取链接</p><pre><code>http://idea.medeming.com/jets/http://idea.medeming.com/jihuo/</code></pre><h4 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h4><p>主题</p><ul><li>Barfi</li><li>Cobalt</li><li>Github</li><li>Gitlab</li><li>Newsprint</li><li>Night</li><li>PixyII</li><li>Vue Dark</li><li>Vue</li><li>Whitey</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> guide </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Trip to Ubuntu</title>
      <link href="/2020/03/20/Trip-to-Ubuntu/"/>
      <url>/2020/03/20/Trip-to-Ubuntu/</url>
      
        <content type="html"><![CDATA[<h2 id="Trip-to-Ubuntu"><a href="#Trip-to-Ubuntu" class="headerlink" title="Trip to Ubuntu"></a>Trip to Ubuntu</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前几天我在Microsoft Store里发现了Ubuntu，它是运行在Windows上的子系统，第一时间我就开始了Ubuntu的配置探索之旅。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>我在Microsoft Store安装之后，发现它是装在C盘系统盘的，为了节省C盘空间，我采取了转移到非系统盘的方式</p><p>通过安装，我定位到了它的安装路径</p><pre><code>C:\Users\xxxx\AppData\Local\Packages\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc</code></pre><p>接着，我将它卸载，通过创建软链接来解决这个问题</p><p>先在想要安装的位置创建了Ubuntu文件夹</p><p>然后打开<code>cmd</code>终端，输入</p><pre><code class="bash">mklink /j C:\Users\XXXX\AppData\Local\Packages\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc  D:\Ubuntu\</code></pre><p>创建成功后，再重新在Microsoft Store中安装Ubuntu</p><p>安装过程中如果出现了安装失败的问题，可以运行</p><pre><code class="bash">icacls D:\Ubuntu /grant &quot;用户名:(OI)(CI)(F)&quot;</code></pre><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h4 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h4><p>清华源</p><ul><li>网址：<a href="https://link.zhihu.com/?target=https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/">https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/</a></li><li>源地址：<a href="https://link.zhihu.com/?target=https://mirrors.tuna.tsinghua.edu.cn/ubuntu/">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a></li></ul><pre><code># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse# 预发布软件源，不建议启用# deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</code></pre><p>阿里源</p><ul><li>网址：<a href="https://link.zhihu.com/?target=https://opsx.alibaba.com/guide?lang=zh-CN&document=69a2341e-801e-11e8-8b5a-00163e04cdbb">https://opsx.alibaba.com/guide?lang=zh-CN&document=69a2341e-801e-11e8-8b5a-00163e04cdbb</a></li><li>源地址：<a href="https://link.zhihu.com/?target=http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a></li></ul><pre><code># 默认注释了源码仓库，如有需要可自行取消注释deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse# deb-src https://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse# deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse# deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse# deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse# 预发布软件源，不建议启用# deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse# deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</code></pre><p>中科大源</p><ul><li>网址：<a href="https://link.zhihu.com/?target=http://mirrors.ustc.edu.cn/help/ubuntu.html">http://mirrors.ustc.edu.cn/help/ubuntu.html</a></li><li>源地址：<a href="https://link.zhihu.com/?target=https://mirrors.ustc.edu.cn/ubuntu/">https://mirrors.ustc.edu.cn/ubuntu/</a></li></ul><pre><code># 默认注释了源码仓库，如有需要可自行取消注释deb https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse# deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse# deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse# deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse# deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse# 预发布软件源，不建议启用# deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse# deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</code></pre><p>网易源</p><ul><li>网址：<a href="https://link.zhihu.com/?target=http://mirrors.163.com/.help/ubuntu.html">http://mirrors.163.com/.help/ubuntu.html</a></li><li>源地址：<a href="https://link.zhihu.com/?target=http://mirrors.163.com/">http://mirrors.163.com</a></li></ul><pre><code># 默认注释了源码仓库，如有需要可自行取消注释deb http://mirrors.163.com/ubuntu/ bionic main restricted universe multiverse# deb-src https://mirrors.163.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiverse# deb-src http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiverse# deb-src http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiverse# deb-src http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiverse# 预发布软件源，不建议启用# deb http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiverse# deb-src http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiverse</code></pre><p>先对系统给的镜像源进行备份，以防止出现问题</p><pre><code class="bash">$ sudo cp /etc/apt/sources.list /etc/apt/sources.list.backup </code></pre><p>然后，修改数据源配置文件</p><pre><code class="bash">$ sudo vim /etc/apt/sources.list</code></pre><p>选择一个源添加到文件最前面或直接将官方的源注释掉替换掉原文件</p><p>更新软件源中的所有软件列表：</p><pre><code class="bash">$ sudo apt-get update</code></pre><p>更新软件：</p><pre><code class="bash">$ sudo apt-get upgrade</code></pre><p>更新系统版本：</p><pre><code class="bash">$ sudo apt-get dist-upgrade</code></pre><p>下载中文语言包：</p><pre><code class="bash">$ sudo apt-get install language-pack-zh-han*</code></pre><h4 id="安装-C-x2F-C-开发环境"><a href="#安装-C-x2F-C-开发环境" class="headerlink" title="安装 C&#x2F;C++ 开发环境"></a>安装 C&#x2F;C++ 开发环境</h4><p>安装编译工具包：</p><pre><code class="bash">$ sudo apt-get install build-essential</code></pre><p>安装 nginx 依赖库：</p><pre><code class="bash">$ sudo apt-get install libpcre3 libpcre3-dev libpcrecpp0 libssl-dev zlib1g-dev</code></pre><h4 id="图形界面"><a href="#图形界面" class="headerlink" title="图形界面"></a>图形界面</h4><p>首先安装使用VcXsrv Windows X Server</p><p>启动Launcher，首次启动自动进入界面设置后，选择：“one large window”，Display number设置成0，其它默认即可：</p><p><strong>安装桌面环境</strong></p><pre><code class="bash">sudo apt-get install ubuntu-desktop unity compizconfig-settings-manager</code></pre><p>启动之前安装的X-Windows，在Bash中执行如下命令：</p><pre><code class="bash">export  DISPLAY=localhost:0ccsm</code></pre><p><strong>启动compiz (打开桌面)</strong></p><pre><code class="bash">compiz</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>first blog</title>
      <link href="/2020/02/02/first-blog/"/>
      <url>/2020/02/02/first-blog/</url>
      
        <content type="html"><![CDATA[<h2 id="这是我的第一条blog"><a href="#这是我的第一条blog" class="headerlink" title="这是我的第一条blog"></a>这是我的第一条blog</h2><p>今天我捣鼓着使用 hexo + Github 的方式搭建了自己的博客，从今天开始维护，希望自己能坚持下去。</p><p>加油鸭！！！</p>]]></content>
      
      
      
        <tags>
            
            <tag> first blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
